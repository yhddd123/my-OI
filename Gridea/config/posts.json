{
  "posts": [
    {
      "content": "## 关于我\n\n我是 yhm，也被称为 yhd，是一名 GDFZ 初三 oier，后面忘了。\n\n各网站账号为 gdf_yhm，gdfyhm，yhddd 中的一个。\n\n高一了。\n\n## 关于本博客\n\n由于各种博客各种问题，现在开始启用 gridea。之前用过 [cnblogs](https://www.cnblogs.com/yhddd)，现在搬迁过来。(24.10.18)\n\nnoip 前摆烂搭了另一个 [博客](https://yhddd123.github.io/qwerty)，一个有意思的尝试。(24.11.29)\n\n凡是之前的题解，都当做 23.12.31 写的，慢慢移过来。\n\n现在博客以做题记录为主，比较简略。有一些题目来源的链接是本校 oj。\n\n使用 [gridea-theme-next-master](https://github.com/hsxyhao/gridea-theme-next) 主题。注意到 Releases 和 Download ZIP 下出来的不是同个东西，而且似乎很久没更新了。目前主要的问题有：链接搞不了下划线，搜索功能比较弱智。\n\n评论使用 [utterances](https://garbageblog.github.io/utterances-help/)，比较好用。",
      "data": {
        "title": "About",
        "date": "3000-12-25 00:00:00",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "1",
      "data": {
        "title": "whk 随想",
        "date": "2025-03-17 22:21:42",
        "tags": [
          "随机说话"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "whk-sui-xiang"
    },
    {
      "content": "形如：给定 $m$ 次多项式 $f(k)$，求 $\\sum_{k=0}^n f(k)\\times \\dotsb$。$m$ 较小 $n$ 极大。\n\n### [P6620](https://www.luogu.com.cn/problem/P6620)\n\n求 $\\sum f(k)x^k\\binom{n}{k}$。\n\n普通幂转下降幂：$x^n=\\sum_{i=0}^n {n \\brace i}  x^{\\underline{i}}$。$f(k)=\\sum_{i=0}^m b_i k^{\\underline{i}}$。\n\n下降幂乘组合数：$\\binom{n}{k}\\times k^{\\underline{m}}=\\binom{n-m}{k-m}n^{\\underline{i}}$。\n\n$$=\\sum_{i=0}^m b_in^{\\underline{i}}\\sum_{k=0}^n\\binom{n-i}{k-i}x^k$$\n\n枚举 $k-i$，提出 $x^i$，二项式定理。\n\n$$=\\sum _{i=0}^m b_in^{\\underline{i}}\\sum_{k=0}^{n-i}\\binom{n-i}{k}x^{k+i}$$\n\n$$=\\sum _{i=0}^m b_in^{\\underline{i}}x^i(x+1)^{n-i}$$\n\n### [P6667](https://www.luogu.com.cn/problem/P6667)\n\n求 $\\sum_{k=0}^n f(k)\\binom{n,k}x^k(1-x)^{n-k}$。$f(k)$ 是 $m$ 次多项式，给出 $f_0,\\dotsb,f_{m}$ 的点值表示。\n\n二项式反演，设 $f_x=\\sum_{i=0}^{x} \\binom{x}{i} g_i$，则 $g_x=\\sum_{i=0}^x (-1)^{x-i}\\binom{x}{i} f_x$。卷积。\n\n$=\\sum_{i=0}^m g_i\\sum_{k=0}^{n}\\binom{k}{i}\\binom{n}{k}x^k(1-x)^{n-k}$。\n\n组合恒等式，枚举 $k-i$，提出 $x^i$，二项式定理。\n\n$$=\\sum_{i=0}^m g_i\\binom{n}{i}\\sum_{k=0}^n\\binom{n-i}{k-i}x^k(1-x)^{n-k}$$\n\n$$=\\sum_{i=0}^mg_i\\binom{n}{i}x^i$$\n\n",
      "data": {
        "title": "式子乱推",
        "date": "2025-02-24 22:24:45",
        "tags": [
          "笔记",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "shi-zi-luan-tui"
    },
    {
      "content": "[P9598](https://www.luogu.com.cn/problem/P9598)\n\n比较蠢的做法，原因是分块的对象错完了。\n\n### 思路\n\n加边删边可以线段树分治。只考虑 $[1,p]$ 部分。可以在 $[1,p-1]$ 的图的基础上加入右端点为 $p$ 的边，然后线段树分治回答所有在 $p$ 隔开的询问。同理，如果在 $[1,pl]$ 的图上线段树分治，到一个时间枚举在这个时间且 $p\\in [pl,pr]$ 的询问，直接加入小于当前时间且右端点属于 $[pl+1,p]$ 的边，询问，再删除这些边。\n\n所以分块，复杂度取决于右端点属于 $[pl+1,pr]$ 的边的数量和 $[pl,pr]$ 块数。设阈值 $B$，按右端点排序大概 $B$ 条边分成一块。对于当前左端点 $pl$，找到最小 $pr$ 满足右端点属于 $[pl,pr]$ 的边数 $>B$。但如果右端点等于 $pr$ 的边数 $>B$，就分 $[pl,pr)$ 和 $[pr,pr]$。这样可以保证右端点属于 $[pl+1,pr]$ 的边数 $<2\\times B$， $[pl,pr]$ 块数 $<2\\times \\frac{n}{B}$。\n\n对于每一块，都要对之前的边重新线段树分治一遍；对于每个询问，都要遍历块内之前的边。所有的加边删边操作都要可撤销并查集。复杂度 $O(\\frac{n}{B}n\\log^2 n+mB\\log n)$。取 $B=1000$ 跑的飞快。\n\n### code\n\n```cp\nint n,m,q,B=1000;\npii upd[maxn],que[maxn];\nint ans[maxn];\nvector<pii> edge[maxn],qq[maxn],ask[maxn];\nint num[maxn];\n#define mid (l+r>>1)\n#define ls nd<<1\n#define rs nd<<1|1\nvector<pii> tree[maxn<<2];\nint f[maxn],siz[maxn];\nint fd(int x){\n\tif(f[x]==x)return x;\n\treturn fd(f[x]);\n}\nint st[maxn],tp;\nvoid merge(int u,int v){\n\tu=fd(u),v=fd(v);\n\tif(u==v)return ;\n\tif(siz[u]<siz[v])swap(u,v);\n\tf[v]=u,siz[u]+=siz[v],st[++tp]=v;\n}\nvoid del(){\n\tint v=st[tp],u=f[v];\n\tf[v]=v,siz[u]-=siz[v];\n\ttp--;\n}\nvoid build(int nd,int l,int r){\n\ttree[nd].clear();\n\tif(l==r)return ;\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n}\nvoid updata(int nd,int l,int r,int ql,int qr,pii w){\n\tif(ql>qr)return ;\n\tif(l>=ql&&r<=qr){tree[nd].pb(w);return ;}\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\n}\nbool vis[maxn<<2];\nvoid modif(int nd,int l,int r,int p){\n\tvis[nd]=1;\n\tif(l==r)return ;\n\tif(p<=mid)modif(ls,l,mid,p);\n\telse modif(rs,mid+1,r,p);\n}\nint lst[maxn];\nvector<int> pos;\nvoid dfs(int nd,int l,int r){\n\tif(!vis[nd])return ;vis[nd]=0;\n\tint tmp=tp;\n\tfor(auto[u,v]:tree[nd])merge(u,v);\n\tif(l==r){\n\t\tfor(auto[p,id]:ask[l]){\n\t\t\tint nw=tp;\n\t\t\tfor(int i:pos){\n\t\t\t\tif(i>p)break;\n\t\t\t\tfor(auto[u,t]:edge[i]){\n\t\t\t\t\tif(t>l)break;\n\t\t\t\t\tlst[u]^=1;\n\t\t\t\t}\n\t\t\t\tfor(auto[u,t]:edge[i]){\n\t\t\t\t\tif(t>l)break;\n\t\t\t\t\tif(lst[u])merge(u,i),lst[u]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans[id]+=p-tp;\n\t\t\twhile(tp>nw)del();\n\t\t}\n\t\task[l].clear();\n\t}\n\telse dfs(ls,l,mid),dfs(rs,mid+1,r);\n\twhile(tp>tmp)del();\n}\nvoid sovle(){\n\tfor(int i=1;i<=n;i++)edge[i].clear();\n\tfor(int i=1;i<=m;i++){\n\t\tauto[u,v]=upd[i];\n\t\tif(u>v)swap(u,v);\n\t\tedge[v].pb({u,i});\n\t}\n\tfor(int i=1;i<=n;i++)num[i]=num[i-1]+edge[i].size();\n\tfor(int i=1;i<=n;i++)qq[i].clear();\n\tfor(int i=1;i<=q;i++){\n\t\tauto[t,p]=que[i];\n\t\tqq[p].pb({t,i});\n\t}\n\tfor(int i=1;i<=n;i++)f[i]=i,siz[i]=1;\n\tbuild(1,1,m);\n\tfor(int l=1,r=1;l<=n;l=r+1,r=l){\n\t\twhile(r<n&&num[r]-num[l-1]<B)r++;\n\t\tif(edge[r].size()>B&&l<r)r--;\n\t\tfor(auto[u,t]:edge[l]){\n\t\t\tif(lst[u])updata(1,1,m,lst[u],t-1,{u,l}),lst[u]=0;\n\t\t\telse lst[u]=t;\n\t\t}\n\t\tfor(auto[u,t]:edge[l])if(lst[u])updata(1,1,m,lst[u],m,{u,l}),lst[u]=0;\n\t\tfor(int i=l;i<=r;i++){\n\t\t\tfor(auto[t,id]:qq[i])ask[t].pb({i,id}),modif(1,1,m,t);\n\t\t}\n\t\tpos.clear();for(int i=l+1;i<=r;i++)if(edge[i].size())pos.pb(i);\n\t\tdfs(1,1,m);\n\t\tfor(int i=l+1;i<=r;i++){\n\t\t\tfor(auto[u,t]:edge[i]){\n\t\t\t\tif(lst[u])updata(1,1,m,lst[u],t-1,{u,i}),lst[u]=0;\n\t\t\t\telse lst[u]=t;\n\t\t\t}\n\t\t\tfor(auto[u,t]:edge[i])if(lst[u])updata(1,1,m,lst[u],m,{u,i}),lst[u]=0;\n\t\t}\n\t}\n}\nvoid work(){\n\tn=read();m=read();q=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint op=read(),u=read()+1,v=read()+1;\n\t\tupd[i]={u,v};\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint t=read()+1,p=read()+1;\n\t\tque[i]={t,p};\n\t}\n\tsovle();\n\tfor(int i=1;i<=m;i++){\n\t\tauto[u,v]=upd[i];\n\t\tupd[i]={n-u+1,n-v+1};\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tauto[t,p]=que[i];\n\t\tque[i]={t,n-p};\n\t}\n\tsovle();\n\tfor(int i=1;i<=q;i++)printf(\"%d\\n\",ans[i]);\n}\n```\n\n",
      "data": {
        "title": "P9598 题解",
        "date": "2025-02-21 14:35:56",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p9598-ti-jie"
    },
    {
      "content": "\n[CF1613F](https://www.luogu.com.cn/problem/CF1613F)\n\n### 思路\n\n容斥。钦定 $i$ 个点不满足 $c_u\\neq c_{fa}-1$ 的限制的方案数为 $f_i$，有 $n-1$ 对限制，$ans=\\sum_{i=0}^{n-1}(-1)^if_i$。\n\n由于 $c$ 是排列，每个点 $u$ 只有一个儿子能被钦定不合法。而没有被钦定的点之间大小关系独立，即 $(n-i)!$；被钦定的点的值取决于祖先最近的没有被钦定的点，这部分的贡献即每个点独立的选一个儿子或不选，即 $[x^i]\\prod(1+d_ux)$。\n\n只需要快速求出 $n$ 个一次的多项式相乘的系数，分治 ntt 复杂度 $O(n\\log^2 n)$。\n\n因为有 $\\sum d_u$ 是 $O(n)$ 的。将相同的 $(dx+1)$ 合起来做。记有 $t_i$ 个 $d_u=i$，$\\prod (ix+1)^{t_i}$ 可以二项式系数展开。按 $d_u$ 的值从大往小做，直接和之前算出来的多项式 ntt 乘起来，复杂度是对的。即每次 ntt 的长度之和 $\\sum_{i=1}^n (\\sum_{j=i}^n t_j)=\\sum i\\times t_i=\\sum d_u$，是 $O(n)$ 级别的。复杂度 $O(n\\log n)$。\n\n### code\n\n```cpp\nint n,ans;\nint d[maxn],t[maxn];\nvector<int> e[maxn];\nvoid dfs(int u,int fa){\n\tfor(int v:e[u])if(v!=fa)d[u]++,dfs(v,u);\n}\nvector<int> f;\nusing poly::mul;\nint fac[maxn],inv[maxn];\nint C(int m,int n){return fac[m]*inv[n]%mod*inv[m-n]%mod;}\nvoid work(){\n\tn=read();\n\tfor(int i=1;i<n;i++){\n\t\tint u=read(),v=read();\n\t\te[u].pb(v),e[v].pb(u);\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=n;i++)t[d[i]]++;\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n]);for(int i=n-1;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\tfor(int i=n-1;i;i--){\n\t\tvector<int> g(t[i]+1);\n\t\tfor(int j=0,mul=1;j<=t[i];j++)g[j]=C(t[i],j)*mul%mod,mul=mul*i%mod;\n\t\tf=mul(f,g);\n\t}\n\tfor(int i=0;i<f.size();i++)(ans+=((i&1)?(mod-1):1)*fac[n-i]%mod*f[i])%=mod;\n\tprintf(\"%lld\\n\",ans);\n}\n```\n\n",
      "data": {
        "title": "CF1613F 题解",
        "date": "2025-02-20 21:51:39",
        "tags": [
          "题解",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1613f-ti-jie"
    },
    {
      "content": "[P11754](https://www.luogu.com.cn/problem/P11754)\n\n人都傻了。\n\n### 思路\n\n重标号 $>0$ 的元素，所以操作可以认为直接从左到右。对于每个 $a_i=0$ 的点可以选择：赋值 $-1$，不操作，赋值为 $x$（但是编号不区分）。所以答案等价于 $3^{cnt0}$。\n\n离散化后线段树维护每个区间 $0$ 的个数。\n\n### code\n\n```cpp\nint n,q;\ninline int ksm(int a,int b=mod-2){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint lsh[maxn],len;\npii que[maxn];\n#define mid (l+r>>1)\n#define ls nd<<1\n#define rs nd<<1|1\nint tree[maxn<<2][2],rev[maxn<<2];\nvoid build(int nd,int l,int r){\n\ttree[nd][0]=lsh[r+1]-lsh[l];\n\tif(l==r)return ;\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n}\nvoid upd(int nd){swap(tree[nd][0],tree[nd][1]),rev[nd]^=1;}\nvoid down(int nd){upd(ls),upd(rs),rev[nd]=0;}\nvoid updata(int nd,int l,int r,int ql,int qr){\n\tif(l>=ql&&r<=qr)return upd(nd);\n\tif(rev[nd])down(nd);\n\tif(ql<=mid)updata(ls,l,mid,ql,qr);\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr);\n\ttree[nd][0]=tree[ls][0]+tree[rs][0];\n\ttree[nd][1]=tree[ls][1]+tree[rs][1];\n}\nvoid work(){\n\tn=read();q=read();\n\tfor(int i=1;i<=q;i++){\n\t\tint u=read(),v=read();\n\t\tque[i]={u,v};\n\t\tlsh[++len]=u,lsh[++len]=v+1;\n\t}\n\tlsh[++len]=1;lsh[++len]=n+1;\n\tsort(lsh+1,lsh+len+1);len=unique(lsh+1,lsh+len+1)-lsh-1;\n\tlen--;build(1,1,len);\n\tfor(int i=1;i<=q;i++){\n\t\tauto[l,r]=que[i];\n\t\tl=lower_bound(lsh+1,lsh+len+2,l)-lsh;\n\t\tr=lower_bound(lsh+1,lsh+len+2,r+1)-lsh-1;\n\t\tupdata(1,1,len,l,r);\n\t\tprintf(\"%lld\\n\",ksm(3,tree[1][0]));\n\t}\n}\n```\n\n",
      "data": {
        "title": "P11754 题解",
        "date": "2025-02-19 18:43:47",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11754-ti-jie"
    },
    {
      "content": "\n## 矩阵树定理\n\n### 对于无向图\n\n记度数矩阵 $D$，$D_{i,i}=deg_i$。邻接矩阵 $A$，$A_{i,j}=A_{j,i}$ 等于 $(i,j)$ 的数量。定义 基尔霍夫矩阵 $K=D-A$，则 $K$ 去掉 $k$ 行 $k$ 列 得到 $K'$，$k'$ 的行列式 $det(K')$ 为图的生成树数量。\n\n#### 模板：[P4111](https://www.luogu.com.cn/problem/P4111)。\n\n### 对于有向图\n\n分 叶向树和根向树，将度数分别换为入度和出度，删去 $rt$ 行 $rt$ 列的行列式为以 $rt$ 为根的方案数。\n\n#### 模板：[P4455](https://www.luogu.com.cn/problem/P4455)。\n\n### 生成树带权值\n\n如果求图的 生成树每条边的权值之积 的和，将 $D$ 和 $A$ 的值改为对应的权值和。\n\n#### [P3317](https://www.luogu.com.cn/problem/P3317)\n\n对于一颗生成树 $T$，权值为 $\\prod_{e\\in T}p_e\\prod_{e\\notin T}(1-p_e)$。把 $\\prod_e(1-p_e)$ 提出来，生成树每条边的权值为 $\\frac{p_e}{1-p_e}$。\n\n### BEST 定理\n\n对于欧拉图（有向图，存在欧拉回路，入度等于出度，除了孤立点强连通），从 $x$ 出发的欧拉回路等于以 $x$ 为根的根向树的方案数乘以 $deg_x\\times \\prod (deg_u-1)!$。\n\n#### [P7531](https://www.luogu.com.cn/problem/P7531)\n\n建源汇点，再从 $T$ 向 $S$ 连 $deg_S$ 条边，此时是欧拉图。随便选一个根求内向树，还要除去 $S,T$ 并不能随便定向。\n\n### 相关技巧\n\n#### [P6624](https://www.luogu.com.cn/problem/P6624)\n\n莫比乌斯反演除去 $gcd$ 的贡献。此时生成树的权值为每条边之和，但矩阵树做的是每条边之积。权值 $(wx+1)$ 之积模 $x^2$ 的一次项权值，维护一个结构体的行列式。\n\n#### [P4208](https://www.luogu.com.cn/problem/P4208)\n\n最小生成树每种边权选的边数量相等。求出一个 MST 之后，把同个边权的边拉出来，先连上其他边权的边，把每层内的生成树数量乘起来。\n\n#### [Q9278](https://qoj.ac/contest/1791/problem/9278)\n\n> 对初始为 $0$ 的 $n\\times n$ 矩阵操作 $m$ 次，对 $l\\le i\\le r,l\\le j\\le r$ 的 $a_{i,j}$ 加 $1$。求矩阵的行列式。\n>\n> $n\\le 5\\times 10^5,m\\le n+300$。\n\n二维差分后行列式值不变，等价于连边 $(l,r+1)$ 后图的基尔霍夫矩阵的行列式，即生成树方案数。注意到 $m-n\\le 300$，广义串并联方法，点数 $600$，求出缩完之后每条边在/不在生成树的方案数 $f_e$ 和 $g_e$。提出 $\\prod g_e$，边权为 $\\frac{f_e}{g_e}$ 再矩阵树定理求生成树权值。",
      "data": {
        "title": "矩阵树定理",
        "date": "2025-02-18 22:00:00",
        "tags": [
          "笔记",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ju-zhen-shu-ding-li"
    },
    {
      "content": "### [P10716](https://www.luogu.com.cn/problem/P10716)\n\n> $q$ 次询问 $(i,k)$，计数合法的非空字符串 $A$ 使得存在可空字符串 $B_1,\\dotsb,B_{k-1}$ 满足 $S[1,i]=AB_1A\\dotsb AB_{k-1}A$。\n\n合法的 $A$ 是前缀且在失配树上是 $i$ 的祖先，答案为最大的合法前缀 $S[1,u]$ 在失配树上的 $dep_u$。\n\n枚举 $u$，向后找不重叠的出现位置，即后缀和整个串 lcp $\\ge u$，即第一个 z 函数 $\\ge u$ 的位置。枚举完 $u$ 之后就删去 $z_p=u$ 的位置，并查集维护下一个位置。复杂度 $O(n\\log n)$。\n\n### [P11150](https://www.luogu.com.cn/problem/P11150)\n\n>给定长为 $n$ 的 $S$。$q$ 次询问 $T$，最小化 $S[1,i]+T+S[i+1,n]$，再最小化 $i$。\n\n先在 $s$ 末尾加入极大字符。要找到 $(i,j)$ 使得 $s[1,i]+t[1,j-1]=s[1,i+j-1]$ 且 $t_j<s_{i+j}$。最小化第一个不同的位置 $i+j$，再最小化 $t$ 从 $j$ 开始的后缀**加上 $s$ 从 $i+1$ 开始的后缀**，再最小化 $s$ 中的位置 $i$。\n\n先枚举 $j$，枚举 $s_{i+j}=c$ 且 $t_j<c$，可以用 SAM 做子串定位找到最小的 $i$ 使得 $s[i+1,i+j]=t[1,j-1]+c$。然后对于相等的 $i+j$，预处理 $t$ 的后缀排序即可比较 $t$ 的两个后缀的字典序大小。\n\n要比较$i1+j1=i2+j2$ 的 $(i1,j1)$ 和 $(i2,j2)$ ，有 $j2>j1$。如果 $j2$ 开始的后缀不是 $j1$ 开始的后缀的前缀，就直接比较 $rk_{j1}$ 和 $rk_{j2}$。否则比较 $t[j1+m-j2+1,m]$ 和  $s[i2+1,i1]$，因为之前匹配，所以 $s[i2+1,i1]$ 是 $t$ 的前缀。如果从 $j1+m-j2+1$ 开始的后缀不是从 $1$ 开始的后缀的前缀，那比较 $rk_{j1+m-j2+1}$ 和 $rk_1$；否则两个串完全相等。\n\n此时已经找到了最小的串，但是 $i$ 选取的位置可以往前。找到 $t$ 的最小循环节 $l$，二分将 $i$ 向前挪 $l\\times mid$，且 $s[i-l\\times mid+1,i-mid]=s[i-l\\times (mid-1)+1,i]$。\n\n### [Q9406](https://qoj.ac/contest/1803/problem/9406)\n\n> 给定 $n$ 个字符串，计数无序 $(x,y,z)$ 满足 $x>yz$ 或 $x>zy$ 且。 $y>xz$ 或 $y>zx$ 且 $z>xy$ 或 $z>yx$。 \n\n判掉含相等的若干情况。\n\n不妨设 $x>y,z$，且 $y+z\\ge z+y$。即 $y$ 是 $x$ 的前缀，$rk_{x-y}<rk_z<rk_x$。\n\n按 $uv\\le vu$ 给每个串排序，即分成三段分类讨论每段的 lcp，将所有串加上终止的极小字符求后缀数组。预处理出所有 $(x,y)$，按排序后的顺序枚举 $y$，区间查询。\n",
      "data": {
        "title": "字符串乱做",
        "date": "2025-02-12 22:26:27",
        "tags": [
          "做题记录",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zi-fu-chuan-luan-zuo"
    },
    {
      "content": "### 区间覆盖\n\n> $[1,n]$ 中 $m$ 个区间 $[l_i,r_i]$，代价 $w_i$，个数 $c_i$。要求使每个点被覆盖 $[a_j,b_j]$ 次。\n\n用边 $i\\to i+1$ 的流量描述 $i$ 被覆盖的次数。设总流量 $lim=\\max b_j$。连边 $(l_i,r_i+1,c_i,w_i)$ 和 $(j,j+1)$ 流量为 $[lim-b_j,lim-a_j]$ 费用为 $0$。每当 $i$ 被覆盖一次，$i\\to i+1$ 流量就少 $1$。\n\n上下界网络流，如果 $b$ 都相等，就没有下界变成普通费用流了。\n\n#### [Q7762](https://qoj.ac/contest/1416/problem/7762)\n\n> 给点 $w_1,\\dotsb w_n$。有一个长为 $m$ 的初始全零的序列 $a$。$q$ 次请求 $k_i$，如果不存在 $a_{pos}=k_i$，加 $w_{k_i}$ 代价使一个位置 $a_{pos}=k_i$。\n\n转换为最多减去多少代价。等价于：对于上一个 $k_p=k_i$ 的请求 $p$，如果 $p$ 到 $i$ 都一直不动 $p$ 处取到 $k_p$ 的位置，就能减少 $w_{k_i}$ 的代价。即线段 $[p+1,i-1]$，最后每个点被覆盖 $\\le m-1$。 \n\n#### [Q3304](https://qoj.ac/contest/776/problem/3304)\n\n> 选择价值最大的一些区间，对区间按包含关系连边，要求不成环。\n\n等价于：没有三个互相相交的区间。即每个点被覆盖 $\\le 2$ 次。\n\n#### [P6967](https://www.luogu.com.cn/problem/P6967)\n\n> $n$ 个小时，睡觉和吃饭价值分别为 $s_i$ 和 $e_i$。要求每 $k$ 个小时睡 $m_e$ 和吃 $m_s$ 小时。\n\n先当做全睡觉，再选一些位置变为吃饭。等价于：把 $i$ 小时吃饭看成区间 $[i,i+k)$，对于 $i\\ge k$ 的位置被覆盖 $[m_e,k-m_s]$ 次。",
      "data": {
        "title": "网络流模型",
        "date": "2025-02-12 21:53:07",
        "tags": [
          "笔记",
          "网络流"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wang-luo-liu-mo-xing"
    },
    {
      "content": "### [P10644](https://www.luogu.com.cn/problem/P10644)\n\n[Public NOIP Round #8 D. 矩阵](https://pjudge.ac/contest/1847/problem/21864)\n\n令 $f_i=\\sum_{j=1}^m a_{i,j}$，$g_j=\\sum_{i=1}^n a_{i,j}$。当 $c'_{i,j}=f_i-g_j$ 时认为 $c'_{i,j}$ 的符号是正确的。记 $p1$ 为一个不全相同的行，$p2$ 为一个不全相同的列。如果能构造出合法的 $\\sum f_i=\\sum g_j$，可以同 [arc135d](https://www.luogu.com.cn/problem/AT_arc135_d) 的方法，取出同符号的 $f_i,g_j$ 消掉绝对值较小的，再取出符号相反的 $f_i,f_j$ 或 $g_i,g_j$ 消掉绝对值较小的。\n\n如果存在 $p1,p2$。找到一个 $c_{p1,p2}\\neq c_{p1,p3}$，枚举 $c'_{p1,p2}$ 和 $c'_{p1,p3}$ 的符号，令 $f_{p1}=0,g_{p2}=c'_{p1,p2},g_{p3}=c'_{p1,p3}$，带进去解 $f_i,g_j$ ，有唯一解。然后调整，令 $f_{p1}$ 初始为 $\\frac{\\sum f_i-\\sum g_j}{n-m}$ 使 $\\sum f_i=\\sum g_j$。\n\n如果不存在 $p1$ 和 $p2$，即所有 $c_{i,j}$ 相等。如果 $n$ 为偶数，构造 $g_j=0$，前 $\\frac{n}{2}$ 个 $f_i$ 为 $c_{1,1}$，其他为 $-c_{1,1}$。否则 $n$ 为奇数，令 $g_j$ 全为 $x$，有 $n1$ 个 $f_i$ 为 $x+c_{1,1}$，$n2=n-n1$ 个为 $x-c_{1,1}$，有 $c_{1,1}=\\frac{(m-n)x}{n1-n2}$。$n1\\neq n2$，枚举 $n1$ 求 $x$。$m$ 为奇偶也同理。\n\n否则不妨设 $p1$ 有值。因为每列的 $c_{i,j}$ 都相等，构造第一行复制 $n$ 次。所以有 $n\\times f_1=\\sum f_i=\\sum g_j$，$g_j=f_1-c'_{i,j}$，$\\sum g_j=m\\times f_1-\\sum c'_{1,j}$。所以 $(n-m)\\times f_1=-\\sum c'_{1,j}$。设 $dp_{i,s}$ 表示前 $i$ 个 $c'_{i,j}$ 的和为 $s$ 是否可行。bitset $O(\\frac{n^3}{w})$ 加速。\n\n### [arc189e](https://www.luogu.com.cn/problem/AT_arc189_e)\n\n$n\\le 3$ 无解。$n=4$ 时 $(1,2),(3,4)$ 权值为 $1$，$(1,4),(2,3)$ 权值为 $2$，$(1,3),(2,4)$ 权值为 $3$。$n=5$ 时如样例。\n\n证明 $mx=2$ 不合法。归纳，对于 $n-1$ 的 $p_1,\\dotsb,p_{n-1}$ 使得 $mx=2$ 不合法，如果全同色，$n$ 可以加在最前或最后；否则找到分界点 $p_x$，$p_x$ 以前为 $1$，以后为 $2$，如果 $(p_x,n)$ 为 $1$，$p_1,\\dotsb,p_x,n,p_{x+1},\\dotsb,p_{n-1}$ 不合法，否则 $p_1,\\dotsb,p_{x-1},n,p_x,\\dotsb,p_{n-1}$ 不合法。\n\n对于 $n>5$ 时 $mx=3$ 合法。将 $n$ 分为 $4$ 个集合 $X1,X2,X3,X4$，对应 $n=4$ 时的 $1,2,3,4$。集合内权值为 $3$，集合间权值为 $n=4$ 的权值。可能不合法的方案会要求连续在 $X1$ 和 $X2$ 间切换，再连续在 $X1$ 和 $X4$ 间切换，即 $|X1|\\ge |X2|+|X4|$。其他一些可能不合法的情况也要求其中一个集合至少为另外两个集合之和。令 $|X1|\\ge |X2|\\ge |X3|\\ge |X4|\\ge |X1|-1$。但当 $n=5$ 时会寄，特判即可。\n\n### [CF1097E](https://www.luogu.com.cn/problem/CF1097E)\n\n记 $c_n$ 为最大的 $k$ 使得 $\\frac{k(k+1)}{2}\\le n$。可以构造 $((1),(3,2),(6,5,4),\\dotsb)$ 使得 $f_n\\ge c_n$。\n\n在 $c_n$ 内划分任意一个排列。设最长上升子序列长为 $len$。如果 $len>k$，取出，$\\frac{(k-1)k}{2}\\le n-len$。否则由 Dilworth，存在 $len$ 个下降子序列可以拼出原序列，贪心构造。\n\n### [P9731](https://www.luogu.com.cn/problem/P9731)\n\n对于 $m=2$，一定有解。连边 $(u,v)$，把奇数度的点连向一个虚点，跑欧拉回路。可以保证原来奇数度的点入度出度差为 $1$。\n\n对于更大的 $m$，当作 $n\\times \\frac{m}{2}$ 对 $2$ 个的处理，使得左右两边差值 $\\le 1$。分治左右两边。\n\n### [P11066](https://www.luogu.com.cn/problem/P11066)\n\n分为要向左的点和要向右的点。从后往前做，要向左的点先向右一步，要向右的点直接去要去的位置。再从前往后，要向左的点去要去的位置。问题是，对于只要向右走一步的点，会在这时挡到路。\n\n先做一步调整。调整会把空位从最右移到最左，所以上面部分反过来。每次从后往前考虑 $i$ 和 $i+1$，如果 $m$ 为奇数就不考虑最后一个点。如果 $i$ 和 $i+1$ 在右移一格后需要调整，就交换 ```i+2,i+2,0,i+1```，否则直接 ```i+2,i+1```，把空位向左移。\n\n理论上 $5n$，常数较小。",
      "data": {
        "title": "智慧构造",
        "date": "2025-02-09 22:38:11",
        "tags": [
          "做题记录",
          "构造"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zhi-hui-gou-zao"
    },
    {
      "content": "[https://oi-wiki.org/graph/flow/min-cost/#primal-dual-%E5%8E%9F%E5%A7%8B%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95](https://oi-wiki.org/graph/flow/min-cost/#primal-dual-%E5%8E%9F%E5%A7%8B%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95)\n\n对于带负权的费用流，正常的 spfa 求增广路的费用流复杂度 $O(nmf)$。使用 Primal-Dual 后 $O(nm+m\\log nf)$。\n\n仿照 [Johnson 全源最短路](https://oi-wiki.org/graph/shortest-path/#johnson-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95)。设置势能使费用为正，然后每次增广用 dij 代替 spfa。初始势能 $h_u$ 为  $s$ 到 $u$ 的最短路，$O(nm)$ 求出。设置 $(u,v,w)$ 的边权为 $w+h_u-h_v$。设置势能后新网络上的最短路径和原网络上的最短路径对应且边权为正。\n\n增广后图的形态会发生变化，设增广后 $s$ 到 $u$ 的距离（新边权）为 $dis_u$，更新势能为 $h_i+dis_i$。对于原有的 $(u,v)$，$dis_u+(w(u,v)+h_u-h_v)\\ge dis_v$，$(u,v)$ 的新边权 $w(u,v)+h_u+dis_u-h_v-dis_v\\ge 0$。对于增广路上的 $(u,v)$，$dis_u+(w(u,v)+h_u-h_v)=dis_v$，$(v,u)$ 的新边权等于 $0$。更新势能后新图上所有边的边权均非负。\n\n```cpp\nint n,m;\nint s,t,flow,ans;\nint head[maxn],tot=1;\nstruct nd{\n\tint nxt,to,w,c;\n}e[maxn<<1];\nvoid add(int u,int v,int w,int c){\n\te[++tot]={head[u],v,w,c};head[u]=tot;\n\te[++tot]={head[v],u,0,-c};head[v]=tot;\n}\nint h[maxn];bool vis[maxn];\nvoid spfa(){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++)h[i]=inf,vis[i]=0;\n\th[s]=0,vis[s]=1,q.push(s);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();vis[u]=0;\n\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].to;\n\t\t\tif(e[i].w&&h[v]>h[u]+e[i].c){\n\t\t\t\th[v]=h[u]+e[i].c;\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint dis[maxn],pre[maxn],id[maxn];\nbool dij(){\n\tpriority_queue<pii> q;\n\tfor(int i=1;i<=n;i++)dis[i]=inf,vis[i]=0;\n\tdis[s]=0;q.push({0,s});\n\twhile(!q.empty()){\n\t\tint u=q.top().se;q.pop();\n\t\tif(vis[u])continue;vis[u]=1;\n\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].to,val=e[i].c+h[u]-h[v];\n\t\t\tif(e[i].w&&dis[v]>dis[u]+val){\n\t\t\t\tdis[v]=dis[u]+val,pre[v]=u,id[v]=i;\n\t\t\t\tq.push({-dis[v],v});\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=inf;\n}\nvoid work(){\n\tn=read();m=read();s=read();t=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read(),w=read(),c=read();\n\t\tadd(u,v,w,c);\n\t}\n\tspfa();\n\twhile(dij()){\n\t\tfor(int i=1;i<=n;i++)h[i]+=dis[i];\n\t\tint mn=inf;\n\t\tfor(int u=t;u!=s;u=pre[u])mn=min(mn,e[id[u]].w);\n\t\tflow+=mn;\n\t\tfor(int u=t;u!=s;u=pre[u]){\n\t\t\te[id[u]].w-=mn,e[id[u]^1].w+=mn;\n            ans+=e[id[u]].c*mn;\n\t\t}\n\t}\n\tprintf(\"%lld %lld\\n\",flow,ans);\n}\n```\n\n例：[Q3304](https://qoj.ac/contest/776/problem/3304)。初始网络为 DAG，流量为 $2$。可以 $O(n)$ 快速求出初始势能，复杂度 $O(n\\log n)$。",
      "data": {
        "title": "Primal-Dual 原始对偶算法",
        "date": "2025-02-07 20:15:31",
        "tags": [
          "笔记",
          "网络流"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "primal-dual-yuan-shi-dui-ou-suan-fa"
    },
    {
      "content": "[https://qoj.ac/contest/776](https://qoj.ac/contest/776)。\r\n\r\n[https://codeforces.com/gym/102759](https://codeforces.com/gym/102759)\r\n\r\n### [A.Advertisement Matching](https://qoj.ac/contest/776/problem/3299)\r\n\r\n> $n$ 种广告每种 $a_i$ 个，$m$ 个用户每人要 $b_i$ 条不相同的广告。每次 $a_i$ 或 $b_j$ $\\pm 1$，问能否达成要求。\r\n\r\n按 $a_i$ 降序。由霍尔定理等价于 $\\forall x\\in[1,n]$，$\\sum_{i=1}^x a_i\\le \\sum_{i=1}^m \\min(x,b_i)$。\r\n\r\n线段树维护 $x$ ，后缀加减，树状数组维护一个值在 $a$ 中的排名。 \r\n\r\n```cpp\r\nint n,m,q;\r\nint a[maxn],b[maxn];\r\nint sum[maxn],num[maxn],val[maxn];\r\nint tree[maxn<<1];\r\n#define lb(x) (x&(-x))\r\nvoid upd(int x,int w){\r\n\tx++;\r\n\twhile(x<maxn*2)tree[x]+=w,x+=lb(x);\r\n}\r\nint que(int x){\r\n\tint res=0;x++;\r\n\twhile(x)res+=tree[x],x-=lb(x);\r\n\treturn res;\r\n}\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nint mn[maxn<<2],tag[maxn<<2];\r\nvoid build(int nd,int l,int r){\r\n\tif(l==r){mn[nd]=val[l]-sum[l];return ;}\r\n\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n\tmn[nd]=min(mn[ls],mn[rs]);\r\n}\r\nvoid modif(int nd,int w){\r\n\tmn[nd]+=w,tag[nd]+=w;\r\n}\r\nvoid down(int nd){\r\n\tmodif(ls,tag[nd]),modif(rs,tag[nd]),tag[nd]=0;\r\n}\r\nvoid updata(int nd,int l,int r,int ql,int qr,int w){\r\n\tif(ql>qr)return ;\r\n\tif(l>=ql&&r<=qr)return modif(nd,w);\r\n\tif(tag[nd])down(nd);\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n\tmn[nd]=min(mn[ls],mn[rs]);\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<=m;i++)b[i]=read();\r\n\tfor(int i=1;i<=m;i++)num[b[i]]++,sum[b[i]]+=b[i];\r\n\tfor(int i=1;i<=n;i++)num[i]+=num[i-1],sum[i]+=sum[i-1];\r\n\tfor(int i=1;i<=n;i++)val[i]=sum[i]+(m-num[i])*i;\r\n\tfor(int i=1;i<=n;i++)sum[i]=a[i];\r\n\tsort(sum+1,sum+n+1,[&](int u,int v){return u>v;});\r\n\tfor(int i=1;i<=n;i++)sum[i]+=sum[i-1];\r\n\tbuild(1,1,n);\r\n\tfor(int i=1;i<=n;i++)upd(a[i],1);\r\n\tq=read();\r\n\twhile(q--){\r\n\t\tint op=read(),p=read();\r\n\t\tif(op==1){\r\n\t\t\tint pos=n-que(a[p])+1;\r\n\t\t\tupdata(1,1,n,pos,n,-1);\r\n\t\t\tupd(a[p],-1),a[p]++,upd(a[p],1);\r\n\t\t}\r\n\t\tif(op==2){\r\n\t\t\tint pos=n-que(a[p]-1);\r\n\t\t\tupdata(1,1,n,pos,n,1);\r\n\t\t\tupd(a[p],-1),a[p]--,upd(a[p],1);\r\n\t\t}\r\n\t\tif(op==3){\r\n\t\t\tupdata(1,1,n,b[p]+1,n,1);\r\n\t\t\tb[p]++;\r\n\t\t}\r\n\t\tif(op==4){\r\n\t\t\tupdata(1,1,n,b[p],n,-1);\r\n\t\t\tb[p]--;\r\n\t\t}\r\n\t\tputs(mn[1]>=0?\"1\":\"0\");\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n### [B.B. Cactus Competition](https://qoj.ac/contest/776/problem/3300)\r\n\r\n> $n\\times m$ 的网格，权值为 $a_i+b_j$，权值 $\\ge 0$ 可以通行，每次向右/下走。有多少对 $(s,t)$ 使得 $(s,1)$ 能到达 $(t,m)$。\r\n\r\n称 $a_i+\\min b_j\\ge 0$ 的行为关键行。等价于 $s,t$ 间有关键行，$s$ 去到的最大关键行 $nxt_s$ 小于最小去到 $t$ 的关键行 $pre_t$。\r\n\r\n算 $pre_i$。如果 $i$ 是关键行，二分 $pre_i$ 看 $\\min_{j=i}^{pre_i} a_i+\\max b_j\\ge 0$。否则如果存在最小的 $p$ 使得 $a_p\\ge a_i$，如果 $(i,1)$ 能去到第 $p$ 行，则 $pre_i=pre_p$。二分 $(i,1)$ 最大去到 $(i,pos)$，取 $[1,pos]$ 中最大的 $b_i$ 往下走。\r\n\r\n然后二维数点即可。\r\n\r\n```cpp\r\nint n,m,ans;\r\nint a[maxn],b[maxn];\r\nint pmn[maxn],pmx[maxn],smn[maxn],smx[maxn];\r\nint mn[18][maxn],mx[18][maxn];\r\nint quemn(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn min(mn[k][l],mn[k][r-(1<<k)+1]);\r\n}\r\nint quemx(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn max(mx[k][l],mx[k][r-(1<<k)+1]);\r\n}\r\nint nxt[maxn],pre[maxn];\r\n#define lb(x) (x&(-x))\r\nint tree[maxn];\r\nvoid upd(int x,int w){\r\n\twhile(x<=n+1)tree[x]+=w,x+=lb(x);\r\n}\r\nint que(int x){\r\n\tint res=0;\r\n\twhile(x)res+=tree[x],x-=lb(x);\r\n\treturn res;\r\n}\r\nvector<int> id;\r\nint rnk[maxn];\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<=m;i++)b[i]=read();\r\n\tfor(int i=1;i<=n;i++)mn[0][i]=mx[0][i]=a[i];\r\n\tfor(int j=1;j<18;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++){\r\n\t\t\tmn[j][i]=min(mn[j-1][i],mn[j-1][i+(1<<j-1)]);\r\n\t\t\tmx[j][i]=max(mx[j-1][i],mx[j-1][i+(1<<j-1)]);\r\n\t\t}\r\n\t}\r\n\tpmn[0]=inf;for(int i=1;i<=m;i++)pmn[i]=min(pmn[i-1],b[i]);\r\n\tpmx[0]=-inf;for(int i=1;i<=m;i++)pmx[i]=max(pmx[i-1],b[i]);\r\n\tsmn[m+1]=inf;for(int i=m;i;i--)smn[i]=min(smn[i+1],b[i]);\r\n\tsmx[m+1]=-inf;for(int i=m;i;i--)smx[i]=max(smx[i+1],b[i]);\r\n\tpre[0]=n+1;\r\n\tfor(int i=1;i<=n;i++)if(a[i]+pmn[m]>=0)id.pb(i),rnk[i]=id.size()-1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tpre[i]=n+1;\r\n\t\tif(a[i]+pmn[m]>=0){\r\n\t\t\tint l=0,r=rnk[i]-1,res=rnk[i];\r\n\t\t\twhile(l<=r){\r\n\t\t\t\tint mid=l+r>>1;\r\n\t\t\t\tif(quemn(id[mid],i)+pmx[m]>=0)r=mid-1,res=mid;\r\n\t\t\t\telse l=mid+1;\r\n\t\t\t}\r\n\t\t\tpre[i]=id[res];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint l=1,r=i-1,res=0,pos=m+1;\r\n\t\twhile(l<=r){\r\n\t\t\tint mid=l+r>>1;\r\n\t\t\tif(quemx(mid,i-1)>=a[i])l=mid+1,res=mid;\r\n\t\t\telse r=mid-1;\r\n\t\t}\r\n\t\tl=1,r=m;\r\n\t\twhile(l<=r){\r\n\t\t\tint mid=l+r>>1;\r\n\t\t\tif(a[i]+smn[mid]>=0)r=mid-1,pos=mid;\r\n\t\t\telse l=mid+1;\r\n\t\t}\r\n\t\tif(quemn(res,i)+smx[pos]>=0)pre[i]=pre[res];\r\n\t}\r\n\tfor(int i=n;i;i--){\r\n\t\tnxt[i]=0;\r\n\t\tif(a[i]+pmn[m]>=0){\r\n\t\t\tint l=rnk[i]+1,r=id.size()-1,res=rnk[i];\r\n\t\t\twhile(l<=r){\r\n\t\t\t\tint mid=l+r>>1;\r\n\t\t\t\tif(quemn(i,id[mid])+pmx[m]>=0)l=mid+1,res=mid;\r\n\t\t\t\telse r=mid-1;\r\n\t\t\t}\r\n\t\t\tnxt[i]=id[res];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tint l=i+1,r=n,res=n+1,pos=0;\r\n\t\twhile(l<=r){\r\n\t\t\tint mid=(l+r>>1);\r\n\t\t\tif(quemx(i+1,mid)>=a[i])r=mid-1,res=mid;\r\n\t\t\telse l=mid+1;\r\n\t\t}\r\n\t\tl=1,r=m;\r\n\t\twhile(l<=r){\r\n\t\t\tint mid=l+r>>1;\r\n\t\t\tif(a[i]+pmn[mid]>=0)l=mid+1,pos=mid;\r\n\t\t\telse r=mid-1;\r\n\t\t}\r\n\t\tif(quemn(i,res)+pmx[pos]>=0)nxt[i]=nxt[res];\r\n\t}\r\n\tfor(int i=n,lst=n;i;i--){\r\n\t\tif(a[i]+pmn[m]>=0){\r\n\t\t\twhile(lst>=i)upd(pre[lst],1),lst--;\r\n\t\t}\r\n\t\tans+=que(nxt[i]);\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [C.Economic One-way Roads](https://qoj.ac/contest/776/problem/3301)\r\n\r\n> 给无向图定向，求最小边权的强连通图。\r\n\r\n[耳分解](https://yhddd123.github.io/post/tu-lun-lian-tong-xing-wen-ti/#%E8%80%B3%E5%88%86%E8%A7%A3)\r\n\r\n$f_s$ 表示 $s$ 内定向为强连通图的最小代价，$g_{s,i,j}$ 表示耳的代价加上 $i$ 到 $s$ 除了 $j$ 的所有点乱定向的最小代价。额外记 $sum_{u,s}$ 表示点 $u$ 到 $s$ 的乱定向的最小代价。\r\n\r\n转移同状压拆分耳分解，复杂度 $O(2^nn^3)$。\r\n\r\n```cpp\r\nint n,e[18][18];\r\nint f[1<<18],g[1<<18][18][18];\r\nint sum[18][1<<18],val[18][18];\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=0;i<n;i++){\r\n\t\tfor(int j=0;j<n;j++){\r\n\t\t\te[i][j]=read();\r\n\t\t\tif(e[i][j]==-1)e[i][j]=inf;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(e[i][j]<inf)val[i][j]=min(e[i][j],e[j][i]);\r\n\tfor(int i=0;i<n;i++){\r\n\t\tfor(int s=1;s<(1<<n);s++){\r\n\t\t\tint lg=__lg(s&(-s));\r\n\t\t\tsum[i][s]=sum[i][s^(s&(-s))]+val[i][lg];\r\n\t\t}\r\n\t}\r\n\tfor(int s=0;s<(1<<n);s++){\r\n\t\tf[s]=inf;\r\n\t\tfor(int i=0;i<n;i++){\r\n\t\t\tfor(int j=0;j<n;j++)g[s][i][j]=inf;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<n;i++)f[1<<i]=0;\r\n\tfor(int s=1;s<(1<<n);s++){\r\n\t\tfor(int i=0;i<n;i++)if(s&(1<<i)){\r\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\r\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\r\n\t\t\t\t\tif(i==j){\r\n\t\t\t\t\t\tfor(int l=0;l<n;l++)if(!(s&(1<<l))){\r\n\t\t\t\t\t\t\tg[s|(1<<k)][l][j]=min(g[s|(1<<k)][l][j],f[s]+e[i][k]+e[k][l]+sum[k][s^(1<<i)]+sum[l][s^(1<<j)]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse g[s][k][j]=min(g[s][k][j],f[s]+e[i][k]+sum[k][s^(1<<i)^(1<<j)]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=0;i<n;i++)if(!(s&(1<<i))){\r\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\r\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\r\n\t\t\t\t\tg[s|(1<<i)][k][j]=min(g[s|(1<<i)][k][j],g[s][i][j]+e[i][k]+val[i][j]+sum[k][s^(1<<j)]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=0;i<n;i++)if(!(s&(1<<i))){\r\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\r\n\t\t\t\tf[s|(1<<i)]=min(f[s|(1<<i)],g[s][i][j]+e[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif(f[(1<<n)-1]==inf)f[(1<<n)-1]=-1;\r\n\tprintf(\"%lld\\n\",f[(1<<n)-1]);\r\n}\r\n```\r\n\r\n### [D. Just Meeting](https://qoj.ac/contest/776/problem/3302)\r\n\r\n> 给 $n$ 个点的完全图，$m$ 条边边权已知，给剩下的边赋值并最小化使得不存在 $w(i,j)<\\min(w(i,k),w(j,k))$。\r\n\r\n有 $w(u,v)\\ge\\min_{(x,y)\\in E(u,v)} w(x,y)$。建最大生成树，有 $w(u,v)\\le\\min_{(x,y)\\in E(u,v)} w(x,y)$。\r\n\r\n查询树链上的最小值判断非树边。并查集是累计 $siz_u\\times siz_v\\times w$。\r\n\r\n```cpp\r\nint n,m,ans;\r\nstruct edge{\r\n\tint u,v,w;\r\n}g[maxn];\r\nint f[maxn],siz[maxn];\r\nint fd(int x){\r\n\tif(f[x]==x)return x;\r\n\treturn f[x]=fd(f[x]);\r\n}\r\nbool vis[maxn];\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to,w;\r\n}e[maxn<<1];\r\nvoid add(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}\r\nint to[maxn][19],w[maxn][19],dep[maxn];\r\nint calc(int u,int v){\r\n\tint res=inf;\r\n\tif(dep[u]<dep[v])swap(u,v);\r\n\tfor(int i=18;~i;i--)if(dep[to[u][i]]>=dep[v])res=min(res,w[u][i]),u=to[u][i];\r\n\tif(u==v)return res;\r\n\tfor(int i=18;~i;i--)if(to[u][i]!=to[v][i])res=min({res,w[u][i],w[v][i]}),u=to[u][i],v=to[v][i];\r\n\treturn min({res,w[u][0],w[v][0]});\r\n}\r\nvoid dfs(int u){\r\n\tdep[u]=dep[to[u][0]]+1;\r\n\tfor(int i=1;i<=18;i++)to[u][i]=to[to[u][i-1]][i-1],w[u][i]=min(w[u][i-1],w[to[u][i-1]][i-1]);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==to[u][0])continue;\r\n\t\tto[v][0]=u,w[v][0]=e[i].w;dfs(v);\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++)g[i]={read(),read(),read()};\r\n\tfor(int i=1;i<=n;i++)f[i]=i,siz[i]=1;\r\n\tsort(g+1,g+m+1,[&](edge u,edge v){return u.w>v.w;});\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=g[i].u,v=g[i].v,w=g[i].w;\r\n\t\tif(fd(u)!=fd(v)){\r\n\t\t\tadd(u,v,w),add(v,u,w);\r\n\t\t\tu=fd(u),v=fd(v);\r\n\t\t\tans+=siz[u]*siz[v]*w;\r\n\t\t\tf[v]=u,siz[u]+=siz[v];\r\n\t\t\tvis[i]=1;\r\n\t\t}\r\n\t}\r\n\tint sum=n*(n-1)/2;\r\n\tfor(int i=1;i<=n;i++)if(f[i]==i)sum-=siz[i]*(siz[i]-1)/2;\r\n\tans+=sum;\r\n\tfor(int i=1;i<=n;i++)if(f[i]==i)dfs(i);\r\n\tfor(int i=1;i<=m;i++)if(!vis[i]){\r\n\t\tif(calc(g[i].u,g[i].v)>g[i].w){puts(\"-1\");return ;}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [E. Chemistry](https://qoj.ac/contest/776/problem/3303)\r\n\r\n> 图。求多少对 $[l,r]$ 使得 $[l,r]$ 中的点和边形成一条链。\r\n\r\n如果保证是森林，那么等价于 $\\max deg_u=2$ 和 $V-E=1$。维护 $f_i$ 表示 $[i,f_i)$ 满足不存在 $deg_u>2$。维护 $g_i$ 表示 $[i,g_i)$ 满足不存在环。线段树分治或 LCT 维护。\r\n\r\n然后对于 $[i,\\min(f_i,g_i)-1]$ 内满足森林的条件，有 $V-E\\ge 1$，扫描线求 $(mn,cnt)$。\r\n\r\n```cpp\r\nint n,m;ll ans;\r\nvector<int> e[maxn];\r\nint pos[maxn];\r\nint d[maxn],f[maxn],g[maxn];\r\nint fa[maxn],siz[maxn];\r\nint fd(int x){\r\n\tif(fa[x]==x)return x;\r\n\treturn fd(fa[x]);\r\n}\r\nint st[maxn],tp;\r\nbool merge(int u,int v){\r\n\tu=fd(u),v=fd(v);\r\n\tif(u==v)return 0;\r\n\tif(siz[u]<siz[v])swap(u,v);\r\n\tfa[v]=u,siz[u]+=siz[v];st[++tp]=v;\r\n\treturn 1;\r\n}\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nvector<pii> tree[maxn<<2];\r\nvoid updata(int nd,int l,int r,int ql,int qr,pii w){\r\n\tif(ql>qr)return ;\r\n\tif(l>=ql&&r<=qr){tree[nd].pb(w);return ;}\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n}\r\nvoid sovle(int nd,int l,int r,bool fl=1){\r\n\tint lst=tp;\r\n\tfor(auto[u,v]:tree[nd])fl&=merge(u,v);\r\n\tif(l==r){\r\n\t\tg[l]=g[l-1];\r\n\t\twhile(fl&&g[l]<=n){\r\n\t\t\tint u=++g[l];\r\n\t\t\tif(u>n)break;\r\n\t\t\tint p=pos[u]-1,v;\r\n\t\t\twhile(p>=0&&(v=e[u][p])>=l){\r\n\t\t\t\tfl&=merge(u,v);\r\n\t\t\t\tupdata(1,1,n,l+1,min(u,v),{u,v});\r\n\t\t\t\tp--;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse sovle(ls,l,mid,fl),sovle(rs,mid+1,r,fl);\r\n\twhile(tp>lst){\r\n\t\tint v=st[tp],u=fa[v];\r\n\t\tsiz[u]-=siz[v],fa[v]=v;\r\n\t\ttp--;\r\n\t}\r\n}\r\npii mn[maxn<<2];\r\nint tag[maxn<<2];\r\nvoid build(int nd,int l,int r){\r\n\tmn[nd]={0,r-l+1};\r\n\tif(l==r)return ;\r\n\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n}\r\nvoid upd(int nd,int w){mn[nd].fi+=w,tag[nd]+=w;}\r\nvoid down(int nd){\r\n\tupd(ls,tag[nd]),upd(rs,tag[nd]),tag[nd]=0;\r\n}\r\npii merge(pii u,pii v){\r\n\treturn {min(u.fi,v.fi),(u.fi==min(u.fi,v.fi))*u.se+(v.fi==min(u.fi,v.fi))*v.se};\r\n}\r\nvoid updata(int nd,int l,int r,int ql,int qr,int w){\r\n\tif(l>=ql&&r<=qr)return upd(nd,w);\r\n\tif(tag[nd])down(nd);\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n\tmn[nd]=merge(mn[ls],mn[rs]);\r\n}\r\npii query(int nd,int l,int r,int ql,int qr){\r\n\tif(l>=ql&&r<=qr)return mn[nd];\r\n\tif(tag[nd])down(nd);\r\n\tif(qr<=mid)return query(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n\treturn merge(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\te[u].pb(v),e[v].pb(u);\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tsort(e[i].begin(),e[i].end());\r\n\t\tpos[i]=lower_bound(e[i].begin(),e[i].end(),i)-e[i].begin();\r\n\t}\r\n\tf[0]=g[0]=1;\r\n\tfor(int i=1,cnt=0;i<=n;i++){\r\n\t\tf[i]=f[i-1];\r\n\t\twhile(!cnt&&f[i]<=n){\r\n\t\t\tint u=++f[i];\r\n\t\t\tif(u>n)break;\r\n\t\t\tint p=pos[u]-1,v;\r\n\t\t\twhile(p>=0&&(v=e[u][p])>=i){\r\n\t\t\t\td[v]++;if(d[v]==3)++cnt;\r\n\t\t\t\td[u]++;if(d[u]==3)++cnt;\r\n\t\t\t\tp--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint p=pos[i],v;\r\n\t\twhile(p<e[i].size()&&(v=e[i][p])<=f[i]){\r\n\t\t\td[v]--;if(d[v]==2)--cnt;\r\n\t\t\td[i]--;if(d[i]==2)--cnt;\r\n\t\t\tp++;\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++)fa[i]=i,siz[i]=1;\r\n\tsovle(1,1,n);\r\n\tbuild(1,1,n);\r\n\tfor(int i=n;i;i--){\r\n\t\tupdata(1,1,n,i,n,1);\r\n\t\tint p=pos[i],v;\r\n\t\twhile(p<e[i].size()&&(v=e[i][p]))updata(1,1,n,v,n,-1),p++;\r\n\t\tpii res=query(1,1,n,i,min(f[i],g[i])-1);\r\n\t\tif(res.fi==1)ans+=res.se;\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [F. Interval Graph](https://qoj.ac/contest/776/problem/3304)\r\n\r\n等价于每个点只被 $\\le 2$ 条线段跨过。费用流，连 $(i-1,i,2,0)$ 和 $(l_i,r_i+1,1,-w_i)$，流量为 $2$。\r\n\r\n带负权值的费用流，Primal-Dual 原始对偶。最开始的网络是 DAG，可以 dp 算初始的势能；转为边权为正的图，后面 dij 算最短路跑费用流。复杂度 $O(n\\log n)$。\r\n\r\n```cpp\r\nint n;\r\nvector<pii> upd[maxn];\r\nint s,t,flow,ans;\r\nint head[maxn],tot=1;\r\nstruct nd{\r\n\tint nxt,to,w,c;\r\n}e[maxn<<2];\r\nvoid add(int u,int v,int w,int c){\r\n\te[++tot]={head[u],v,w,c};head[u]=tot;\r\n\te[++tot]={head[v],u,0,-c};head[v]=tot;\r\n}\r\nint h[maxn];\r\nint dis[maxn],pre[maxn],id[maxn];\r\nbool vis[maxn];\r\nbool dij(){\r\n\tpriority_queue<pii> q;\r\n\tfor(int i=0;i<=t;i++)dis[i]=inf,vis[i]=0;\r\n\tdis[s]=0;q.push({0,s});\r\n\twhile(!q.empty()){\r\n\t\tint u=q.top().se;q.pop();\r\n\t\tif(vis[u])continue;vis[u]=1;\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to,val=e[i].c+h[u]-h[v];\r\n\t\t\tassert(!e[i].w||val>=0);\r\n\t\t\tif(e[i].w&&dis[v]>dis[u]+val){\r\n\t\t\t\tdis[v]=dis[u]+val,pre[v]=u,id[v]=i;\r\n\t\t\t\tq.push({-dis[v],v});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dis[t]!=inf;\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint l=read(),r=read(),w=read();\r\n\t\tadd(l,r+1,1,-w);\r\n\t\tt=max(t,r+1);\r\n\t}\r\n\tfor(int i=1;i<=t;i++)add(i-1,i,2,0);\r\n\tfor(int i=0;i<=t;i++)h[i]=inf;h[s]=0;\r\n\tfor(int u=0;u<=t;u++){\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(e[i].w)h[v]=min(h[v],h[u]+e[i].c);\r\n\t\t}\r\n\t}\r\n\twhile(dij()){\r\n\t\tfor(int i=0;i<=t;i++)h[i]+=dis[i];\r\n\t\tint mn=1;\r\n\t\tfor(int u=t;u!=s;u=pre[u])mn=min(mn,e[id[u]].w);\r\n\t\tflow+=mn;\r\n\t\tfor(int u=t;u!=s;u=pre[u]){\r\n\t\t\te[id[u]].w-=mn,e[id[u]^1].w+=mn;\r\n\t\t\tans+=e[id[u]].c*mn;\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",-ans);\r\n}\r\n```\r\n\r\n\r\n\r\n### [G. LCS 8](https://qoj.ac/contest/776/problem/3305)\r\n\r\n> 给 $s$，构造 $t$ 使得最长公共子序列 $\\ge n-k$。$n\\le 50000,k\\le 3$。\r\n\r\ndp 套 dp。内层维护 $f_{i-k,i},\\dotsb,f_{i+k,i}$。外层记录第一个数 $f_{i-k}=i-k-j$，$j\\le 3$，状压 $f_{i+c,i}-f_{i+c-1,i}$。枚举 $t_i=c$，只有 $O(k)$ 个本质不同的字符。复杂度 $O(n2^kk^2)$。\r\n\r\n```cpp\r\nint n,k,ans;\r\nchar s[maxn];\r\nint dp[2][1<<6][4],cur;\r\nint f[9],g[9];\r\nvoid work(){\r\n\tscanf(\"%s\",s+1);n=strlen(s+1);k=read();\r\n\tdp[0][0][0]=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int s=0;s<(1<<k+k);s++){\r\n\t\t\tfor(int j=0;j<=k;j++)dp[i&1][s][j]=0;\r\n\t\t}\r\n\t\tint ss=0,mn=26,cnt=0;\r\n\t\tfor(int p=max(i-k,1);p<=min(i+k,n);p++)ss|=1<<s[p]-'A';\r\n\t\tfor(int c=0;c<26;c++)if(!(ss&(1<<c)))++cnt,mn=c;\r\n\t\tss|=1<<mn;\r\n\t\tfor(int s=0;s<(1<<k+k);s++){\r\n\t\t\tfor(int j=0;j<=k;j++)if(dp[cur][s][j]){\r\n\t\t\t\tg[0]=max(i-1-k,0)-j;\r\n\t\t\t\tfor(int p=1;p<=2*k;p++)g[p]=g[p-1]+((s>>p-1)&1);\r\n\t\t\t\tfor(int c=0;c<26;c++)if(ss&(1<<c)){\r\n\t\t\t\t\tbool fl=1;int t=0;\r\n\t\t\t\t\tfor(int p=0;p<=2*k;p++){\r\n\t\t\t\t\t\tf[p]=max({p?f[p-1]:0,g[p]+(1<=i-k+p&&i-k+p<=n&&c==::s[i-k+p]-'A'),g[p+1]});\r\n\t\t\t\t\t\tif(f[p]+max(n-i,n-(i-k+p))<n-k){fl=0;break;}\r\n\t\t\t\t\t\tif(p&&f[p-1]!=f[p])t|=(1<<p-1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(fl){\r\n\t\t\t\t\t\tint val=1ll*(c==mn?cnt:1)*dp[cur][s][j]%mod;\r\n\t\t\t\t\t\t(dp[i&1][t][max(i-k,0)-f[0]]+=val)%=mod;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcur^=1;\r\n\t}\r\n\tfor(int s=0;s<(1<<k+k);s++){\r\n\t\tfor(int j=0;j<=k;j++){\r\n\t\t\tint v=max(n-k,0)-j;\r\n\t\t\tfor(int ii=0;ii<k;ii++)if(s&(1<<ii))++v;\r\n\t\t\tif(v>=n-k)(ans+=dp[n&1][s][j])%=mod;\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n",
      "data": {
        "title": "XXI Open Cup, Grand Prix of Korea",
        "date": "2025-02-06 22:12:17",
        "tags": [
          "acm"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "xxi-open-cup-grand-prix-of-korea"
    },
    {
      "content": "[P11150](https://www.luogu.com.cn/problem/P11150)\r\n\r\n### upd 25.2.7\r\n\r\n被 [1](https://www.luogu.com.cn/discuss/1054533) [2](https://www.luogu.com.cn/discuss/1056262) hack 了。内容有修改。暂时通过了所有 hack。后缀排序应该还是对的。\r\n\r\n### 思路\r\n\r\n先在 $s$ 末尾加入极大字符。要找到 $(i,j)$ 使得 $s[1,i]+t[1,j-1]=s[1,i+j-1]$ 且 $t_j<s_{i+j}$。最小化第一个不同的位置 $i+j$，再最小化 $t$ 从 $j$ 开始的后缀**加上 $s$ 从 $i+1$ 开始的后缀**，再最小化 $s$ 中的位置 $i$。\r\n\r\n先枚举 $j$，枚举 $s_{i+j}=c$ 且 $t_j<c$，（**$c$ 要枚举极大字符**），可以用 SAM 做子串定位找到最小的 $i$ 使得 $s[i+1,i+j]=t[1,j-1]+c$。然后对于相等的 $i+j$，预处理 $t$ 的后缀排序即可比较 $t$ 的两个后缀的字典序大小。但是问题出在这里，如果两个后缀短的是长的的前缀，那就需要比较 $s$ 的后缀的部分。要将 $s$ 中的部分拉到 $t$ 的后缀上比较，后文后缀都指 $t$ 的后缀。用 height 数组求两个后缀的 lcp 即可判断后缀是否为另一个的前缀。\r\n\r\n要比较$i1+j1=i2+j2$ 的 $(i1,j1)$ 和 $(i2,j2)$ ，有 $j2>j1$。如果 $j2$ 开始的后缀不是 $j1$ 开始的后缀的前缀，就直接比较 $rk_{j1}$ 和 $rk_{j2}$。否则比较 $t[j1+m-j2+1,m]$ 和  $s[i2+1,i1]$，因为之前匹配，所以 $s[i2+1,i1]$ 是 $t$ 的前缀。如果从 $j1+m-j2+1$ 开始的后缀不是从 $1$ 开始的后缀的前缀，那比较 $rk_{j1+m-j2+1}$ 和 $rk_1$；否则两个串完全相等。\r\n\r\n此时已经找到了最小的串，但是 $i$ 选取的位置可以往前。找到 $t$ 的最小循环节 $l$，用字符串哈希向前比较 $s[i-l+1,i]$ 是否等于 $t[1,l]$，如果相等就可以把 $i$ 向前挪 $l$。二分加速，二分将 $i$ 向前挪 $l\\times mid$，要求 $s$ 每 $l$ 个一段都相等，即 $s[i-l\\times mid+1,i-mid]=s[i-l\\times (mid-1)+1,i]$。\r\n\r\n用了 $O(n\\log^2n)$ 的后缀排序，否则就 $O(n\\log n)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,q;\r\nchar s[maxn],t[maxn];\r\nint len[maxn],lnk[maxn];\r\nint a[maxn][11];\r\nint p=1,cur=1;\r\nint pos[maxn];\r\nvoid insert(int c){\r\n\tint nd=++cur;\r\n\tlen[nd]=len[p]+1;\r\n\tpos[nd]=len[nd];\r\n\twhile(p&&!a[p][c])a[p][c]=nd,p=lnk[p];\r\n\tif(!p){lnk[p=nd]=1;return ;}\r\n\tint q=a[p][c];\r\n\tif(len[p]+1==len[q])lnk[nd]=q;\r\n\telse{\r\n\t\tint cl=++cur;\r\n\t\tlen[cl]=len[p]+1,lnk[cl]=lnk[q];\r\n\t\tmemcpy(a[cl],a[q],sizeof(a[q]));\r\n\t\tlnk[nd]=lnk[q]=cl;\r\n\t\twhile(p&&a[p][c]==q)a[p][c]=cl,p=lnk[p];\r\n\t}\r\n\tp=nd;\r\n}\r\nvector<int> e[maxn];\r\nvoid dfs(int u){\r\n\tif(!pos[u])pos[u]=n+1;\r\n\tfor(int v:e[u]){\r\n\t\tdfs(v);\r\n\t\tpos[u]=min(pos[u],pos[v]);\r\n\t}\r\n}\r\nint sa[maxn],rk[maxn],tmp[maxn],ht[maxn];\r\nint st[20][maxn];\r\nint calc(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn min(st[k][l],st[k][r-(1<<k)+1]);\r\n}\r\nbool chk(int i,int j){return rk[i]>rk[j]&&calc(rk[j]+1,rk[i])==m-j+1;}\r\nint f[maxn],g[maxn];\r\nint val[11],bas,pw[maxn];\r\nmt19937 rnd(time(0));\r\nint calcf(int l,int r){if(l>r)return 0;return (f[r]-f[l-1]*pw[r-l+1]%mod+mod)%mod;}\r\nint calcg(int l,int r){if(l>r)return 0;return (g[r]-g[l-1]*pw[r-l+1]%mod+mod)%mod;}\r\nvoid work(){\r\n\tn=read();q=read();scanf(\"%s\",s+1);s[++n]='0'+10;\r\n\tfor(int i=0;i<=10;i++)val[i]=rnd()%mod;bas=rnd()%mod;\r\n\tpw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*bas%mod;\r\n\tfor(int i=1;i<=n;i++)f[i]=(f[i-1]*bas+val[s[i]-'0'])%mod;\r\n\tfor(int i=1;i<=n;i++)insert(s[i]-'0');\r\n\tfor(int i=2;i<=cur;i++)e[lnk[i]].pb(i);\r\n\tdfs(1);\r\n\twhile(q--){\r\n\t\tscanf(\"%s\",t+1);m=strlen(t+1);\r\n\t\tfor(int i=1;i<=m;i++)sa[i]=i,rk[i]=t[i]-'0'+1;\r\n\t\tfor(int len=1;len<m;len<<=1){\r\n\t\t\tsort(sa+1,sa+m+1,[&](int u,int v){\r\n\t\t\t\treturn rk[u]==rk[v]?rk[u+len]<rk[v+len]:rk[u]<rk[v];\r\n\t\t\t});\r\n\t\t\tfor(int i=1;i<=m;i++)tmp[i]=rk[i];\r\n\t\t\tfor(int i=1,v=0;i<=m;i++){\r\n\t\t\t\tif(tmp[sa[i]]==tmp[sa[i-1]]&&tmp[sa[i]+len]==tmp[sa[i-1]+len])rk[sa[i]]=v;\r\n\t\t\t\telse rk[sa[i]]=++v;\r\n\t\t\t}\r\n\t\t}\r\n\t\tht[1]=0;\r\n\t\tfor(int i=1,l=0;i<=m;i++){\r\n\t\t\tif(rk[i]==1)continue;\r\n\t\t\tif(l)l--;\r\n\t\t\twhile(min(i+l,sa[rk[i]-1]+l)<=m&&t[i+l]==t[sa[rk[i]-1]+l])l++;\r\n\t\t\tht[rk[i]]=l;\r\n\t\t}\r\n\t\tfor(int i=1;i<=m;i++)st[0][i]=ht[i];\r\n\t\tfor(int j=1;j<20;j++){\r\n\t\t\tfor(int i=1;i+(1<<j)-1<=m;i++){\r\n\t\t\t\tst[j][i]=min(st[j-1][i],st[j-1][i+(1<<j-1)]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=1;i<=m;i++)g[i]=(g[i-1]*bas+val[t[i]-'0'])%mod;\r\n\t\tint p1=n+1,p2=m+1;\r\n\t\tfor(int j=1,u=1;j<=m&&u;j++){\r\n\t\t\tfor(int c=t[j]-'0'+1;c<=10;c++)if(a[u][c]){\r\n\t\t\t\tint i=pos[a[u][c]]-j;\r\n\t\t\t\tif(i+j<p1+p2)p1=i,p2=j;\r\n\t\t\t\telse if(i+j==p1+p2){\r\n\t\t\t\t\tif(!chk(p2,j)){\r\n\t\t\t\t\t\tif(rk[j]<=rk[p2])p1=i,p2=j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(!chk(1,p2+m-j+1)){\r\n\t\t\t\t\t\tif(rk[1]<=rk[p2+m-j+1])p1=i,p2=j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse p1=i,p2=j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tu=a[u][t[j]-'0'];\r\n\t\t}\r\n\t\tint mm=m;\r\n\t\tfor(int i=1;i<m;i++)if(m%i==0){\r\n\t\t\tif(calcg(1,m-i)==calcg(i+1,m)){mm=i;break;}\r\n\t\t}\r\n\t\tif(calcf(p1-mm+1,p1)==calcg(1,mm)){\r\n\t\t\tint l=1,r=p1/mm,res=0;\r\n\t\t\twhile(l<=r){\r\n\t\t\t\tint mid=l+r>>1;\r\n\t\t\t\tif(calcf(p1-(mid-1)*mm+1,p1)==calcf(p1-mid*mm+1,p1-mm))l=mid+1,res=mid;\r\n\t\t\t\telse r=mid-1;\r\n\t\t\t}\r\n\t\t\tp1-=res*mm;\r\n\t\t}\r\n\t\tprintf(\"%lld\\n\",min(n-1,p1));\r\n\t}\r\n}\r\n\r\n/*\r\n3 1\r\n102\r\n101\r\n\r\n10 1\r\n0000110011\r\n1100110011\r\n*/\r\n```\r\n\r\n",
      "data": {
        "title": "P11150 题解",
        "date": "2025-02-03 21:13:40",
        "tags": [
          "题解",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11150-ti-jie"
    },
    {
      "content": "模拟线段树上的若干操作，然后查询相关的计数信息。\n\n学习自 [https://www.luogu.com/article/qh85y10k](https://www.luogu.com/article/qh85y10k)。\n\n## 区间定位数\n\n定义 $[l,r]$ 的区间定位数，为（广义）线段树上 $[l,r]$ 最少拆为多少个区间的并。\n\n区间 $[l,r]$ 在线段树上的区间定位数等于 $2\\times (r-l+1)-|S|$，其中 $S$ 为 $[l,r]$ 完全包含的区间数。\n\n### [P7143](https://www.luogu.com.cn/problem/P7143)\n\n> 对于 $[1,n]$ 的标准线段树求所有区间的区间定位数之和。\n\n前半部分拆开 $O(1)$ 算，后半部分 $|S|=\\sum l\\times (n-r+1)=(n+1)\\times \\sum l+\\sum l\\times r$，分治维护 $cnt,\\sum l,\\sum r,\\sum l\\times r$。\n\n```cpp\nint n;\nmap<int,int> cnt,sl,sr,slr,res;\nvoid sovle(int n){\n\tif(cnt[n])return ;\n\tif(n==1){\n\t\tcnt[n]=sl[n]=sr[n]=slr[n]=res[n]=1;\n\t\treturn ;\n\t}\n\tint mid=(n+1)>>1,vmid=mid%mod;\n\tsovle(mid),sovle(n-mid);\n\tcnt[n]=(cnt[mid]+cnt[n-mid]+1)%mod;\n\tsl[n]=(sl[mid]+sl[n-mid]+cnt[n-mid]*vmid+1)%mod;\n\tsr[n]=(sr[mid]+sr[n-mid]+cnt[n-mid]*vmid+n)%mod;\n\tslr[n]=(slr[mid]+slr[n-mid]+(sl[n-mid]+sr[n-mid])*vmid+cnt[n-mid]*vmid%mod*vmid+n)%mod;\n\tres[n]=((n%mod+1)*sl[n]+mod-slr[n])%mod;\n}\nint sum1(int n){return n*(n+1)/2%mod;}\nint sum2(int n){return n*(n+1)%mod*(2*n+1)%mod*ni(6)%mod;}\nvoid work(){\n\tn=read();sovle(n);\n\tint ans=2*(sum1(n%mod)*(n%mod+1)+mod-sum2(n%mod))%mod;\n\tprintf(\"%lld\\n\",(ans+mod-res[n])%mod);\n}\n```\n\n## 区间定位\n\n（广义）线段树上，$[l,r]$ 的区间定位可以描述为：\n\n取出 $[l-1,l-1]$ 和 $[r+1,r+1]$ 的 lca $U$。$[l-1,l-1]$ 到 $U$ 的左儿子（不含）的链上是左儿子的节点的右兄弟。右边同理。\n\n![](https://yhddd123.github.io/post-images/1738552008851.webp)\n\n额外建出 $[0,0]$ 和 $[n+1,n+1]$。\n\n### [P5210](https://www.luogu.com.cn/problem/P5210)\n\n> 对于 $[1,n]$ 的广义线段树 $q$ 次询问 $u,l,r$ 求 $\\sum_{v\\in S} dis(u,v)$。\n\n$\\sum_{v\\in S} dis(u,v)=|S|\\times dep_u+\\sum_{v\\in S}dep_v-2\\times \\sum_{v\\in S}dep_{lca(u,v)}$。设 $cl_u,cr_u,sl_u,sr_u$ 表示 $u$ 的所有祖先的左偏/右偏儿子的右兄弟/左兄弟的数量/深度和，求出 lca 后差分求出。\n\n对于 lca，分类讨论。如果 $u$ 在 $U$ 子树外，lca 为 $U$。否则假设在 $U$ 的左子树内，求出 $u$ 和 $[l-1,l-1]$ 的 lca $x$。对于 $U$ 右子树中的区间 lca 为 $U$；左子树 $x$ 一下的 lca 为 $x$；左子树 $x$ 以上都是 $u$ 的祖先，lca 为区间的父亲，特判 $u$ 在 $x$ 的右子树中时 $u$ 和 $x$ 的右儿子的 lca 不为 $x$ 而是 $x$ 的右儿子。\n\n```cpp\nint n,idx,rt,q;\nint ls[maxn],rs[maxn],fa[maxn],pos[maxn];\nint dfs(int l,int r){\n\tif(l>r)return 0;\n\tif(l==r)return pos[l]=++idx;\n\tint id=++idx,p=read();\n\tls[id]=dfs(l,p),rs[id]=dfs(p+1,r);\n\treturn id;\n}\nint st[20][maxn],dfn[maxn],tim,dep[maxn],siz[maxn];\nint cl[maxn],cr[maxn],sl[maxn],sr[maxn];\nvoid dfs(int u){\n\tif(!u)return ;\n\tdep[u]=dep[fa[u]]+1;siz[u]=1;\n\tcl[u]=cl[fa[u]]+(u==ls[fa[u]])*(rs[fa[u]]!=0),sl[u]=sl[fa[u]]+(u==ls[fa[u]])*dep[u];\n\tcr[u]=cr[fa[u]]+(u==rs[fa[u]])*(ls[fa[u]]!=0),sr[u]=sr[fa[u]]+(u==rs[fa[u]])*dep[u];\n\tst[0][dfn[u]=++tim]=fa[u];\n\tdfs(ls[u]),dfs(rs[u]);\n\tsiz[u]+=siz[ls[u]]+siz[rs[u]];\n}\nint mmax(int u,int v){return dfn[u]<dfn[v]?u:v;}\nint lca(int u,int v){\n\tif(u==v)return u;\n\tu=dfn[u],v=dfn[v];\n\tif(u>v)swap(u,v);u++;\n\tint k=__lg(v-u+1);\n\treturn mmax(st[k][u],st[k][v-(1<<k)+1]);\n}\nbool in(int u,int v){return dfn[u]<=dfn[v]&&dfn[v]<dfn[u]+siz[u];}\nvoid work(){\n\tn=read();rt=dfs(1,n);\n\tpos[0]=++idx;ls[++idx]=pos[0];rs[idx]=rt;rt=idx;\n\tpos[n+1]=++idx;rs[++idx]=pos[n+1];ls[idx]=rt;rt=idx;\n\tfor(int i=1;i<=idx;i++)fa[ls[i]]=fa[rs[i]]=i;fa[0]=0;\n\tdfs(rt);\n\tfor(int j=1;j<20;j++){\n\t\tfor(int i=1;i+(1<<j)-1<=idx;i++)st[j][i]=mmax(st[j-1][i],st[j-1][i+(1<<j-1)]);\n\t}\n\tq=read();\n\twhile(q--){\n\t\tint u=read(),l=read(),r=read(),tp=lca(pos[l-1],pos[r+1]);\n\t\tint num=cl[pos[l-1]]-cl[ls[tp]]+cr[pos[r+1]]-cr[rs[tp]];\n\t\tint sum=sl[pos[l-1]]-sl[ls[tp]]+sr[pos[r+1]]-sr[rs[tp]];\n\t\tint ans=num*dep[u]+sum;\n\t\tif(!in(tp,u)||u==tp)ans-=2*dep[lca(u,tp)]*num;\n\t\telse if(in(ls[tp],u)){\n\t\t\tint x=lca(pos[l-1],u);\n\t\t\tans-=2*dep[tp]*(cr[pos[r+1]]-cr[rs[tp]]);\n\t\t\tans-=2*(sl[x]-sl[ls[tp]]-(cl[x]-cl[ls[tp]]));\n\t\t\tif(in(rs[x],u))ans-=2;\n\t\t\tans-=2*dep[x]*(cl[pos[l-1]]-cl[x]);\n\t\t}\n\t\telse{\n\t\t\tint x=lca(pos[r+1],u);\n\t\t\tans-=2*dep[tp]*(cl[pos[l-1]]-cl[ls[tp]]);\n\t\t\tans-=2*(sr[x]-sr[rs[tp]]-(cr[x]-cr[rs[tp]]));\n\t\t\tif(in(ls[x],u))ans-=2;\n\t\t\tans-=2*dep[x]*(cr[pos[r+1]]-cr[x]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n```\n\n## 区间修改的 tag 下放\n\n按对 $[l,r]$ 做区间操作时 tag 的下放对节点的 tag 的不同影响将节点分为 $5$ 类。\n\n1.访问到并继续递归的结点。不管之前什么样，现在肯定没标记。\n\n2.区间定位点。不管之前什么样，现在肯定有标记。\n\n3.$2$ 的真后代。不变。\n\n4.$1$ 的儿子，且不是 $1,2$。如果有祖先或自己有标记则有标记。\n\n5.$4$ 的真后代。不变。\n\n![](https://yhddd123.github.io/post-images/1738552040412.webp)\n\n维护 $f_i,g_i$ 表示 节点/节点及祖先 有没有标记即可转移。\n\n### [P5280](https://www.luogu.com.cn/problem/P5280)\n\n>  $q$ 次操作。有 $\\frac{1}{2}$ 的概率对 $[l,r]$ 做区间修改；询问期望有几个节点有 tag。\n\n对于 $1$ 类点，$\\frac{f'_i}{2}\\to f_i,\\frac{g'_i}{2}\\to g_i$；对于 $2$ 类点，$\\frac{f'_i+1}{2}\\to f_i,\\frac{g'_i+1}{2}\\to g_i$；对于 $4$ 类点，$\\frac{f'_i+g'_i}{2}\\to f_i$。\n\n线段树维护即可。可以维护 $gg_i=1-g_i$ 然后 $\\frac{gg'_i}{2}\\to gg_i$，维护除了几次 $2$。\n\n```cpp\nint n,q,ans;\nint inv[maxn];\n#define mid (l+r>>1)\n#define ls nd<<1\n#define rs nd<<1|1\nint f[maxn<<2],g[maxn<<2],tag[maxn<<2];\nvoid build(int nd,int l,int r){\n\tg[nd]=1;\n\tif(l==r)return ;\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n}\nvoid inc(int &u,int v){((u+=v)>=mod)&&(u-=mod);}\nvoid downf(int nd,int w){\n\tinc(ans,mod-f[nd]),f[nd]=(f[nd]+w)*inv[1]%mod,inc(ans,f[nd]);\n}\nvoid downg(int nd,int w){\n\tg[nd]=g[nd]*inv[w]%mod,tag[nd]+=w;\n}\nvoid down(int nd){\n\tdowng(ls,tag[nd]),downg(rs,tag[nd]),tag[nd]=0;\n}\nvoid updata(int nd,int l,int r,int ql,int qr){\n\tif(l>=ql&&r<=qr){downf(nd,1),downg(nd,1);return ;}\n\tif(tag[nd])down(nd);\n\tif(ql<=mid)updata(ls,l,mid,ql,qr);\n\telse downf(ls,mod+1-g[ls]);\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr);\n\telse downf(rs,mod+1-g[rs]);\n\tdownf(nd,0);g[nd]=(g[nd]+1)*inv[1]%mod;\n}\nvoid work(){\n\tn=read();q=read();int mul=1;\n\tbuild(1,1,n);\n\tinv[0]=1,inv[1]=(mod+1)/2;for(int i=2;i<=q;i++)inv[i]=inv[i-1]*inv[1]%mod;\n\twhile(q--){\n\t\tint op=read();\n\t\tif(op==1){\n\t\t\tmul=mul*2%mod;\n\t\t\tint l=read(),r=read();\n\t\t\tupdata(1,1,n,l,r);\n\t\t}\n\t\telse printf(\"%lld\\n\",ans*mul%mod);\n\t}\n}\n```\n\n### [P6630](https://www.luogu.com.cn/problem/P6630)\n\n> $k$ 次随机选取 $[l,r]$ 做区间修改，询问最后期望有几个节点有 tag。\n\n对于 $1$ 类点，$f_i=g_i=0$；对于 $2$ 类点，$f_i=g_i=1$；对于 $3$ 类点，$f_i=f'_i,g_i=1$；对于 $4$ 类点，$f_i=g_i=g'_i$；对于 $5$ 类点，$f_i=f'_i,g_i=g'_i$。\n\n对于区间 $[l,r]$，父亲为 $[fl,fr]$，选取 $[ql,qr]$ 使得 $[l,r]$ 成为某类点的方案数分别为。记 $val_i=\\frac{i\\times(i+1)}{2}$。成为 $1$ 类点，$val_n-val_{l-1}-val_{n-r}-l\\times (n-r+1)$；成为 $2$ 类点，$l\\times (n-r+1)-fl\\times (n-fr+1)$；成为 $3$ 类点，$fl\\times (n-fr+1)$；成为 $4$ 类点，$val_{l-1}+val_{n-r}-val_{fl-1}-val_{n-fr}$；成为 $5$ 类点，$val_{fl-1}+val_{n-fr}$；\n\n维护 $f,g,1$ 的 $3\\times 3$ 矩阵。\n\n```cpp\nint n,k,ans,inv;\nint val(int n){return n*(n+1)/2%mod;}\nvoid calc(int l,int r,int fl,int fr){\n\tmat a;\n\ta.e[2][2]=1;\n\tint p1=(val(n)-val(l-1)-val(n-r)-l*(n-r+1)%mod+3*mod)*inv%mod;\n\tint p2=(l*(n-r+1)%mod-fl*(n-fr+1)%mod+mod)*inv%mod;\n\tint p3=fl*(n-fr+1)%mod*inv%mod;\n\tint p4=(val(l-1)+val(n-r)-val(fl-1)-val(n-fr)+2*mod)*inv%mod;\n\tint p5=(val(fl-1)+val(n-fr))*inv%mod;\n\t// assert((p1+p2+p3+p4+p5)%mod==1);\n\t(a.e[2][0]+=p2)%=mod;\n\t(a.e[2][1]+=p2)%=mod;\n\t(a.e[0][0]+=p3)%=mod;\n\t(a.e[2][1]+=p3)%=mod;\n\t(a.e[1][0]+=p4)%=mod;\n\t(a.e[1][1]+=p4)%=mod;\n\t(a.e[0][0]+=p5)%=mod;\n\t(a.e[1][1]+=p5)%=mod;\n\ta=ksm(a,k);\n\t(ans+=a.e[2][0])%=mod;\n}\nvoid dfs(int l,int r,int fl,int fr){\n\tif(l>r)return ;\n\tcalc(l,r,fl,fr);\n\tif(l==r)return ;\n\tint p=read();\n\tdfs(l,p,l,r),dfs(p+1,r,l,r);\n}\nvoid work(){\n\tn=read();k=read();inv=ni(val(n));\n\tdfs(1,n,0,n);\n\tprintf(\"%lld\\n\",ans);\n}\n```",
      "data": {
        "title": "线段树区间定位",
        "date": "2025-02-03 09:22:48",
        "tags": [
          "笔记",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "xian-duan-shu-qu-jian-ding-wei"
    },
    {
      "content": "## 耳分解\n\n![](https://yhddd123.github.io/post-images/1738238829287.gif)\n\n简单路径/环 $V_1,\\dotsb,V_k$，其中 $V_2,\\dotsb,V_{k-1}$ 不属于 $V'$，称为耳/开耳。从一个点/简单环开始不断加入耳，成为耳分解。如果全是开耳成为开耳分解。\n\n有向图可耳分解等价于强连通；无向图可耳分解等价于边双；无向图可开耳分解等价于点双。\n\n可以 $O(2^nn^3)$ 状压拆分耳分解。\n\n### [P5776](https://www.luogu.com.cn/problem/P5776)\n\n>  求最小边权的边双子图。\n\n设 $f_s$ 表示 $s$ 的最小权边双连通分量，$g_{s,i,j}$ 表示拓展耳到 $i$，终点为 $j$。规定只有 $i\\notin S$ 才能成为一个合法的耳，枚举 $i\\to k$ 后将 $i$ 加入 $s$ 中，$j$ 用于区分是耳上的点还是原来的点。\n\n转移有：加 $u\\to v\\to u$；$i=j$ 时再枚举一个 $l\\neq j$ 以区分，$i\\neq j$  时 $f_s$ 更新给 $g_{s,k,j}$。\n\n```cpp\nint n,m;\nint f[1<<12],g[1<<12][12][12];\nint e[12][12][2];\nvoid work(){\n\tn=read();m=read();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++)e[i][j][0]=e[i][j][1]=inf;\n\t}\n\tfor(int s=0;s<(1<<n);s++){\n\t\tf[s]=inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++)g[s][i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read()-1,v=read()-1,w=read();\n\t\tif(w<e[u][v][0])e[u][v][1]=e[u][v][0],e[u][v][0]=w;\n\t\telse if(w<e[u][v][1])e[u][v][1]=w;\n\t\tswap(u,v);\n\t\tif(w<e[u][v][0])e[u][v][1]=e[u][v][0],e[u][v][0]=w;\n\t\telse if(w<e[u][v][1])e[u][v][1]=w;\n\t}\n\tfor(int i=0;i<n;i++)f[1<<i]=0;\n\tfor(int s=1;s<(1<<n);s++){\n\t\tfor(int i=0;i<n;i++)if(s&(1<<i)){\n\t\t\tfor(int j=0;j<n;j++)if(!(s&(1<<j))){\n\t\t\t\tf[s|(1<<j)]=min(f[s|(1<<j)],f[s]+e[i][j][0]+e[i][j][1]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(s&(1<<i)){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\n\t\t\t\t\tif(i==j)g[s|(1<<k)][k][j]=min(g[s|(1<<k)][k][j],f[s]+e[i][k][0]);\n\t\t\t\t\telse g[s][k][j]=min(g[s][k][j],f[s]+e[i][k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\n\t\t\t\t\tg[s|(1<<i)][k][j]=min(g[s|(1<<i)][k][j],g[s][i][j]+e[i][k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(!(s&(1<<i))){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tf[s|(1<<i)]=min(f[s|(1<<i)],g[s][i][j]+e[i][j][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif(f[(1<<n)-1]==inf)puts(\"impossible\");\n\telse printf(\"%lld\\n\",f[(1<<n)-1]);\n}\n```\n\n### [Q3301](https://qoj.ac/problem/3301)\n\n> 给无向图定向，求最小边权的强连通图。\n\n$f_s$ 表示 $s$ 内定向为强连通图的最小代价，$g_{s,i,j}$ 表示耳的代价加上 $i$ 到 $s$ 除了 $j$ 的所有点乱定向的最小代价。额外记 $sum_{u,s}$ 表示点 $u$ 到 $s$ 的乱定向的最小代价。\n\n```cpp\nint n,e[18][18];\nint f[1<<18],g[1<<18][18][18];\nint sum[18][1<<18],val[18][18];\nvoid work(){\n\tn=read();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\te[i][j]=read();\n\t\t\tif(e[i][j]==-1)e[i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(e[i][j]<inf)val[i][j]=min(e[i][j],e[j][i]);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int s=1;s<(1<<n);s++){\n\t\t\tint lg=__lg(s&(-s));\n\t\t\tsum[i][s]=sum[i][s^(s&(-s))]+val[i][lg];\n\t\t}\n\t}\n\tfor(int s=0;s<(1<<n);s++){\n\t\tf[s]=inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++)g[s][i][j]=inf;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)f[1<<i]=0;\n\tfor(int s=1;s<(1<<n);s++){\n\t\tfor(int i=0;i<n;i++)if(s&(1<<i)){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\n\t\t\t\t\tif(i==j){\n\t\t\t\t\t\tfor(int l=0;l<n;l++)if(!(s&(1<<l))){\n\t\t\t\t\t\t\tg[s|(1<<k)][l][j]=min(g[s|(1<<k)][l][j],f[s]+e[i][k]+e[k][l]+sum[k][s^(1<<i)]+sum[l][s^(1<<j)]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse g[s][k][j]=min(g[s][k][j],f[s]+e[i][k]+sum[k][s^(1<<i)^(1<<j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(!(s&(1<<i))){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tfor(int k=0;k<n;k++)if(!(s&(1<<k))){\n\t\t\t\t\tg[s|(1<<i)][k][j]=min(g[s|(1<<i)][k][j],g[s][i][j]+e[i][k]+val[i][j]+sum[k][s^(1<<j)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(!(s&(1<<i))){\n\t\t\tfor(int j=0;j<n;j++)if(s&(1<<j)){\n\t\t\t\tf[s|(1<<i)]=min(f[s|(1<<i)],g[s][i][j]+e[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tif(f[(1<<n)-1]==inf)f[(1<<n)-1]=-1;\n\tprintf(\"%lld\\n\",f[(1<<n)-1]);\n}\n```\n\n## 双极定向\n\n对于一个无向图，点 $s$ 和 $t$，$4$ 个等价的问题：\n\n- 加入 $(s,t)$ 后图点双连通。\n- 图的所有点双成一条链，且 $s$ 和 $t$ 所在的点双分别在两端。\n- 存在一种定向方式，形成 DAG，使得只有 $s$ 无入度，$t$ 无出度。\n- 存在一个排列 p，$p_1=s$，$p_n=t$，且任意一个前缀和后缀的导出子图都连通。即依次由白染黑，黑白点都是连通的。\n\n$3\\to 4$ ：取拓扑序。$4\\to 3$ ：出现在前的向出现在后的连边。$1\\to 3$ ：做开耳分解。\n\n构造：建 $s$ 为根的 dfs 树。对于一个节点 $u$，当 $fa_u$ 或 $u$ 子树返祖边去到的最浅祖先 $lw_u$ 之一被染黑时，将 $u$ 染黑。保留 $s\\to t$ 的路径后，从下往上剥去叶子，对每个点维护后继的点。从 $s$ 开始沿着 $s\\to t$ 的路径 dfs。不合法即不存在双极定向。\n\n#### 模板：[CF730K](https://www.luogu.com.cn/problem/CF730K)\n\n```cpp\nint n,m,s,t;\nint head[maxn],tot;\nstruct nd{\n\tint nxt,to;\n}e[maxn<<1];\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\npii g[maxn];\nint lw[maxn],dfn[maxn],idx,fa[maxn];\nvector<int> id;\nbool vis[maxn];\nbool dfs(int u){\n\tdfn[u]=lw[u]=++idx;vis[u]=1;\n\tbool fl=u==t;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(!vis[v]){\n\t\t\tfa[v]=u;fl|=dfs(v);\n\t\t\tlw[u]=min(lw[u],lw[v]);\n\t\t}\n\t\telse lw[u]=min(lw[u],dfn[v]);\n\t}\n\tif(fl)id.pb(u);\n\treturn fl;\n}\nqueue<int> q;\nint d[maxn];\nvector<int> a[maxn];\nint st[maxn],tp,rnk[maxn];\nvoid dfs1(int u){\n\tif(vis[u])return ;vis[u]=1;\n\tst[++tp]=u;\n\tfor(int v:a[dfn[u]])dfs1(v);\n}\nvoid work(){\n\tn=read();m=read();s=read();t=read();\n\tfor(int i=1;i<=n;i++)head[i]=0;tot=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tadd(u,v),add(v,u);\n\t\tg[i]={u,v};\n\t}\n\tidx=0;id.clear();\n\tfor(int i=1;i<=n;i++)vis[i]=0;\n\tfa[s]=0;dfs(s);\n\tfor(int i=1;i<=n;i++)d[i]=0;\n\tfor(int i:id)d[i]++;\n\tfor(int i=1;i<=n;i++)d[fa[i]]++;\n\tfor(int i=1;i<=n;i++)if(!d[i])q.push(i);\n\tfor(int i=1;i<=n;i++)a[i].clear();\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\ta[lw[u]].pb(u),a[dfn[fa[u]]].pb(u);\n\t\td[fa[u]]--;\n\t\tif(!d[fa[u]])q.push(fa[u]);\n\t}\n\ttp=0;\n\tfor(int i=1;i<=n;i++)vis[i]=0;\n\twhile(id.size())dfs1(id.back()),id.pop_back();\n\tif(st[1]!=s||st[tp]!=t){puts(\"No\");return ;}\n\tif(tp!=n){puts(\"No\");return ;}\n\tfor(int i=1;i<=n;i++)vis[i]=0;\n\tvis[st[1]]=1;\n\tfor(int i=2;i<=tp;i++){\n\t\tint u=st[i];bool fl=0;\n\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].to;\n\t\t\tfl|=vis[v];\n\t\t}\n\t\tif(!fl){puts(\"No\");return ;}\n\t\tvis[u]=1;\n\t}\n\tfor(int i=1;i<=n;i++)vis[i]=0;\n\tvis[st[tp]]=1;\n\tfor(int i=tp-1;i;i--){\n\t\tint u=st[i];bool fl=0;\n\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].to;\n\t\t\tfl|=vis[v];\n\t\t}\n\t\tif(!fl){puts(\"No\");return ;}\n\t\tvis[u]=1;\n\t}\n\tfor(int i=1;i<=n;i++)rnk[st[i]]=i;\n\tputs(\"Yes\");\n\tfor(int i=1;i<=m;i++){\n\t\tauto[u,v]=g[i];\n\t\tif(rnk[u]>rnk[v])swap(u,v);\n\t\tprintf(\"%lld %lld\\n\",u,v);\n\t}\n}\n```\n\n### [P9394](https://www.luogu.com.cn/problem/P9394)\n\n每次染黑一个点集，要求黑白点都是连通的，最小化最大的点集大小。\n\n建圆方树后，假设从 $s$ 去到 $t$，lca 为 $u$。代价为 $s\\to t$ 路径上 $v$ 向外的子树大小之和。可以说明，对于路径上一点 $x$，下一个点为 $x$ 的重儿子最优。对于 $u$，$s,t$ 分别在重儿子子树和次重儿子子树中。设 $f_u$ 表示 $u$ 子树去到叶子的最大代价。在 lca 求最小代价。\n\n将节点分为若干集合后跑双极定向。\n\n```cpp\nint n,m;\nint head[maxn],tot;\nstruct nd{\n\tint nxt,to;\n}e[maxn<<1];\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\nint dfn[maxn],lw[maxn],idx;\nint st[maxn],tp,scct;\nvector<int> g[maxn];\nvoid addg(int u,int v){g[u].pb(v),g[v].pb(u);}\nvoid tar(int u){\n\tdfn[u]=lw[u]=++idx;st[++tp]=u;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(!dfn[v]){\n\t\t\ttar(v);\n\t\t\tlw[u]=min(lw[u],lw[v]);\n\t\t\tif(lw[v]>=dfn[u]){\n\t\t\t\t++scct;\n\t\t\t\taddg(scct,st[tp]);\n\t\t\t\twhile(st[tp--]!=v)addg(scct,st[tp]);\n\t\t\t\taddg(scct,u);\n\t\t\t}\n\t\t}\n\t\telse lw[u]=min(lw[u],dfn[v]);\n\t}\n}\nint siz[maxn],fa[maxn],mx[maxn],se[maxn];\nint f[maxn];\npii ans;\nvoid dfs(int u){\n\tsiz[u]=(u<=n);\n\tfor(int v:g[u])if(v!=fa[u]){\n\t\tfa[v]=u;dfs(v);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[mx[u]])se[u]=mx[u],mx[u]=v;\n\t\telse if(siz[v]>siz[se[u]])se[u]=v;\n\t}\n\tint v1=u<=n,v2=u<=n;\n\tfor(int v:g[u])if(v!=fa[u]&&v!=mx[u]){\n\t\tif(u<=n)v1+=siz[v];\n\t\telse v1=max(v1,siz[v]);\n\t}\n\tf[u]=max(v1,f[mx[u]]);\n\tfor(int v:g[u])if(v!=fa[u]&&v!=mx[u]&&v!=se[u]){\n\t\tif(u<=n)v2+=siz[v];\n\t\telse v2=max(v2,siz[v]);\n\t}\n\tif(u<=n)v2+=n-siz[u];\n\telse v2=max(v2,n-siz[u]);\n\tv2=max({v2,f[mx[u]],f[se[u]]});\n\tans=min(ans,{v2,u});\n}\nbool vis[maxn];\nint col[maxn],cnt;\nvector<int> id[maxn];\nvoid dfs1(int u){\n\tif(col[u]||vis[u])return ;col[u]=cnt;\n\tif(u<=n)id[cnt].pb(u);\n\tfor(int v:g[u])dfs1(v);\n}\nint s,t;\nvector<int> h[maxn];\nvector<int> a[maxn],b;\nbool dfs2(int u){\n\tdfn[u]=lw[u]=++idx;\n\tbool fl=u==t;\n\tfor(int v:h[u]){\n\t\tif(!dfn[v]){\n\t\t\tfa[v]=u;fl|=dfs2(v);\n\t\t\tlw[u]=min(lw[u],lw[v]);\n\t\t}\n\t\telse lw[u]=min(lw[u],dfn[v]);\n\t}\n\tif(fl)b.pb(u);\n\treturn fl;\n}\nqueue<int> q;\nint d[maxn];\nvoid dfs3(int u){\n\tif(vis[u])return ;vis[u]=1;\n\tst[++tp]=u;\n\tfor(int v:a[dfn[u]])dfs3(v);\n}\nvoid work(){\n\tn=read();m=read();scct=n;\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tadd(u,v),add(v,u);\n\t}\n\ttar(1);\n\tans={inf,0};dfs(1);\n\tif(ans.se>n)vis[ans.se]=1;\n\tint p1=ans.se,p2=ans.se;\n\tfor(int u=mx[ans.se];u;u=mx[u]){\n\t\tif(u>n)vis[u]=1;\n\t\telse p1=u;\n\t}\n\tfor(int u=se[ans.se];u;u=mx[u]){\n\t\tif(u>n)vis[u]=1;\n\t\telse p2=u;\n\t}\n\tfor(int i=1;i<=scct;i++)if(!col[i]&&!vis[i])++cnt,dfs1(i);\n\ts=col[p1],t=col[p2];\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].to;\n\t\t\tif(col[u]!=col[v])h[col[u]].pb(col[v]);\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt;i++)dfn[i]=fa[i]=0;tp=idx=0;\n\tdfs2(s);\n\tfor(int i:b)d[i]++;\n\tfor(int i=1;i<=cnt;i++)if(fa[i])d[fa[i]]++;\n\tfor(int i=1;i<=cnt;i++)if(!d[i])q.push(i);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\ta[lw[u]].pb(u),a[dfn[fa[u]]].pb(u);\n\t\td[fa[u]]--;\n\t\tif(!d[fa[u]])q.push(fa[u]);\n\t}\n\tfor(int i=1;i<=cnt;i++)vis[i]=0;\n\twhile(b.size())dfs3(b.back()),b.pop_back();\n\tprintf(\"%lld %lld\\n\",ans.fi,cnt);\n\tfor(int i=1;i<=cnt;i++){\n\t\tprintf(\"%lld \",id[st[i]].size());\n\t\tfor(int j:id[st[i]])printf(\"%lld \",j);puts(\"\");\n\t}\n}\n```",
      "data": {
        "title": "图论连通性问题",
        "date": "2025-01-19 21:48:54",
        "tags": [
          "笔记",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "tu-lun-lian-tong-xing-wen-ti"
    },
    {
      "content": "维护一前一后两个栈，正常插入删除。如果某一个栈删空了，将另一个栈的一半扔过去，重构。可以认为两半等价，对于每个元素，只会被扔到对面一次，复杂度 $O(n)$。\n\n例：[CF2026F](https://www.luogu.com.cn/problem/CF2026F)\n\n```cpp\nvector<int> st,ed;\nvoid push_front(int x){st.pb(x);}\nvoid push_back(int x){ed.pb(x);}\nvoid rebuild(){\n\t\n}\nvoid rebuildfront(){\n\tint pos=(ed.size()+1)/2;\n\tfor(int i=0;i<pos;i++)st.pb(ed[i]);\n\treverse(st.begin(),st.end());\n\treverse(ed.begin(),ed.end());\n\tfor(int i=1;i<=pos;i++)ed.pop_back();\n\treverse(ed.begin(),ed.end());\n\trebuild();\n}\nvoid rebuildback(){\n\tint pos=(st.size()+1)/2;\n\tfor(int i=0;i<pos;i++)ed.pb(st[i]);\n\treverse(ed.begin(),ed.end());\n\treverse(st.begin(),st.end());\n\tfor(int i=1;i<=pos;i++)st.pop_back();\n\treverse(st.begin(),st.end());\n\trebuild();\n}\nint front(){\n\tif(!st.size())rebuildfront();\n\treturn st.back();\n}\nint back(){\n\tif(!ed.size())rebuildback();\n\treturn ed.back();\n}\nvoid pop_front(){\n\tif(!st.size())rebuildfront();\n\tst.pop_back();\n}\nvoid pop_back(){\n\tif(!ed.size())rebuildback();\n\ted.pop_back();\n}\nint size(){\n\treturn st.size()+ed.size();\n}\n```",
      "data": {
        "title": "deque 实现",
        "date": "2025-01-16 22:06:53",
        "tags": [
          "笔记",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "deque-shi-xian"
    },
    {
      "content": "[CF2026F](https://www.luogu.com.cn/problem/CF2026F)\n\n### 思路\n\n离线建出版本树，需要支持在两端加入删除并维护背包，形如 deque。维护两个栈，一头一尾，分别维护背包，$O(V)$ 合并两个背包。复杂度 $(qV)$。\n\n### code\n\n```cpp\nint q,idx,tot,cntq;\nint rt[maxn],ans[maxn];\nvector<pii> que[maxn];\nvector<pair<int,pii>> e[maxn];\nvector<pii> st,ed;\nint f[maxn][maxv],g[maxn][maxv];\nvoid addback(int p,int t){\n\ted.pb({p,t});int tim=ed.size();\n\tfor(int i=0;i<=maxv-10;i++)g[tim][i]=g[tim-1][i];\n\tfor(int i=p;i<=maxv-10;i++)g[tim][i]=max(g[tim][i],g[tim-1][i-p]+t);\n}\nvoid addfront(int p,int t){\n\tst.pb({p,t});int tim=st.size();\n\tfor(int i=0;i<=maxv-10;i++)f[tim][i]=f[tim-1][i];\n\tfor(int i=p;i<=maxv-10;i++)f[tim][i]=max(f[tim][i],f[tim-1][i-p]+t);\n}\nvoid rebuild(){\n\tfor(int tim=1;tim<=ed.size();tim++){\n\t\tauto[p,t]=ed[tim-1];\n\t\tfor(int i=0;i<=maxv-10;i++)g[tim][i]=g[tim-1][i];\n\t\tfor(int i=p;i<=maxv-10;i++)g[tim][i]=max(g[tim][i],g[tim-1][i-p]+t);\n\t}\n\tfor(int tim=1;tim<=st.size();tim++){\n\t\tauto[p,t]=st[tim-1];\n\t\tfor(int i=0;i<=maxv-10;i++)f[tim][i]=f[tim-1][i];\n\t\tfor(int i=p;i<=maxv-10;i++)f[tim][i]=max(f[tim][i],f[tim-1][i-p]+t);\n\t}\n}\nvoid rebuildfront(){\n\tint pos=(ed.size()+1)/2;\n\tfor(int i=0;i<pos;i++)st.pb(ed[i]);\n\treverse(st.begin(),st.end());\n\treverse(ed.begin(),ed.end());\n\tfor(int i=1;i<=pos;i++)ed.pop_back();\n\treverse(ed.begin(),ed.end());\n\trebuild();\n}\nvoid rebuildback(){\n\tint pos=(st.size()+1)/2;\n\tfor(int i=0;i<pos;i++)ed.pb(st[i]);\n\treverse(ed.begin(),ed.end());\n\treverse(st.begin(),st.end());\n\tfor(int i=1;i<=pos;i++)st.pop_back();\n\treverse(st.begin(),st.end());\n\trebuild();\n}\npii popfront(){\n\tif(!st.size())rebuildfront();\n\tpii p=st.back();st.pop_back();\n\treturn p;\n}\npii popback(){\n\tif(!ed.size())rebuildback();\n\tpii p=ed.back();ed.pop_back();\n\treturn p;\n}\nint query(int v){\n\tint ans=0;\n\tfor(int i=0;i<=v;i++)ans=max(ans,f[st.size()][i]+g[ed.size()][v-i]);\n\treturn ans;\n}\nvoid dfs(int u){\n\tfor(auto[v,id]:que[u])ans[id]=query(v);\n\tfor(auto[v,p]:e[u]){\n\t\tif(!p.fi){\n\t\t\tpii w=popfront();\n\t\t\tdfs(v);\n\t\t\taddfront(w.fi,w.se);\n\t\t}\n\t\telse{\n\t\t\taddback(p.fi,p.se);\n\t\t\tdfs(v);\n\t\t\tpopback();\n\t\t}\n\t}\n}\nvoid work(){\n\tq=read();rt[1]=idx=tot=1;\n\twhile(q--){\n\t\tint opt=read();\n\t\tif(opt==1){\n\t\t\tint x=read();\n\t\t\trt[++idx]=rt[x];\n\t\t}\n\t\tif(opt==2){\n\t\t\tint x=read(),p=read(),t=read();\n\t\t\te[rt[x]].pb({++tot,{p,t}}),rt[x]=tot;\n\t\t}\n\t\tif(opt==3){\n\t\t\tint x=read();\n\t\t\te[rt[x]].pb({++tot,{0,0}}),rt[x]=tot;\n\t\t}\n\t\tif(opt==4){\n\t\t\tint x=read(),p=read();\n\t\t\tque[rt[x]].pb({p,++cntq});\n\t\t}\n\t}\n\tdfs(1);\n\tfor(int i=1;i<=cntq;i++)printf(\"%lld\\n\",ans[i]);\n}\n```\n\n",
      "data": {
        "title": "CF2026F 题解",
        "date": "2025-01-16 21:59:00",
        "tags": [
          "dp",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf2026f-ti-jie"
    },
    {
      "content": "\r\n\r\n## 1.06\r\n\r\n### [CF1975G](https://www.luogu.com.cn/problem/CF1975G)\r\n\r\n如果两边都存在任意符，或都不存在任意符直接比较即可。判掉两端的固定字符。a 没有任意符，b 有任意符。任意符将 b 分为若干长为 $m$ 的段 ，在长为 $n$ 的 a 中做[带通配符的字符串匹配](https://yhddd123.github.io/post/mo-ban/#%E5%B8%A6%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D)，贪心取最前的一个匹配的位置。$m$ 可能很小但很多，所以一次取 a 的前 $2\\times m$ 进行匹配，如果失败删去前 $m$ 个。复杂度 $O(m\\log m)$。\r\n\r\n### [P8518](https://www.luogu.com.cn/problem/P8518)\r\n\r\n对盒子扫描线，线段树维护时间，形如后缀加减。只需要关心最后一次顶上下界，即线段树二分最后一次 $\\max-\\min\\ge a_i$。然后分讨计算。\r\n\r\n## 1.07\r\n\r\n### [CF1503D](https://www.luogu.com.cn/problem/CF1503D)\r\n\r\n一定有 $\\min (a_i,b_i)\\le n$，$\\max(a_i,b_i)>n$。按 $\\max(a_i,b_i)$ 降序排序取出两个 $\\min(a_i,b_i)$ 升序的子序列。线段树维护。\r\n\r\n### [P11519](https://www.luogu.com.cn/problem/P11519)\r\n\r\n[并查集启发式分裂](https://yhddd123.github.io/post/bing-cha-ji-qi-fa-shi-fen-lie/)。\r\n\r\n## 1.09\r\n\r\n### [P6822](https://www.luogu.com.cn/problem/P6822)\r\n\r\n建超级源汇点，拆成有向边，化边为点。每条边向反向边连其权值。把每个点的出边权值排序，相邻的小的向大的连权值的差值。跑最短路。\r\n\r\n### [P3587](https://www.luogu.com.cn/problem/P3587)\r\n\r\n异或哈希，改同颜色最后一个点的权值使得同颜色异或为 $0$。\r\n\r\n## 1.10\r\n\r\n### [CF1753F](https://www.luogu.com.cn/problem/CF1753F)\r\n\r\n枚举对角线确定正方形，同条对角线有决策单调性。每条对角线只用加入 $(min(n,m))^2$ 个点，每个点只会被枚举 $\\min(n,m)$ 次。每条对角线只用查询 $\\min(n,m)$ 次。只需要 插入 $O(1)$ 查询 $O(\\sqrt k)$ 的分块求 mex 即可。",
      "data": {
        "title": "2025.1 做题记录",
        "date": "2025-01-10 13:45:00",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20251-zuo-ti-ji-lu"
    },
    {
      "content": "真正区别从来不是一群人盼国家好，一群人盼国家不好，而是都盼着国家好，只不过双方对国家要变好的路线有完全不同的认知。\r\n\r\n他们相信天堂是有的，可以实现的，但在现实世界与那天堂的中间隔着一座海，一座血污海，人类泅得过这血海，才能登彼岸，他们决定先实现那血海。\r\n\r\n我们在今日谈宪政，谈民主，谈国共问题，谈结束训政，谈美苏对峙的两个世界，似乎都应该先认清世界上有两种根本不同的政党。\r\n\r\n人们一边被禁止阅读书籍，一边自发地不再阅读书籍；一边被剥夺获取信息的权利，一边又深陷垃圾信息的汪洋大海中；一边真相被隐瞒，一边真相被淹没；一边是被砍伐殆尽的文化荒漠，一边又疯狂生长着毫无价值的杂草和荆棘……\r\n\r\n在这个比冬天更肃杀的极端时候，我的阳光依然要挣扎着穿过高墙照亮你昏暗的牢房。\r\n\r\n在那荒茫美丽马勒戈壁，\r\n有一群草泥马，\r\n他们活泼又聪明，\r\n他们调皮又灵敏，\r\n他们自由自在生活在那草泥马戈壁，\r\n他们顽强克服艰苦环境。\r\n噢，卧槽的草泥马！\r\n噢，狂槽的草泥马！\r\n他们为了卧草不被吃掉打败了河蟹，\r\n河蟹从此消失草泥马戈壁。\r\n\r\n老百姓之所以相信什么深层政府、阴谋论之类的东西，是因为他们对真实政府有多缓慢低效一无所知或不相信。\r\n\r\n国家是为人而设立，但人不是为国家而生存。\r\n\r\n很多国家连他自己的人民都不关心，怎么会来关心我们（别有用心）？",
      "data": {
        "title": "复读",
        "date": "2025-01-08 22:08:03",
        "tags": [
          "随机说话"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "fu-du"
    },
    {
      "content": "在 [https://qoj.ac/submission/445313](https://qoj.ac/submission/445313) 中发现一种特殊加边删边中并查集可以启发式分裂。\n\n保证每条边只加/删一次，且所有加的边形成森林，维护连通块信息，强制在线。由于加边删边的特殊性，可以 $O(n\\log^2 n)$ 启发式合并分裂。\n\n记录路径压缩的并查集祖先，set 维护每个点的边和每个并查集里的点。加边是正常的启发式合并并查集信息。分裂时只要保证枚举的点数为两个新连通块较小的一个就可以得到和启发式合并相同的复杂度。具体的，同时维护两个新连通块，往较小的一边拓展一个点直到有一边无法增加。为了防止枚举到菊花使一边增加过多的点，类似当前弧优化一次枚举一条边。两边用队列维护当前的点和出边的指针。分裂时当前点的祖先可能在点数小的一边，但是不能枚举点数多的一边修改，所以把祖先理解为并查集的编号，点数小的部分给一个全新的编号。\n\n```cpp\nset<int> e[maxn],id[maxn<<1];\nint fa[maxn],idx;\nll del[maxn*3];\nstruct node{\n\tint u,fa;\n\tset<int>::iterator it;\n};\nvoid add(int u,int v){\n\te[u].insert(v),e[v].insert(u);\n\tint uu=fa[u],vv=fa[v];\n\tsum+=1ll*id[uu].size()*id[vv].size();\n\tif(id[uu].size()<id[vv].size())swap(u,v),swap(uu,vv);\n\tfor(int i:id[vv])fa[i]=uu,id[uu].insert(i);id[vv].clear();\n}\nvoid del(int u,int v){\n\te[u].erase(v),e[v].erase(u);\n\tvector<int> pos[2];\n\tqueue<node> que[2];\n\tpos[0].pb(u),pos[1].pb(v);\n\tif(e[u].size())que[0].push({u,0,e[u].begin()});\n\tif(e[v].size())que[1].push({v,0,e[v].begin()});\n\twhile(que[0].size()&&que[1].size()){\n\t\tint o=pos[1].size()<pos[0].size();\n\t\tauto[u,fa,it]=que[o].front();que[o].pop();\n\t\tint v=(*it);\n\t\tif(v!=fa){\n\t\t\tpos[o].pb(v);\n\t\t\tif(e[v].size())que[o].push({v,u,e[v].begin()});\n\t\t}\n\t\tit++;\n\t\tif(it==e[u].end())continue;\n\t\tif((*it)==fa)it++;\n\t\tif(it==e[u].end())continue;\n\t\tque[o].push({u,fa,it});\n\t}\n\tif(!que[0].size()&&(que[1].size()||pos[0].size()<pos[1].size())){\n\t\tswap(u,v),swap(pos[0],pos[1]);\n\t}\n\tdel[qq]+=1ll*pos[1].size()*(id[fa[u]].size()-pos[1].size());\n\t++idx;\n\tfor(int i:pos[1])id[fa[u]].erase(i),id[idx].insert(i),fa[i]=idx;\n}\n```\n\n例：[p11519](https://yhddd123.github.io/post/p11519-ti-jie/)。",
      "data": {
        "title": "并查集启发式分裂",
        "date": "2025-01-07 18:32:06",
        "tags": [
          "图论",
          "笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "bing-cha-ji-qi-fa-shi-fen-lie"
    },
    {
      "content": "[P11519](https://www.luogu.com.cn/problem/P11519)\r\n\r\n学习了这份[提交](https://qoj.ac/submission/445313)，记录一下。\r\n\r\n### 思路\r\n\r\n没有重复的加边，且所有边形成森林，所以答案等于至今为止所有的加边合并的连通块 $siz_u\\times siz_v$，减去时刻 $s-t$ 及以前所有的删边合并的连通块 $siz_u\\times siz_v$。要求强制在线维护连通块相关信息。\r\n\r\n由于加边删边的特殊性，可以 $O(n\\log^2 n)$ 启发式合并分裂。记录路径压缩的并查集祖先，set 维护每个点的边和每个并查集里的点。加边是正常的启发式合并并查集信息。分裂时只要保证枚举的点数为两个新连通块较小的一个就可以得到和启发式合并相同的复杂度。具体的，同时维护两个新连通块，往较小的一边拓展一个点直到有一边无法增加。为了防止枚举到菊花使一边增加过多的点，类似当前弧优化一次枚举一条边。两边用队列维护当前的点和出边的指针。分裂时当前连通块的祖先可能在点数小的一边，但是不能枚举点数多的一边修改，所以把祖先理解为并查集的编号，点数小的部分给一个全新的编号。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,q,op;ll ans,sum;\r\nset<int> e[maxn],id[maxn<<1];\r\nint fa[maxn],idx;\r\nll del[maxn*3];\r\nstruct node{\r\n\tint u,fa;\r\n\tset<int>::iterator it;\r\n};\r\nvoid work(){\r\n\top=read();n=read();q=read();idx=n;\r\n\tfor(int i=1;i<=n;i++)fa[i]=i,id[i].insert(i);\r\n\tfor(int qq=1;qq<=q;qq++){\r\n\t\tdel[qq]=del[qq-1];\r\n\t\tint opt=read();\r\n\t\tif(opt==1){\r\n\t\t\tll u=read(),v=read();\r\n\t\t\tif(op)u^=ans,v^=ans;\r\n\t\t\te[u].insert(v),e[v].insert(u);\r\n\t\t\tint uu=fa[u],vv=fa[v];\r\n\t\t\tsum+=1ll*id[uu].size()*id[vv].size();\r\n\t\t\tif(id[uu].size()<id[vv].size())swap(u,v),swap(uu,vv);\r\n\t\t\tfor(int i:id[vv])fa[i]=uu,id[uu].insert(i);id[vv].clear();\r\n\t\t}\r\n\t\tif(opt==2){\r\n\t\t\tll u=read(),v=read();\r\n\t\t\tif(op)u^=ans,v^=ans;\r\n\t\t\te[u].erase(v),e[v].erase(u);\r\n\t\t\tvector<int> pos[2];\r\n\t\t\tqueue<node> que[2];\r\n\t\t\tpos[0].pb(u),pos[1].pb(v);\r\n\t\t\tif(e[u].size())que[0].push({u,0,e[u].begin()});\r\n\t\t\tif(e[v].size())que[1].push({v,0,e[v].begin()});\r\n\t\t\twhile(que[0].size()&&que[1].size()){\r\n\t\t\t\tint o=pos[1].size()<pos[0].size();\r\n\t\t\t\tauto[u,fa,it]=que[o].front();que[o].pop();\r\n\t\t\t\tint v=(*it);\r\n\t\t\t\tif(v!=fa){\r\n\t\t\t\t\tpos[o].pb(v);\r\n\t\t\t\t\tif(e[v].size())que[o].push({v,u,e[v].begin()});\r\n\t\t\t\t}\r\n\t\t\t\tit++;\r\n\t\t\t\tif(it==e[u].end())continue;\r\n\t\t\t\tif((*it)==fa)it++;\r\n\t\t\t\tif(it==e[u].end())continue;\r\n\t\t\t\tque[o].push({u,fa,it});\r\n\t\t\t}\r\n\t\t\tif(!que[0].size()&&(que[1].size()||pos[0].size()<pos[1].size())){\r\n\t\t\t\tswap(u,v),swap(pos[0],pos[1]);\r\n\t\t\t}\r\n\t\t\tdel[qq]+=1ll*pos[1].size()*(id[fa[u]].size()-pos[1].size());\r\n\t\t\t++idx;\r\n\t\t\tfor(int i:pos[1])id[fa[u]].erase(i),id[idx].insert(i),fa[i]=idx;\r\n\t\t}\r\n\t\tif(opt==3){\r\n\t\t\tint t=read();\r\n\t\t\tif(op)t^=ans;\r\n\t\t\tprintf(\"%lld\\n\",ans=sum-del[qq-t]);\r\n\t\t}\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "P11519 题解",
        "date": "2025-01-07 17:23:15",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11519-ti-jie"
    },
    {
      "content": "迟到的 Goodbye2024\r\n\r\n说什么好呢，能说什么好呢？\r\n\r\n年末飞机不少事故。时隔 10 年，毛子再次击落一架民航。不如摘一篇 Goodbye2014。\r\n\r\n---\r\n\r\n《MH370写给2014年的一封信》\r\n\r\n2014年12月11日\r\n\r\n我是MH370。不要问我是从哪里给你写信的，有些事情如果需要知道，人们早晚会知道。你也不用担心我是来谴责你的。是的，你已经把我忘了，这我知道。“亲戚或余悲，他人亦已歌。”你并没有比别人做得更好，但也没有比别人做得更差。“尘归尘、土归土”，我们的命运均是如此。\r\n\r\n我没有早一点给你写信，是因为一直沉浸在自己的悲伤之中。事情过去这么久了，慢慢地，我已经可以玩味这场悲剧中的黑色幽默了。飞机出事故的概率大约是20万分之一，而出现多人死亡的空难事故的概率只有三百万分之一。\r\n\r\n我是一架波音777。在这种飞机二十多年的飞行历史上，只出现过9次事故，涉及的死亡人数不过3人而已。马航在40多年的历史里只出过两次重大事故，其中一次还是因为劫机。2013年，马航才刚刚获得世界旅游奖的“亚洲最佳航空公司”奖项。出事的那一天，我是从吉隆坡起飞的，那是一个尽管有点浮夸，但再怎么浮夸也仍然被大家视为二流角色的国家的首都。我要飞往北京，那是一个尽管在迅速强大起来，但总是低调得唯恐不够低调的国家的首都。\r\n\r\n再怎么说，“中大奖”的也不应该是我啊。\r\n\r\n我最近变得有点像哲学家，因为总是在思考灾难这件事。灾难是个哲学问题。它复杂、痛苦，而且无解，特别适合喜欢自虐的哲学家。我是个生活流的哲学家，只能从自己的生活体验来思考灾难问题。\r\n\r\n飞机失事，往往都是在起飞和降落的时候。我还记得第一次起飞的感觉：兴奋、紧张、害怕，觉得有点失控。后来的每一次起飞，对我来说都是一个神圣的仪式，总会有那么点小激动。但降落就是另外一回事了。每一次降落的时候，我已经是风尘仆仆、疲惫不堪。从高贵而洁净的天空回到嘈杂而混乱的地面，心中不免有些莫名的失落。我喜欢在空中平稳飞行的感觉，尽管我知道，油箱里的油总会用完的，飞得再高、飞得再远，总得要着陆。\r\n\r\n你现在就正处在降落的过程中。我这么说你一定会不服气，因为这一路走来有惊无险，逢凶之处，总能化吉。全球经济增长是低落了，但还算平稳；世界油价突然下跌，但也没有触发连锁反应。我的一个兄弟MH17，也是一架波音777，好端端地在乌克兰上空飞着，竟然被打了下来。我本来以为这下糟糕了，可能会引发一场不大也不小的冲突，结果居然又是不了了之。看来，今年唯一倒霉的就是我们马航。\r\n\r\n当然，我是有一点危言耸听，就算是我自己，也不是在降落过程中出事的，我是被欺骗、被劫持、被杀害的。具体的故事我不愿意讲，我的痛苦是属于我自己的，你们的好奇不足以理解我的悲伤。你们和我不一样，你们仍然是踌躇满志的。\r\n\r\n是的，我是被怨气和戾气所害，你并不是凶手，你甚至连凶手是谁都找不着，但是，这股怨气和戾气，难道就与你们的傲慢和偏见一点关系都没有？\r\n\r\n我看到，那个繁花似锦、人人快乐的镀金时代已经结束了——又或许，那个时代原本就是人们的一种幻觉。我看到了纽约世界贸易中心的熊熊黑烟，我看到了世界各地股票交易所的人们在金融危机爆发时的惊恐万状，我看到你的仪表盘上，油箱的指示已经快接近红线。我能听得到你久未修理的发动机发出沙哑的噪音，能预感到你航线前方即将出现空气湍流。　　但是，没有人把前面的风险当成一件值得担忧的事情。我看到，世界上规模最大的国家仍然自以为能够号令天下，其实它连自己国内的骚乱都束手无策。我看到，世界上增长速度最快的国家笼罩在一片雾霾之中，失去了曾经夺人心魄的高速经济增长，我不知道它该怎么应付层出不穷的问题。我看到，有的国家变得越是衰弱，就越是强硬；我也看到，有的国家越是停滞，就越是破罐子破摔。\r\n\r\n我看到，曾经得到的人们不愿意失去，哪怕他们曾经得到的都是特权；而没有得到的人们开始愤怒，尽管他们不知道该怎么去争取、以及该争取什么样的权利。我看到人们都很忙，假装在忙正经的事情：他们有眼睛，却看不到别人；有耳朵，却听不到别人；有心灵，却无法理解别人。\r\n\r\n在经济繁荣的时候，人们变得更加乐观自信，而在经济低迷的时候，人们就变得更加悲观和自私。历史已经在降落了，尽管人们尚未察觉——但我察觉到了，因为我就是受害者之一。想想我真是够窝囊的。有人在街上吵架，那不是我；有人在街上打架，那也不是我；有人在街上掏出了手枪，我只是一个路过的，子弹却打偏了，恰恰打中了我。\r\n\r\n我已经走了。街上愤怒的人们还在。冰山上已经有裂纹，断层线的地质活动比过去更加活跃，气候日益异常。从一个高歌凯进的繁荣时期，到一个长久低迷的萧条时代，发生变化的并不仅仅是经济增长率的高低，很多事情、很多意想不到的风险会等着你们。我祝你们的运气比我更好。\r\n\r\n抱歉占用你这么多的时间。我知道你很忙，人们都要为你送行，各种庆典排都排不开。但我的话又能讲给谁听呢？讲给2015年听吗？他只会比你更志得意满。好歹，你在觥筹交错的盛宴之余，或许会有一丝曲终人散的惆怅。毕竟，你很快也要离开这个世界了。\r\n\r\n匆匆草就，巾短意长。告别的时候到了，送你一首歌德的诗。不长。　　\r\n\r\n“一切的峰顶\r\n\r\n沉静\r\n\r\n一切的树尖　　\r\n\r\n全不见　　\r\n\r\n丝儿风影　　\r\n\r\n小鸟们在林间无声。　　\r\n\r\n等待吧：　　\r\n\r\n俄顷　　\r\n\r\n你也要安静。”　　\r\n\r\n——MH370",
      "data": {
        "title": "Goodbye2024",
        "date": "2025-01-01 13:24:15",
        "tags": [
          "随机说话"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "goodbye2024"
    },
    {
      "content": "[CF2048F](https://www.luogu.com.cn/problem/CF2048F)\r\n\r\n### 思路\r\n\r\n如果想操作 $b_p$，选可以选的最长区间不劣，那可以选的区间即为小根笛卡尔树上 $p$ 对应的区间。只有 $O(n)$ 个包含关系成树的可行操作区间，从下往上操作。可以设 $dp_{u,v}$ 表示操作完 $u$ 的子树，$u$ 对应的区间中 $a_u$ 的最大值最小为 $v$，最少做几次。注意到至多只会操作 $\\log V$ 次，交换 dp 的状态和答案，$dp_{u,i}$ 表示 $u$ 子树内做 $i$ 次 $a_u$ 的最大值最小为多少。暴力合并复杂度 $O(n\\log V)$。\r\n\r\n分步转移，$dp_{u,i}=\\min_{j+k=i}(\\max (dp_{ls,j},dp_{rs,k}))$。$dp_{u,i}$ 单调，min-max 卷积可以 $O(siz)$ 归并的合并。$dp_{u,i}=\\max(dp_{u,i},a_u)$，$dp_{u,i}=\\min(dp_{u,i},\\lceil \\frac{dp_{u,i-1}}{b_u}\\rceil)$。复杂度 $O(n\\log V)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn],b[maxn];\r\nint st[18][maxn];\r\nbool cmp(int u,int v){return b[u]<b[v];}\r\nint que(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn min(st[k][l],st[k][r-(1<<k)+1],cmp);\r\n}\r\nvector<int> dp[maxn];\r\nvector<int> merge(vector<int> u,vector<int> v){\r\n\tif(!u.size())return v;\r\n\tif(!v.size())return u;\r\n\tvector<int> res;res.pb(max(u[0],v[0]));\r\n\tint p=1,q=1;\r\n\twhile(p<u.size()&&q<v.size()){\r\n\t\tif(max(u[p],v[q-1])<max(u[p-1],v[q]))res.pb(max(u[p],v[q-1])),p++;\r\n\t\telse res.pb(max(u[p-1],v[q])),q++;\r\n\t}\r\n\twhile(p<u.size())res.pb(max(u[p],v.back())),p++;\r\n\twhile(q<v.size())res.pb(max(u.back(),v[q])),q++;\r\n\tres.resize(60);\r\n\treturn res;\r\n}\r\nint idx;\r\nint sovle(int l,int r){\r\n\tif(l>r)return 0;\r\n\tint nd=++idx;dp[nd].resize(60);\r\n\tif(l==r){\r\n\t\tfor(int i=0,v=a[l];i<60;i++)dp[nd][i]=v,v=(v+b[l]-1)/b[l];\r\n\t\treturn nd;\r\n\t}\r\n\tint mid=que(l,r),ls=sovle(l,mid-1),rs=sovle(mid+1,r);\r\n\tdp[nd]=merge(dp[ls],dp[rs]);\r\n\tfor(int i=0;i<60;i++)dp[nd][i]=max(dp[nd][i],a[mid]);\r\n\tfor(int i=1;i<60;i++)dp[nd][i]=min(dp[nd][i],(dp[nd][i-1]+b[mid]-1)/b[mid]);\r\n\treturn nd;\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<=n;i++)b[i]=read();\r\n\tfor(int i=1;i<=n;i++)st[0][i]=i;\r\n\tfor(int j=1;j<18;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++)st[j][i]=min(st[j-1][i],st[j-1][i+(1<<j-1)],cmp);\r\n\t}\r\n\tidx=0;sovle(1,n);\r\n\tint pos=60;for(int i=59;~i;i--)if(dp[1][i]==1)pos=i;\r\n\tprintf(\"%lld\\n\",pos);\r\n}\r\n```",
      "data": {
        "title": "CF2048F 题解",
        "date": "2024-12-26 16:19:44",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf2048f-ti-jie"
    },
    {
      "content": "![](https://yhddd123.github.io/post-images/1738238880731.jpg)\r\n\r\n### [无向连通图计数](https://www.luogu.com.cn/problem/P10982)\r\n\r\n总方案数 $g_n=2^{\\binom{n}{2}}$，减去不连通的方案数，枚举 $1$ 所在连通块的大小。\r\n\r\n$$f_n=g_n-\\sum_{i=1}^{n-1}\\binom{n-1}{i-1}f_ig_{n-i}$$\r\n\r\n加强版 [P4841](https://www.luogu.com.cn/problem/P4841)，分治 ntt 加速。\r\n\r\n```cpp\r\nint n;\r\nint f[maxn],g[maxn];\r\nint fac[maxn],inv[maxn];\r\nusing ploy::mul;\r\nvoid sovle(int l,int r){\r\n\tif(l==r){\r\n\t\tf[l]=(g[l]+mod-f[l]*fac[l-1]%mod)%mod;\r\n\t\treturn ;\r\n\t}\r\n\tint mid=l+r>>1;\r\n\tsovle(l,mid);\r\n\tvector<int> p(mid-l+1),q(r-l+1);\r\n\tfor(int i=l;i<=mid;i++)p[i-l]=f[i]*inv[i-1]%mod;\r\n\tfor(int i=1;i<=r-l;i++)q[i]=g[i]*inv[i]%mod;\r\n\tvector<int> ans=mul(p,q);\r\n\tfor(int i=mid+1;i<=r;i++)inc(f[i],ans[i-l]);\r\n\tsovle(mid+1,r);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;\r\n\tinv[n]=ksm(fac[n]);for(int i=n-1;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;\r\n\tfor(int i=1;i<=n;i++)g[i]=ksm(2,i*(i-1)/2);\r\n\tsovle(1,n);\r\n\tprintf(\"%lld\\n\",f[n]);\r\n}\r\n```\r\n\r\n#### [abc236h](https://www.luogu.com.cn/problem/AT_abc236_h)\r\n\r\n钦定若干组组内相等，方案为 $\\frac{m}{lcm (d_i)}$。状压，枚举包含 $mn_S$ 的子集乘方案数和容斥系数转移。\r\n\r\n对于 $\\binom{n}{2}$ 个不等关系钦定 $i$ 个相等相等的容斥系数为 $(-1)^i$。钦定组内相等的容斥系数为构成大小为 $siz$ 无向连通图的选边方案的容斥系数之和。\r\n\r\n$n$ 个点乱连的系数为 $\\sum_{i=0}^{\\frac{n(n-1)}{2}}\\binom{\\frac{n(n-1)}{2}}{i} (-1)^i=[\\frac{n(n-1)}{2}=0]=[n=1]$。减去不连通图的贡献，$n$ 个点的无向连通图的容斥系数和为 $f_n=[n=1]-\\sum_{i=1}^{n-1}C(n-1,i-1)f_i[n-i==1]$。\r\n\r\n#### 欧拉图计数\r\n\r\n要求偶度数且连通。偶度数图的数量 $g_n=2^{\\binom{n-1}{2}}$，$1,\\dotsb,n-1$ 乱连，$n$ 调整。连通的计数同无向连通图计数。\r\n\r\n### DAG计数\r\n\r\n钦定入度为 $0$ 的点数，分配容斥系数使得 $\\sum_{T\\subseteq S}f(T)=1$。\r\n\r\n$$f_n=\\sum_{i=1}^n (-1)^{i+1}\\binom{n}{i}2^{i(n-i)}f_{n-i}$$\r\n\r\n#### [P10221](https://www.luogu.com.cn/problem/P10221)\r\n\r\n设 $f_{i,s}$ 表示 $s$ 分为 $i$ 个非空段形成 DAG 的方案，$g_{i,s}$ 为 $s$ 分为 $i$ 个非空段段间没有边的方案数。容斥系数同 DAG 计数。可以做到 $O(3^nn^2)$，设 $F_S(x)=\\sum f_{i,S} x^i$，$F_S(x)=G_T(x)F_{S\\oplus T}(x)$，拉插之后算系数，复杂度 $O(3^nn)$。\r\n\r\n### perfur 序列\r\n\r\n$n$ 个点的数和长为 $n-2$ 值域 $[1,n]$ 的序列的双射。取出编号最小的叶子结点删去，将其父亲加 到序列末端。\r\n\r\nn 个点有标号无根树数量 $n^{n-2}$。确定度数之后 $\\frac{(n-2)!}{\\prod (d_u-1)!}$。已经形成 $k$ 个连通块后 $(\\sum s_i)^{k-2}\\prod s_i$。\r\n\r\n#### [P6596](https://www.luogu.com.cn/problem/P6596)\r\n\r\n设 $dp_{i,j}$ 为 $i$ 个点 $j$ 条割边的 $j+1$ 个边双的大小之积。$dp_{i,j}=\\sum_k \\binom{i}{k} dp_{i-k,j-1}dp_{k,0}$。$j+1$ 个点双没有顺序，再除掉 $\\frac{1}{(j+1)!}$。$dp_{i,0}$ 为大小为 $i$ 的无向连通图数量减去 $j>0$ 的 $dp_{i,j}$ 再乘 $i$。答案为 $\\sum dp_{n,i}n^{i-1}$。\r\n\r\n",
      "data": {
        "title": "图计数",
        "date": "2024-12-26 16:18:07",
        "tags": [
          "计数",
          "笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "tu-ji-shu"
    },
    {
      "content": "每日 数据结构。\r\n\r\n### 241201\r\n\r\n[P11364](https://www.luogu.com.cn/problem/P11364)\r\n\r\n考虑一个节点 $u$，和 $u$ 的叶子 $v$ 合并，贡献是若干个连续段对 $[l1,r1]$ 到 $[r1+1,r2]$ 的答案为 $dep_u$。由于 $[l1,r1]$ 内任选两点一定在 $u$ 子树中的某个点被贡献过，所以可以当成 $[l1,r2]$ 有 $dep_u$ 的贡献。对每个 $u$ 维护子树内连续段，启发式合并。因为每个贡献区间都是两个连续段合并起来，所以只有 $n-1$ 个长度 $>1$ 的区间和 $n$ 个单点。\r\n\r\n单点可以用 st 表维护区间最大值，对 $k=1$ 的询问贡献。对于有贡献的区间和询问区间，分三类考虑。有贡献的区间左端点小于询问区间左端点，按 $l$ 从小到大扫描线，贡献加在 $r$ 上，查询 $l\\le ql,r\\in [ql+qk-1,qr]$ 的答案。有贡献的区间右端点大于询问区间右端点同理。否则 $ql\\le l\\le r\\le qr$，按 $r-l+1$ 从大到小扫描线，贡献加在 $l$ 上，查询 $k\\ge qk,l\\in [ql,qr-qk+1]$ 的答案。\r\n\r\n优化启发式合并，只要对每个 $i$ 二分在 $lca(i,i+1)$ 的子树内包含 $i$ 的极长连通块，st 表求区间 dfn 最大最小的点，$O(n\\log n)-O(1)$ lca。\r\n\r\n### 241203\r\n\r\n[CF2041J](https://www.luogu.com.cn/problem/CF2041J)\r\n\r\n令 $c_i=b_i-1$，枚举最大值位置 $l$，令 $a'_i=\\min_{i\\le j\\le l} a_j$，要求 $c_i<a_i$。令 $p_i$ 为最大的 $c_{p_i}<a_i$，要求 $|\\{p_i\\le v\\}|\\le v$。维护 $v-\\sum [p_i\\le v]$ 的最小值和最小值个数，维护 $l$ 两侧的单调栈。合法的 $l$ 的 $\\min v-\\sum [cp_i\\le v]\\ge 0$，需要减 $1$ 的 $b_i$ 数量为 $v-\\sum [bp_i\\le v]=-1$ 的数量。\r\n\r\n### 241204\r\n\r\n[CF1500E](https://www.luogu.com.cn/problem/CF1500E)\r\n\r\n求 $[sum_i,sum_n-sunm_{n-i}]$ 的并的长度。关于 $\\frac{n}{2}$ 对称，两端无交，中间有交，二分。线段树维护区间个数，区间和，区间和的前缀和。\r\n\r\n### 241205\r\n\r\n[P7028](https://www.luogu.com.cn/problem/P7028)\r\n\r\n分块，维护块内的最大前缀和。形如 $v1_ix+v2_iy$，建 $(v2_i,v1_i)$ 的凸包，二分斜率 $\\frac{y}{x}$。\r\n\r\n### 241206\r\n\r\n[Q967](https://qoj.ac/problem/967)\r\n\r\n每个线段树节点开 set 维护 $y$ 行的白格对列答案的影响。删掉一个未被染黑的区间时，在被询问区间完全包含的线段树节点删掉 $y$ 的标记，否则下传。线段树维护答案为左右儿子的较大值和当前节点的最小标记的 min。对每个 $y$ set 维护连续段，保证每次删的区间无交。\r\n\r\n### 241208\r\n\r\n[CF1178G](https://www.luogu.com.cn/problem/CF1178G)\r\n\r\n分块，维护正负的最大最小值。块内建凸包，二分 $kb_i+a_ib_i$。\r\n\r\n### 241211\r\n\r\n[Q2064](https://qoj.ac/problem/2064)\r\n\r\n点分治 $u$，预处理 $x$ 最早 $f_x$ 到 $u$，要走边 $(u,v,t)$ 最晚 $g_{u,t}$ 从 $u$ 出发。数满足 $f_s\\le g_{ed,t},t\\le lim$ 的不同颜色数量，扫描线。\r\n\r\n### 241215\r\n\r\n[thupc2025 初赛 H](https://www.luogu.com.cn/problem/P11527)。\r\n\r\n对 $c$ 分解质因数，每个质数 $p$ 维护 $\\frac{i}{gcd(i,a_i)}$ 是 $p$ 倍数的位置，一个个取出来修改，只有 $n\\log n$ 次修改。\r\n\r\n类似 [弹飞绵羊](https://www.luogu.com.cn/problem/P3203)，分块，每个点维护第一次跳出块的位置。\r\n\r\n---\r\n\r\n开更。\r\n\r\n### 250207\r\n\r\n[P10061](https://www.luogu.com.cn/problem/P10061)\r\n\r\n> $n\\times n$ 的矩阵，$q$ 次询问。\r\n>\r\n> - 将一个正方形逆时针转 $90$ 度；\r\n> - 矩阵加一个值。\r\n>\r\n> $n,q\\le 3000$。\r\n\r\n神秘。\r\n\r\n根号重构。对询问分大小为 $B$ 的块，将矩阵划分为 $4B^2$ 个子矩阵并维护原来左上角现在的坐标和旋转的次数。每次询问遍历所有的块判断在不在操作范围内并打标记，重构时再放回去。复杂度 $O(qB^2+\\frac{q}{B}n^2)$。\r\n\r\n### 250208\r\n\r\n[P4800](https://www.luogu.com.cn/problem/P4800)\r\n\r\n> $n\\times m$ 的矩形，$q$ 次询问 $(a,b,x,y)$，每个点加 $\\max(a-b\\times \\max(|i-x|,|j-y|),0)$。最后输出矩形。\r\n>\r\n> $n\\times m\\le 2.5\\times 10^6,q\\le 2\\times 10^5$。\r\n\r\n一坨屎。\r\n\r\n每次枚举较短一边做矩阵加可以 $O(q\\sqrt{nm})$，当一维顶到两边的界时对另一维加等差数列。\r\n\r\n矩阵不断扩大时差分的位置在对角线或边界上，维护斜线和边界位置差分数组变化值的差分。\r\n\r\n### 250210\r\n\r\n[P8969](https://www.luogu.com.cn/problem/P8969)\r\n\r\n> 区间加，区间 popcount，单点查。\r\n\r\n做完一次 ```P``` 之后只有 $O(\\log V)$ 种本质不同数值。\r\n\r\n线段树维护区间是否有 ```P``` 操作，```P``` 之前加了多少，对于第一次 ```P``` 后等于 $i$ 的数现在是什么。\r\n\r\n### 250216\r\n\r\n[pjudge PR #15 B](https://pjudge.ac/contest/1914/problem/21889)\r\n\r\n> 树，每个节点上有一颗二叉搜索树。\r\n>\r\n> - 对路径上的点的 BST 插入一个 $x$。\r\n> - 单点查询在一个 BST 上查找 $x$ 时经过的权值和。\r\n\r\n离线。对于 $(x,t)$，贡献为比 $x$ 两侧的 $t$ 的前/后缀最小值位置上的 $y$。\r\n\r\n线段树合并，楼房重建线段树维护前/后缀最小值位置上的和。\r\n\r\n### 250218\r\n\r\n[P11369](https://www.luogu.com.cn/problem/P11369)\r\n\r\n> 有向图。\r\n>\r\n> - 将一条边打开关闭。\r\n> - 询问 $u,v$ 是否可达。\r\n>\r\n> $n\\le e\\times 10^4,m,q\\le 10^5$。\r\n\r\n时间分块，每 $B$ 个询问一起做，$2\\times B$ 个关键点。把非关键边的拿出来缩边双，求出关键点使用非关键边两两的连通性。bitset 优化 bfs。复杂度 $O(\\frac{q}{B}n\\frac{B}{w}+q\\frac{B^2}{w})$，乱冲。\r\n\r\n### 250220\r\n\r\n怎么两天一道了。\r\n\r\n> 给定 ${a_n},k$。计数区间 $[l,r]$ 满足 $\\text{mex} a_j+\\min a_j+k\\ge \\max a_j$。\r\n\r\n注意到 $\\text{mex}$ 和 $\\min$ 至少一个为 $0$。计数 $\\text{mex}+k\\ge \\max$ 加 $\\min+k\\ge max$ 减去 $k\\ge \\max$。\r\n\r\n$\\text{mex}$ 的部分。求出 [极小和极大 $\\text{mex}$ 区间](https://www.luogu.com.cn/problem/P9970)，即 $pl\\le i\\le l,r\\le j\\le pr$ 的区间 $[i,j]$ 的 $\\text{mex}$ 值相等。再二分出 $nl$ 使得 $\\text{mex}+k\\ge \\max_{nl\\le j\\le r}a_j$，和 $nr$ 使得 $\\text{mex}+k\\ge\\max_{l\\le j\\le nr}a_j$。对于 $nl\\le i\\le l,r\\le j\\le nr$ 的 $[i,j]$ 符合 $\\text{mex}$ 部分的限制。扫描线求矩阵并。\r\n\r\n### 240221\r\n\r\n[P9598](https://www.luogu.com.cn/problem/P9598)\r\n\r\n> $n$ 个点 $m$ 次加/删边操作。$q$ 次询问操作 $t$ 后 $[1,p]$ 和 $[p+1,n]$ 的导出子图的连通块数之和。\r\n>\r\n> $n,m,q\\le 10^5$。\r\n\r\n在 $[1,pl]$ 的图上线段树分治，到一个时间枚举在这个时间且 $p\\in [pl,pr]$ 的询问，直接加入小于当前时间且右端点属于 $[pl+1,p]$ 的边，询问，再删除这些边。\r\n\r\n所以分块，复杂度取决于右端点属于 $[pl+1,pr]$ 的边的数量和 $[pl,pr]$ 块数。设阈值 $B$，按右端点排序大概 $B$ 条边分成一块。可以保证右端点属于 $[pl+1,pr]$ 的边数 $<2\\times B$， $[pl,pr]$ 块数 $<2\\times \\frac{n}{B}$。\r\n\r\n对于每一块，都要对之前的边重新线段树分治一遍；对于每个询问，都要遍历块内之前的边。所有的加边删边操作都要可撤销并查集。复杂度 $O(\\frac{n}{B}n\\log^2 n+mB\\log n)$。取 $B=1000$ 跑的飞快。\r\n\r\n### 240224\r\n\r\n[Q8229](https://qoj.ac/contest/1515/problem/8229)\r\n\r\n>$n$ 个栈 $q$​ 次询问。\r\n>\r\n>- 对编号 $[l,r]$ 的栈 ```push``` $x$ 个 $y$。\r\n>- 对编号 $[l,r]$ 的栈 ```pop``` $x$ 次。\r\n>- 查询编号 $k$ 的栈从栈底开始 $[p,q]$ 的元素之和。\r\n>\r\n>$n,q\\le 10^5$。\r\n\r\n换维，扫描线，数据结构维护时间维。\r\n\r\n维护 $pre$ 个右括号和 $suf$ 个左括号合并。\r\n\r\n将询问差分为两个后缀。对于一个后缀，如果全部来自右儿子，递归右儿子；否则查右侧所有左括号的权值之和，与左侧一段的权值之和，类楼房重建，合并时记录左侧被合并掉的左括号权值是多少。\r\n\r\n将时间的一个前缀从线段树上取出，从右往左合并计算。",
      "data": {
        "title": "Everyday DS",
        "date": "2024-12-01 21:37:52",
        "tags": [
          "数据结构",
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "everyday-ds"
    },
    {
      "content": "241130\r\n\r\n### 241129\r\n\r\n感觉考前精神状态比 csps 好一点，但是反而抽象 oj 的抽象 rating 掉了贼多。弃疗了上周 ucup 改题。弃疗了刷 arc。训了一些纯正 cnoi 风味的 **。\r\n\r\nnoip 前摆烂搭了另一个 [博客](https://yhddd123.github.io/qwerty)，一个有意思的尝试。\r\n\r\n### 241130\r\n\r\n高三学长回来打 noip，唉。\r\n\r\n进场。T1 乱贪，写写写写写，过编就过大样例了，感觉数据还挺强，扔了。感觉头脑非常不清醒，发现 T2 sb，写写写写写，过了，扔了。不知道为啥不想拍。大概过了 1h。T3 看不懂，跳了，T4 感觉就很合胃口。喝水，喝喝喝喝喝，上厕所，不知道什么动词。感觉启发式合并找 $n$ 个贡献区间很容易，但是询问是求一个直角三角形的区间 max，会不了一点。不知道为啥我决定开始写，写写写写写，写完 $O(n\\log^2 n+nq)$，感觉头脑非常清醒。然后不知道为啥我就会了扫描线做询问，写写写写写。本地 $2.3$ 秒，不过之前我在这台电脑上打模拟赛时有本地 2s 等于 oj 1.3s 的逆天情况，根本不慌。不知道为啥极限数据不想造，二叉树不想造。还剩 1.5 h 做 T3，怎么说？不怎么说。喝水，喝喝喝喝喝，上厕所，不知道什么动词。被容斥干爆了，根本会不了一点。\r\n\r\n如果不挂分，$100+100+40+100$，是不是和 csps $100+100+100+40$ 是同分异构体。\r\n\r\n唉，OI。\r\n\r\n[T4 sol](https://yhddd123.github.io/post/p11364-ti-jie/)。",
      "data": {
        "title": "noip2024 游记",
        "date": "2024-12-01 20:26:52",
        "tags": [
          "游记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "noip2024-you-ji"
    },
    {
      "content": "[P11364](https://www.luogu.com.cn/problem/P11364)\r\n\r\n### 思路\r\n\r\n考虑一个节点 $u$，和 $u$ 的叶子 $v$ 合并，贡献是若干个连续段对 $[l1,r1]$ 到 $[r1+1,r2]$ 的答案为 $dep_u$。由于 $[l1,r1]$ 内任选两点一定在 $u$ 子树中的某个点被贡献过，所以可以当成 $[l1,r2]$ 有 $dep_u$ 的贡献。对每个 $u$ 维护子树内连续段，启发式合并。因为每个贡献区间都是两个连续段合并起来，所以只有 $n-1$ 个长度 $>1$ 的区间和 $n$ 个单点。\r\n\r\n单点可以用 st 表维护区间最大值，对 $k=1$ 的询问贡献。对于有贡献的区间和询问区间，分三类考虑。有贡献的区间左端点小于询问区间左端点，按 $l$ 从小到大扫描线，贡献加在 $r$ 上，查询 $l\\le ql,r\\in [ql+qk-1,qr]$ 的答案。有贡献的区间右端点大于询问区间右端点同理。否则 $ql\\le l\\le r\\le qr$，按 $r-l+1$ 从大到小扫描线，贡献加在 $l$ 上，查询 $k\\ge qk,l\\in [ql,qr-qk+1]$ 的答案。\r\n\r\n复杂度 $O(n\\log^2n)$，跑的飞快。\r\n\r\n```cpp\r\nint n,q;\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nint ll[maxn],rr[maxn],kk[maxn],ans[maxn];\r\nint dep[maxn];\r\nset<pii> s[maxn];\r\nstruct node{\r\n\tint l,r,x;\r\n}upd[maxn];\r\nvoid ins(int u,pii p){\r\n\tauto it=s[u].lower_bound(p);\r\n\tpii del1,del2;\r\n\tif(it!=s[u].end()){\r\n\t\tpii pp=(*it);\r\n\t\tif(p.se+1==pp.fi){\r\n\t\t\tupd[p.se]={p.fi,pp.se,dep[u]};\r\n\t\t\tdel1=pp;p.se=pp.se;\r\n\t\t}\r\n\t}\r\n\tif(it!=s[u].begin()){\r\n\t\tit--;pii pp=(*it);\r\n\t\tif(pp.se+1==p.fi){\r\n\t\t\tupd[pp.se]={pp.fi,p.se,dep[u]};\r\n\t\t\tdel2=pp;p.fi=pp.fi;\r\n\t\t}\r\n\t}\r\n\tif(del1.fi)s[u].erase(del1);\r\n\tif(del2.fi)s[u].erase(del2);\r\n\ts[u].insert(p);\r\n}\r\nvoid dfs(int u,int fa){\r\n\tdep[u]=dep[fa]+1;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);\r\n\t}\r\n\tins(u,{u,u});\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tif(s[u].size()<s[v].size())swap(s[u],s[v]);\r\n\t\tfor(pii p:s[v])ins(u,p);\r\n\t}\r\n}\r\n#define mid (l+r>>1)\r\n#define ls lc[nd]\r\n#define rs rc[nd]\r\nint rt[maxn],idx;\r\nint lc[maxn*100],rc[maxn*100],tree[maxn*100];\r\nvoid modif(int &nd,int l,int r,int p,int w){\r\n\tint lst=nd;nd=++idx;tree[nd]=max(tree[lst],w),ls=lc[lst],rs=rc[lst];\r\n\tif(l==r)return ;\r\n\tif(p<=mid)modif(ls,l,mid,p,w);\r\n\telse modif(rs,mid+1,r,p,w);\r\n}\r\nint query(int nd,int l,int r,int ql,int qr){\r\n\tif(!nd||ql>qr)return 0;\r\n\tif(l>=ql&&r<=qr)return tree[nd];\r\n\tif(qr<=mid)return query(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n\treturn max(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));\r\n}\r\nvector<int> id[maxn];\r\nint mx[20][maxn];\r\nint quemx(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn max(mx[k][l],mx[k][r-(1<<k)+1]);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t}\r\n\tq=read();\r\n\tfor(int i=1;i<=q;i++)ll[i]=read(),rr[i]=read(),kk[i]=read();\r\n\tdfs(1,0);\r\n\tfor(int i=1;i<=n;i++)mx[0][i]=dep[i];\r\n\tfor(int j=1;j<20;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++)mx[j][i]=max(mx[j-1][i],mx[j-1][i+(1<<j-1)]);\r\n\t}\r\n\tfor(int i=1;i<=q;i++)if(kk[i]==1)ans[i]=quemx(ll[i],rr[i]);\r\n\tfor(int i=1;i<n;i++)id[upd[i].l].pb(i);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\trt[i]=rt[i-1];\r\n\t\tfor(int j:id[i])modif(rt[i],1,n,upd[j].r,upd[j].x);\r\n\t}\r\n\tfor(int i=1;i<=q;i++){\r\n\t\tint l=ll[i],r=rr[i],k=kk[i];\r\n\t\tans[i]=max(ans[i],query(rt[l],1,n,l+k-1,n));\r\n\t}\r\n\twhile(idx)tree[idx]=lc[idx]=rc[idx]=0,idx--;\r\n\tfor(int i=1;i<=n;i++)rt[i]=0;\r\n\tfor(int i=1;i<=n;i++)id[i].clear();\r\n\tfor(int i=1;i<n;i++)id[upd[i].r].pb(i);\r\n\tfor(int i=n;i;i--){\r\n\t\trt[i]=rt[i+1];\r\n\t\tfor(int j:id[i])modif(rt[i],1,n,upd[j].l,upd[j].x);\r\n\t}\r\n\tfor(int i=1;i<=q;i++){\r\n\t\tint l=ll[i],r=rr[i],k=kk[i];\r\n\t\tans[i]=max(ans[i],query(rt[r],1,n,1,r-k+1));\r\n\t}\r\n\twhile(idx)tree[idx]=lc[idx]=rc[idx]=0,idx--;\r\n\tfor(int i=1;i<=n;i++)rt[i]=0;\r\n\tfor(int i=1;i<=n;i++)id[i].clear();\r\n\tfor(int i=1;i<n;i++)id[upd[i].r-upd[i].l+1].pb(i);\r\n\tfor(int i=n;i;i--){\r\n\t\trt[i]=rt[i+1];\r\n\t\tfor(int j:id[i])modif(rt[i],1,n,upd[j].l,upd[j].x);\r\n\t}\r\n\tfor(int i=1;i<=q;i++){\r\n\t\tint l=ll[i],r=rr[i],k=kk[i];\r\n\t\tans[i]=max(ans[i],query(rt[k],1,n,l,r-k+1));\r\n\t}\r\n\tfor(int i=1;i<=q;i++)printf(\"%lld\\n\",ans[i]);\r\n}\r\n```",
      "data": {
        "title": "P11364 题解",
        "date": "2024-12-01 20:05:35",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11364-ti-jie"
    },
    {
      "content": "## 杂项\r\n\r\n### qsy\r\n\r\n```cpp\r\n#include<bits/stdc++.h>\r\n#define int long long\r\n#define mod 998244353ll\r\n#define pii pair<int,int>\r\n#define fi first\r\n#define se second\r\n#define mems(x,y) memset(x,y,sizeof(x))\r\n#define pb push_back\r\n#define db double\r\nusing namespace std;\r\nconst int maxn=200010;\r\nconst int inf=1e18;\r\ninline int read(){\r\n\tint x=0,f=1;\r\n\tchar ch=getchar();\r\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\r\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch-48);ch=getchar();}\r\n\treturn x*f;\r\n}\r\nbool Mbe;\r\n\r\nint n;\r\nvoid work(){\r\n\tn=read();\r\n}\r\n\r\n// \\\r\n444\r\n\r\nbool Med;\r\nint T;\r\nsigned main(){\r\n//\tfreopen(\".in\",\"r\",stdin);\r\n//\tfreopen(\".out\",\"w\",stdout);\r\n\t\r\n//\tios::sync_with_stdio(0);\r\n//\tcin.tie(0);cout.tie(0);\r\n\t\r\n//\tcerr<<(&Mbe-&Med)/1048576.0<<\" MB\\n\";\r\n\t\r\n\tT=1;\r\n\twhile(T--)work();\r\n}\r\n```\r\n\r\n### fastio\r\n\r\n```cpp\r\nstatic char buf[1000000],*p1=buf,*p2=buf;\r\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++\r\ninline int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}return x*f;}\r\ninline void write(int x){static char buf[20];static int len=-1;if(x<0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len>=0)putchar(buf[len--]+48);}\r\n#define put() putchar(' ')\r\n#define endl puts(\"\")\r\n```\r\n\r\n## 字符串\r\n\r\n### kmp\r\n\r\n```cpp\r\nchar s[maxn],q[maxn];\r\nint n,m,nxt[maxn];\r\nint main(){\r\n\tscanf(\"%s%s\",s+1,q+1);n=strlen(s+1),m=strlen(q+1);\r\n\tfor(int i=2,j=0;i<=m;i++){\r\n\t\twhile(j&&q[i]!=q[j+1])j=nxt[j];\r\n\t\tif(q[i]==q[j+1])j++;\r\n\t\tnxt[i]=j;\r\n\t}\r\n\tfor(int i=1,j=0;i<=n;i++){\r\n\t\twhile(j&&s[i]!=q[j+1])j=nxt[j];\r\n\t\tif(s[i]==q[j+1])j++;\r\n\t\tif(j==m){\r\n\t\t\tprintf(\"%d\\n\",i-m+1);\r\n\t\t\tj=nxt[j];\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=m;i++)printf(\"%d \",nxt[i]);\r\n}\r\n```\r\n\r\n### manacher\r\n\r\n```cpp\r\nint n,ans;\r\nchar s[maxn],a[maxn<<1];\r\nint len[maxn<<1];\r\nvoid change(){\r\n\ta[0]='#';a[1]='#';\r\n\tfor(int i=1;i<=n;i++)a[i<<1]=s[i],a[i<<1|1]='#';\r\n\tn=n<<1|1;\r\n}\r\nvoid manacher(){\r\n\tint maxr=0,mid=0;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(i<maxr)len[i]=min(len[mid*2-i],len[mid]+mid-i);\r\n\t\telse len[i]=1;\r\n\t\twhile(a[i+len[i]]==a[i-len[i]])++len[i];\r\n\t\tif(len[i]+i>maxr){\r\n\t\t\tmaxr=len[i]+i;\r\n\t\t\tmid=i;\r\n\t\t}\r\n\t}\r\n}\r\nsigned main(){\r\n\tscanf(\"%s\",s+1);n=strlen(s+1);\r\n\tchange();manacher();\r\n\tfor(int i=1;i<=n;i++)ans=max(ans,len[i]);\r\n\tprintf(\"%d\",ans-1);\r\n}\r\n```\r\n\r\n### Z 函数\r\n\r\n```cpp\r\nint n,z[maxn];\r\nchar s[maxn];\r\nvoid work(){\r\n\tscanf(\"%s\",s);n=strlen(s);\r\n\tfor(int i=1,l=0,r=0;i<n;i++){\r\n\t\tz[i]=max(0ll,min(z[i-l],r-i+1));\r\n\t\twhile(i+z[i]<n&&s[z[i]]==s[i+z[i]])z[i]++;\r\n\t\tif(i+z[i]-1>r)l=i,r=i+z[i]-1;\r\n\t}\r\n\tfor(int i=0;i<n;i++)printf(\"%lld \",z[i]);\r\n}\r\n```\r\n\r\n### SAM\r\n\r\n```cpp\r\nint n,ans;\r\nchar s[maxn];\r\nint len[maxn],lnk[maxn];\r\nint a[maxn][26];\r\nint p=1,cur=1;\r\nint siz[maxn];\r\nvoid insert(int c){\r\n\tint nd=++cur;\r\n\tlen[nd]=len[p]+1;siz[nd]=1;\r\n\twhile(p&&!a[p][c])a[p][c]=nd,p=lnk[p];\r\n\tif(!p){lnk[p=nd]=1;return ;}\r\n\tint q=a[p][c];\r\n\tif(len[p]+1==len[q])lnk[nd]=q;\r\n\telse{\r\n\t\tint cl=++cur;\r\n\t\tlen[cl]=len[p]+1,lnk[cl]=lnk[q];\r\n\t\tmemcpy(a[cl],a[q],sizeof(a[q]));\r\n\t\tlnk[nd]=lnk[q]=cl;\r\n\t\twhile(p&&a[p][c]==q)a[p][c]=cl,p=lnk[p];\r\n\t}\r\n\tp=nd;\r\n}\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nvoid dfs(int u){\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tdfs(v),siz[u]+=siz[v];\r\n\t}\r\n}\r\nvoid work(){\r\n\tscanf(\"%s\",s+1),n=strlen(s+1);\r\n\tfor(int i=1;i<=n;i++)insert(s[i]-'a');\r\n\tfor(int i=2;i<=cur;i++)add(lnk[i],i);\r\n\tdfs(1);\r\n\tfor(int i=2;i<=cur;i++)if(siz[i]>1)ans=max(ans,siz[i]*len[i]);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### 带通配符字符串匹配\r\n\r\nntt 部分略。要求 $n$ 不能过大超过 $mod$，否则使用 fft。\r\n\r\n```cpp\r\nint n,m;\r\nchar s[maxn],t[maxn];\r\nint f[maxn],g[maxn],res[maxn];\r\nvector<int> ans;\r\nvoid work(){\r\n\tm=read();n=read();\r\n\tscanf(\"%s%s\",t,s);\r\n\treverse(t,t+m);\r\n\tint lim=1;while(lim<n)lim<<=1;\r\n\tfor(int i=0;i<lim;i++)to[i]=(to[i>>1]>>1)|((i&1)?lim>>1:0);\r\n\tfor(int i=0;i<m;i++)if(t[i]!='*')f[i]=(t[i]-'a')*(t[i]-'a');\r\n\tfor(int i=0;i<n;i++)if(s[i]!='*')g[i]=1;\r\n\tntt(f,lim,1),ntt(g,lim,1);\r\n\tfor(int i=0;i<lim;i++)res[i]=f[i]*g[i]%mod,f[i]=g[i]=0;\r\n\tfor(int i=0;i<m;i++)if(t[i]!='*')f[i]=t[i]-'a';\r\n\tfor(int i=0;i<n;i++)if(s[i]!='*')g[i]=s[i]-'a';\r\n\tntt(f,lim,1),ntt(g,lim,1);\r\n\tfor(int i=0;i<lim;i++)(res[i]+=mod-2*f[i]*g[i]%mod)%=mod,f[i]=g[i]=0;\r\n\tfor(int i=0;i<m;i++)if(t[i]!='*')f[i]=1;\r\n\tfor(int i=0;i<n;i++)if(s[i]!='*')g[i]=(s[i]-'a')*(s[i]-'a');\r\n\tntt(f,lim,1),ntt(g,lim,1);\r\n\tfor(int i=0;i<lim;i++)(res[i]+=f[i]*g[i])%=mod,f[i]=g[i]=0;\r\n\tntt(res,lim,-1);\r\n\tfor(int i=m-1;i<n;i++)if(!res[i])ans.pb(i-m+2);\r\n\tprintf(\"%lld\\n\",(int)ans.size());\r\n\tfor(int i:ans)printf(\"%lld \",i);\r\n}\r\n```\r\n\r\n## 图论\r\n\r\n### 边双\r\n\r\n```cpp\r\nint n,m;\r\nint head[maxn],tot=1;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nint dfn[maxn],lw[maxn],idx;\r\nint st[maxn],tp;\r\nvector<int> g[maxn];\r\nint num;\r\nbool vis[maxn];\r\nvoid tar(int u,int fl){\r\n\tdfn[u]=lw[u]=++idx;st[++tp]=u;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(i==(fl^1))continue;\r\n\t\tif(!dfn[v]){\r\n\t\t\ttar(v,i);\r\n\t\t\tlw[u]=min(lw[u],lw[v]);\r\n\t\t}\r\n\t\telse lw[u]=min(lw[u],dfn[v]);\r\n\t}\r\n\tif(lw[u]==dfn[u]){\r\n\t\t++num;\r\n\t\tg[num].push_back(st[tp]);\r\n\t\twhile(st[tp--]!=u){\r\n\t\t\tg[num].push_back(st[tp]);\r\n\t\t}\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(!dfn[i])tar(i,0);\r\n\tprintf(\"%lld\\n\",num);\r\n\tfor(int i=1;i<=num;i++){\r\n\t\tprintf(\"%lld \",g[i].size());\r\n\t\tfor(int j:g[i])printf(\"%lld \",j);\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n```\r\n\r\n### 点双\r\n\r\n```cpp\r\nint n,m,num;\r\nvector<int> e[maxn],g[maxn];\r\nint dfn[maxn],idx,lw[maxn];\r\nint st[maxn],tp;\r\nvoid tar(int u){\r\n\tdfn[u]=lw[u]=++idx;st[++tp]=u;\r\n\tfor(int v:e[u]){\r\n\t\tif(!dfn[v]){\r\n\t\t\ttar(v);\r\n\t\t\tlw[u]=min(lw[u],lw[v]);\r\n\t\t\tif(lw[v]>=dfn[u]){\r\n\t\t\t\tg[++num].push_back(st[tp]);\r\n\t\t\t\twhile(st[tp--]!=v)g[num].push_back(st[tp]);\r\n\t\t\t\tg[num].push_back(u);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse lw[u]=min(lw[u],dfn[v]);\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\te[u].push_back(v),e[v].push_back(u);\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(!dfn[i]){\r\n\t\tint lst=idx;tar(i);\r\n\t\tif(idx==lst+1)g[++num].push_back(i);\r\n\t}\r\n\tprintf(\"%lld\\n\",num);\r\n\tfor(int i=1;i<=num;i++){\r\n\t\tprintf(\"%lld \",(int)g[i].size());\r\n\t\tfor(int j:g[i])printf(\"%lld \",j);printf(\"\\n\");\r\n\t}\r\n}\r\n```\r\n\r\n### 无向图四元环计数\r\n\r\n```cpp\r\nint n,m;\r\nint d[maxn],cnt[maxn],ans;\r\nvector<int> e[maxn],g[maxn];\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\te[u].push_back(v),e[v].push_back(u);\r\n\t\td[u]++,d[v]++;\r\n\t}\r\n\tfor(int u=1;u<=n;u++){\r\n\t\tfor(int v:e[u])if(d[u]>d[v]||(d[u]==d[v]&&u>v))g[u].push_back(v);\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j:g[i]){\r\n\t\t\tfor(int k:e[j])if(d[i]>d[k]||(d[i]==d[k]&&i>k))ans+=cnt[k]++;\r\n\t\t}\r\n\t\tfor(int j:g[i])for(int k:e[j])cnt[k]=0;\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n## 数据结构\r\n\r\n### 李超线段树\r\n\r\n```cpp\r\nstruct line{\r\n\tdb k,b;\r\n}p[maxn];\r\ndb calc(int u,int x){return 1.0*(x*p[u].k+p[u].b);}\r\nint tree[maxn<<1];\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\n#define mid (l+r>>1)\r\nvoid upd(int nd,int l,int r,int id){\r\n\tif(l==r){\r\n\t\tif(calc(id,l)-calc(tree[nd],l)>eps)tree[nd]=id;\r\n\t\treturn ;\r\n\t}\r\n\tif(calc(id,mid)-calc(tree[nd],mid)>eps)swap(tree[nd],id);\r\n\tif(calc(id,l)-calc(tree[nd],l)>eps)upd(ls,l,mid,id);\r\n\telse upd(rs,mid+1,r,id);\r\n}\r\nvoid updata(int nd,int l,int r,int ql,int qr,int id){\r\n\tif(l>=ql&&r<=qr){\r\n\t\tupd(nd,l,r,id);\r\n\t\treturn ;\r\n\t}\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,id);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,id);\r\n}\r\nint query(int nd,int l,int r,int p){\r\n\tif(l==r)return tree[nd];\r\n\tint res;\r\n\tif(p<=mid)res=query(ls,l,mid,p);\r\n\telse res=query(rs,mid+1,r,p);\r\n\tif(calc(tree[nd],p)-calc(res,p)>eps)return tree[nd];\r\n\tif(calc(tree[nd],p)-calc(res,p)<-eps)return res;\r\n\treturn min(tree[nd],res);\r\n}\r\n```\r\n\r\n### fhq treap\r\n\r\n```cpp\r\nstruct fhq{\r\n\tint w[maxn],ls[maxn],rs[maxn],idx,rt;\r\n\tint siz[maxn],sz[maxn];\r\n\tvoid up(int u){\r\n\t\tsiz[u]=siz[ls[u]]+siz[rs[u]]+sz[u];\r\n\t}\r\n\tint merge(int u,int v){\r\n\t\tif(!u||!v)return u|v;\r\n\t\tif(w[u]<w[v]){\r\n\t\t\trs[u]=merge(rs[u],v);\r\n\t\t\tup(u);\r\n\t\t\treturn u;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tls[v]=merge(u,ls[v]);\r\n\t\t\tup(v);\r\n\t\t\treturn v;\r\n\t\t}\r\n\t}\r\n\tpii split(int u,int k){\r\n\t\tif(!u)return {0,0};\r\n\t\tif(siz[ls[u]]+sz[u]>k){\r\n\t\t\tpii t=split(ls[u],k);\r\n\t\t\tls[u]=t.se;\r\n\t\t\tup(u);\r\n\t\t\treturn {t.fi,u};\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpii t=split(rs[u],k-siz[ls[u]]-sz[u]);\r\n\t\t\trs[u]=t.fi;\r\n\t\t\tup(u);\r\n\t\t\treturn {u,t.se};\r\n\t\t}\r\n\t}\r\n\tint newnode(int s,int v){\r\n\t\tw[++idx]=rnd();siz[idx]=sz[idx]=s,val[idx]=num[idx]=v;\r\n\t\treturn idx;\r\n\t}\r\n}t;\r\n```\r\n\r\n### 线段树分裂\r\n\r\n```cpp\r\nint rt[maxn],cnt;\r\n#define mid (l+r>>1)\r\n#define ls lc[nd]\r\n#define rs rc[nd]\r\nll tree[maxn<<5];\r\nint lc[maxn<<5],rc[maxn<<5],idx;\r\nint st[maxn<<5],tp;\r\nint newnode(){\r\n\tif(tp)return st[tp--];\r\n\treturn ++idx;\r\n}\r\nvoid clr(int nd){\r\n\ttree[nd]=0,ls=rs=0;\r\n\tst[++tp]=nd;\r\n}\r\nvoid updata(int &nd,int l,int r,int p,int w){\r\n\tif(!nd)nd=newnode();\r\n\ttree[nd]+=w;\r\n\tif(l==r)return ;\r\n\tif(p<=mid)updata(ls,l,mid,p,w);\r\n\telse updata(rs,mid+1,r,p,w);\r\n\ttree[nd]=tree[ls]+tree[rs];\r\n}\r\nll query(int nd,int l,int r,int ql,int qr){\r\n\tif(!nd||ql>qr)return 0;\r\n\tif(l>=ql&&r<=qr)return tree[nd];\r\n\tif(qr<=mid)return query(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n\treturn query(ls,l,mid,ql,qr)+query(rs,mid+1,r,ql,qr);\r\n}\r\nint fdkth(int nd,int l,int r,ll k){\r\n\tif(tree[nd]<k)return -1;\r\n\tif(l==r)return l;\r\n\tif(tree[ls]>=k)return fdkth(ls,l,mid,k);\r\n\treturn fdkth(rs,mid+1,r,k-tree[ls]);\r\n}\r\nint merge(int u,int v,int l,int r){\r\n\tif(!u||!v)return u|v;\r\n\tif(l==r){tree[u]+=tree[v];clr(v);return u;}\r\n\tlc[u]=merge(lc[u],lc[v],l,mid);\r\n\trc[u]=merge(rc[u],rc[v],mid+1,r);\r\n\ttree[u]=tree[lc[u]]+tree[rc[u]];clr(v);\r\n\treturn u;\r\n}\r\nint split(int nd,int l,int r,ll k){\r\n\tif(!nd)return 0;\r\n\tint u=newnode();\r\n\tif(k>tree[ls])rc[u]=split(rs,mid+1,r,k-tree[ls]);\r\n\telse rc[u]=rs,rs=0;\r\n\tif(k<tree[ls])lc[u]=split(ls,l,mid,k);\r\n\ttree[nd]=tree[ls]+tree[rs],tree[u]=tree[lc[u]]+tree[rc[u]];\r\n\treturn u;\r\n}\r\n```\r\n\r\n### 手写 bitset\r\n\r\n```cpp\r\n#define ull unsigned long long\r\null pw[65];\r\nstruct bs{\r\n\tvector<ull> a;\r\n\tint len,n;\r\n\tvoid init(int _n){\r\n\t\tn=_n,len=(n+63)/64;a.resize(len+1,0);\r\n\t}\r\n\tvoid set0(int x){a[x>>6]&=~pw[x&63];}\r\n\tvoid set1(int x){a[x>>6]|=pw[x&63];}\r\n\tbool operator[](int x){return (a[x>>6]>>(x&63))&1;}\r\n\tbs operator|(const bs&b)const{\r\n\t\tbs c;c.init(max(n,b.n));\r\n\t\tfor(int i=0;i<c.len;i++)c.a[i]=a[i]|b.a[i];\r\n\t\treturn c;\r\n\t}\r\n\tbs operator&(const bs&b)const{\r\n\t\tbs c;c.init(min(n,b.n));\r\n\t\tfor(int i=0;i<c.len;i++)c.a[i]=a[i]&b.a[i];\r\n\t\treturn c;\r\n\t}\r\n\tvoid operator|=(const bs&b){\r\n\t\tfor(int i=0;i<max(len,b.len);i++)a[i]|=b.a[i];\r\n\t}\r\n\tvoid operator&=(const bs&b){\r\n\t\tfor(int i=0;i<min(len,b.len);i++)a[i]&=b.a[i];\r\n\t}\r\n\tbs operator<<(int x)const{\r\n\t\tbs res;res.init(n);\r\n\t\tint y=x>>6,z=x&63;\r\n\t\tull lst=0;\r\n\t\tfor(int i=0;i+y<res.len;i++){\r\n\t\t\tres.a[i+y]=lst|(a[i]<<z);\r\n\t\t\tif(z)lst=a[i]>>(64ll-z);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```\r\n\r\n### 哈希表\r\n\r\n```cpp\r\nstruct hsh_table{\r\n\tint head[maxn],tot;\r\n\tstruct nd{\r\n\t\tint nxt;\r\n\t\tull key;\r\n\t\tint val;\r\n\t}e[maxn];\r\n\tint hsh(ull u){return u%maxn;}\r\n\tbool find(ull key){\r\n\t\tint u=hsh(key);\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tif(e[i].key==key)return 1;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\tint &operator[](ull key){\r\n\t\tint u=hsh(key);\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tif(e[i].key==key)return e[i].val;\r\n\t\t}\r\n\t\te[++tot]={head[u],key,0};head[u]=tot;\r\n\t\treturn e[tot].val;\r\n\t}\r\n\tvoid clear(){\r\n\t\ttot=0;\r\n\t\tfor(int i=0;i<maxn;i++)head[i]=0;\r\n\t}\r\n}mp;\r\n```\r\n## 数学 \r\n\r\n### 拉格朗日插值\r\n\r\n```cpp\r\nvoid work(){\r\n\tn=read();k=read();\r\n\tfor(int i=1;i<=n;i++)x[i]=read(),y[i]=read();\r\n\t// for(int i=1;i<=n;i++){\r\n\t\t// int mul=y[i];\r\n\t\t// for(int j=1;j<=n;j++)if(i!=j){\r\n\t\t\t// mul=mul*(k-x[j]+mod)%mod*ksm(x[i]-x[j]+mod)%mod;\r\n\t\t// }\r\n\t\t// (ans+=mul)%=mod;\r\n\t// }\r\n    int g=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tg=g*(k-x[i]+mod)%mod;\r\n\t\tt[i]=y[i];for(int j=1;j<i;j++)t[i]=t[i]*ksm(x[i]-x[j]+mod)%mod;\r\n\t\tfor(int j=1;j<i;j++)t[j]=t[j]*ksm(x[j]-x[i]+mod)%mod;\r\n\t}\r\n\t\r\n\t// pre[0]=x;for(int i=1;i<=n;i++)pre[i]=pre[i-1]*(x-i)%mod;\r\n\t// suf[n]=x-n;for(int i=n-1;~i;i--)suf[i]=suf[i+1]*(x-i)%mod;\r\n\t// int val=0;\r\n\t// for(int i=0;i<=n;i++){\r\n\t\t// (val+=y[i]*(i?pre[i-1]:1)%mod*(i<n?suf[i+1]:1)*inv[i]%mod*inv[n-i]%mod*(((n-i)&1)?mod-1:1))%=mod;\r\n\t// }\r\n\t\r\n\tfor(int i=1;i<=n;i++)(ans+=t[i]*ksm(k-x[i]+mod))%=mod;ans=ans*g%mod;\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### 矩阵求逆\r\n\r\n```cpp\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=n;j++)a[i][j]=read();a[i][i+n]=1;\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(!a[i][i]){\r\n\t\t\tfor(int j=i+1;j<=n;j++)if(a[j][i]){\r\n\t\t\t\tswap(a[i],a[j]);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!a[i][i]){puts(\"No Solution\");return ;}\r\n\t\tint inv=ksm(a[i][i]);\r\n\t\tfor(int j=1;j<=n;j++)if(i!=j){\r\n\t\t\tint d=a[j][i]*inv%mod;\r\n\t\t\tfor(int k=i;k<=(n<<1);k++)(a[j][k]+=mod-a[i][k]*d%mod)%=mod;\r\n\t\t}\r\n\t\tfor(int j=i;j<=(n<<1);j++)a[i][j]=a[i][j]*inv%mod;\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=n+1;j<=(n<<1);j++)printf(\"%lld \",a[i][j]);puts(\"\");\r\n\t}\r\n}\r\n```\r\n\r\n### [快速离散对数](https://yhddd123.github.io/post/p11175-ti-jie/)\r\n\r\n```cpp\r\nint mod,g,n,q;\r\nint B,bas,h0;\r\nstruct hsh_table{\r\n}mp;\r\nint bsgs(int v){\r\n\tint mul=v;\r\n\tfor(int i=0;i<=mod/B;i++){\r\n\t\tif(mp.find(mul))return i*B+mp[mul];\r\n\t\tmul=1ll*mul*bas%mod;\r\n\t}\r\n}\r\n/*\r\nmod=ba+c\r\nlog(a)=log(-c)-log(b)=log(mod-1)+log(c)-log(b)\r\nlog(a)=log(a-c)-log(b+1)\r\nmin(c,a-c)<=a/2\r\n*/\r\nint h[maxn];\r\nint sovle(int a){\r\n\tint b=mod/a,c=mod%a;\r\n\tif(a<=n)return h[a];\r\n\tif(c<a-c)return inc(inc(h0,sovle(c)),(mod-1-h[b]));\r\n\telse return inc(sovle(a-c),mod-1-h[b+1]);\r\n}\r\nbool vis[maxn];\r\nint pre[maxn],cnt;\r\nvoid work(){\r\n\tmod=read();g=read();n=sqrt(mod)+1;B=sqrt(1ll*mod*n/log2(n));\r\n\t// cout<<n<<\" \"<<B<<\"\\n\";\r\n\tint mul=1;for(int i=0;i<B;i++){\r\n\t\tmp[mul]=i;\r\n\t\tmul=1ll*mul*g%mod;\r\n\t}\r\n\tbas=ksm(ksm(g,B));h0=bsgs(mod-1);h[1]=0;\r\n\tfor(int i=2;i<=n;i++){\r\n\t\tif(!vis[i]){\r\n\t\t\th[i]=bsgs(i);\r\n\t\t\tpre[++cnt]=i;\r\n\t\t}\r\n\t\tfor(int j=1;j<=cnt&&1ll*i*pre[j]<=n;j++){\r\n\t\t\tvis[i*pre[j]]=0;\r\n\t\t\th[i*pre[j]]=(h[i]+h[pre[j]])%(mod-1);\r\n\t\t\tif(i%pre[j]==0)break;\r\n\t\t}\r\n\t}\r\n\tq=read();\r\n\twhile(q--){\r\n\t\tint x=read();\r\n\t\tprintf(\"%lld\\n\",sovle(x));\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "模板",
        "date": "2024-11-29 21:50:55",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mo-ban"
    },
    {
      "content": "[P10644](https://www.luogu.com.cn/problem/P10644)\r\n\r\n[Public NOIP Round #8 D. 矩阵](https://pjudge.ac/contest/1847/problem/21864)\r\n\r\n大量证明缺失，只有构造方法。参考 [std](https://github.com/nordicolympiad/nordic-olympiad-2022/blob/main/powergrid/submissions/accepted/nils.cpp)。\r\n\r\n### 思路\r\n\r\n令 $f_i=\\sum_{j=1}^m a_{i,j}$，$g_j=\\sum_{i=1}^n a_{i,j}$。当 $c'_{i,j}=f_i-g_j$ 时认为 $c'_{i,j}$ 的符号是正确的。记 $p1$ 为一个不全相同的行，$p2$ 为一个不全相同的列。\r\n\r\n如果能构造出合法的 $\\sum f_i=\\sum g_j$，可以同 [arc135d](https://www.luogu.com.cn/problem/AT_arc135_d) 的方法，取出同符号的 $f_i,g_j$ 消掉绝对值较小的，再取出符号相反的 $f_i,f_j$ 或 $g_i,g_j$ 消掉绝对值较小的。\r\n\r\n如果存在 $p1,p2$。找到一个 $c_{p1,p2}\\neq c_{p1,p3}$，枚举 $c'_{p1,p2}$ 和 $c'_{p1,p3}$ 的符号，令 $f_{p1}=0,g_{p2}=c'_{p1,p2},g_{p3}=c'_{p1,p3}$，带进去解 $f_i,g_j$ ，有唯一解。然后调整，令 $f_{p1}$ 初始为 $\\frac{\\sum f_i-\\sum g_j}{n-m}$ 使 $\\sum f_i=\\sum g_j$。\r\n\r\n如果不存在 $p1$ 和 $p2$，即所有 $c_{i,j}$ 相等。如果 $n$ 为偶数，构造 $g_j=0$，前 $\\frac{n}{2}$ 个 $f_i$ 为 $c_{1,1}$，其他为 $-c_{1,1}$。否则 $n$ 为奇数，令 $g_j$ 全为 $x$，有 $n1$ 个 $f_i$ 为 $x+c_{1,1}$，$n2=n-n1$ 个为 $x-c_{1,1}$，有 $c_{1,1}=\\frac{(m-n)x}{n1-n2}$。$n1\\neq n2$，枚举 $n1$ 求 $x$。$m$ 为奇偶也同理。\r\n\r\n否则 $p1,p2$ 只有一个有值，反转 $n,m$ 使 $p1$ 有值。因为每列的 $c_{i,j}$ 都相等，构造第一行复制 $n$ 次。所以有 $n\\times f_1=\\sum f_i=\\sum g_j$，$g_j=f_1-c'_{i,j}$，$\\sum g_j=m\\times f_1-\\sum c'_{1,j}$。所以 $(n-m)\\times f_1=-\\sum c'_{1,j}$。设 $dp_{i,s}$ 表示前 $i$ 个 $c'_{i,j}$ 的和为 $s$ 是否可行。当 $n\\neq m$ 时要求 $s\\bmod (n-m)=0$，$O(n^2)$ dp 取模后的 $s$。$n=m$ 时要求$\\sum c'_{i,j}=0$，bitset $O(\\frac{n^3}{w})$ 加速。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nint a[maxn][maxn],c[maxn][maxn],b[maxn][maxn];\r\nint f[maxn],g[maxn];\r\nvoid get(){\r\n\tvector<int> f1,f2,g1,g2;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(f[i]<0)f1.pb(i);\r\n\t\tif(f[i]>0)f2.pb(i);\r\n\t}\r\n\tfor(int j=1;j<=m;j++){\r\n\t\tif(g[j]<0)g1.pb(j);\r\n\t\tif(g[j]>0)g2.pb(j);\r\n\t}\r\n\twhile(f1.size()&&g1.size()){\r\n\t\tint u=f1.back(),v=g1.back();f1.pop_back(),g1.pop_back();\r\n\t\tint d=min(abs(f[u]),abs(g[v]));\r\n\t\ta[u][v]-=d;f[u]+=d,g[v]+=d;\r\n\t\tif(f[u])f1.pb(u);\r\n\t\tif(g[v])g1.pb(v);\r\n\t}\r\n\twhile(f2.size()&&g2.size()){\r\n\t\tint u=f2.back(),v=g2.back();f2.pop_back(),g2.pop_back();\r\n\t\tint d=min(abs(f[u]),abs(g[v]));\r\n\t\ta[u][v]+=d;f[u]-=d,g[v]-=d;\r\n\t\tif(f[u])f2.pb(u);\r\n\t\tif(g[v])g2.pb(v);\r\n\t}\r\n\twhile(f1.size()&&f2.size()){\r\n\t\tint u=f1.back(),v=f2.back();f1.pop_back(),f2.pop_back();\r\n\t\tint d=min(abs(f[u]),abs(f[v]));\r\n\t\ta[u][1]-=d,a[v][1]+=d;f[u]+=d,f[v]-=d;\r\n\t\tif(f[u])f1.pb(u);\r\n\t\tif(f[v])f2.pb(v);\r\n\t}\r\n\twhile(g1.size()&&g2.size()){\r\n\t\tint u=g1.back(),v=g2.back();g1.pop_back(),g2.pop_back();\r\n\t\tint d=min(abs(g[u]),abs(g[v]));a[1][u]-=d,a[1][v]+=d;\r\n\t\tg[u]+=d,g[v]-=d;\r\n\t\tif(g[u])g1.pb(u);\r\n\t\tif(g[v])g2.pb(v);\r\n\t}\r\n}\r\nvoid check(){\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=m;j++)printf(\"%lld \",a[i][j]);puts(\"\");\r\n\t}\r\n\tfor(int i=1;i<=n;i++)f[i]=0;\r\n\tfor(int j=1;j<=m;j++)g[j]=0;\r\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)f[i]+=a[i][j],g[j]+=a[i][j];\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=m;j++)if(b[i][j]!=abs(g[j]-f[i]))assert(0);\r\n\t}\r\n}\r\nint p1,p2,p3;\r\nbool work_dif(int v1,int v2){\r\n\tf[p1]=0,g[p2]=v1,g[p3]=v2;\r\n\tfor(int i=1;i<=n;i++)if(i!=p1){\r\n\t\tif(abs(v1+c[i][p2]-v2)==c[i][p3]){f[i]=v1+c[i][p2];continue;}\r\n\t\tif(abs(v1-c[i][p2]-v2)==c[i][p3]){f[i]=v1-c[i][p2];continue;}\r\n\t\treturn 0;\r\n\t}\r\n\tfor(int j=1;j<=m;j++)if(j!=p2&&j!=p3){\r\n\t\tint v=f[1]+c[1][j],fl=1;\r\n\t\tfor(int i=1;i<=n;i++)fl&=abs(v-f[i])==c[i][j];\r\n\t\tif(fl){g[j]=v;continue;}\r\n\t\tv=f[1]-c[1][j],fl=1;\r\n\t\tfor(int i=1;i<=n;i++)fl&=abs(v-f[i])==c[i][j];\r\n\t\tif(fl){g[j]=v;continue;}\r\n\t\treturn 0;\r\n\t}\r\n\tint sum=0;\r\n\tfor(int i=1;i<=n;i++)sum+=f[i];\r\n\tfor(int j=1;j<=m;j++)sum-=g[j];\r\n\tif(n==m)return !sum;\r\n\tif(abs(sum)%abs(n-m))return 0;\r\n\tint d=sum/(n-m);\r\n\tfor(int i=1;i<=n;i++)f[i]-=d;\r\n\tfor(int j=1;j<=m;j++)g[j]-=d;\r\n\treturn 1;\r\n}\r\nvoid work_sam(){\r\n\tif(!c[1][1])return ;\r\n\tif(!(n&1)){\r\n\t\tfor(int i=1;i<=n/2;i++)f[i]=c[1][1];\r\n\t\tfor(int i=n/2+1;i<=n;i++)f[i]=-c[1][1];\r\n\t\treturn ;\r\n\t}\r\n\tif(!(m&1)){\r\n\t\tfor(int i=1;i<=m/2;i++)g[i]=c[1][1];\r\n\t\tfor(int i=m/2+1;i<=m;i++)g[i]=-c[1][1];\r\n\t\treturn ;\r\n\t}\r\n\tfor(int n1=0;n1<=n;n1++){\r\n\t\tint n2=n-n1,d=n1-n2;\r\n\t\tif(abs(c[1][1]*d)%abs(m-n)==0){\r\n\t\t\tint x=c[1][1]*d/(m-n);\r\n\t\t\tfor(int i=1;i<=n1;i++)f[i]=x+c[1][1];\r\n\t\t\tfor(int i=n1+1;i<=n;i++)f[i]=x-c[1][1];\r\n\t\t\tfor(int j=1;j<=m;j++)g[j]=x;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t}\r\n\tfor(int m1=0;m1<=m;m1++){\r\n\t\tint m2=m-m1,d=m1-m2;\r\n\t\tif(abs(c[1][1]*d)%abs(n-m)==0){\r\n\t\t\tint x=c[1][1]*d/(n-m);\r\n\t\t\tfor(int j=1;j<=m1;j++)g[j]=x+c[1][1];\r\n\t\t\tfor(int j=m1+1;j<=m;j++)g[j]=x-c[1][1];\r\n\t\t\tfor(int i=1;i<=n;i++)f[i]=x;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t}\r\n}\r\nbool dp[maxn][maxn];\r\nint B=maxn*maxn;\r\nbitset<maxn*maxn*2> bs[maxn];\r\nvoid work_sam_dif(){\r\n\tif(n!=m){\r\n\t\tdp[0][0]=1;\r\n\t\tint d=abs(m-n);\r\n\t\tfor(int i=1;i<=m;i++){\r\n\t\t\tfor(int j=0;j<d;j++)if(dp[i-1][j]){\r\n\t\t\t\tdp[i][(j+c[1][i])%d]=1;\r\n\t\t\t\tdp[i][(j+d-c[1][i]%d)%d]=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvector<int> val(m+1);\r\n\t\tint p=0;\r\n\t\tfor(int i=m;i;i--){\r\n\t\t\tif(dp[i-1][(p+c[1][i])%d])val[i]=-c[1][i],(p+=c[1][i])%=d;\r\n\t\t\telse val[i]=c[1][i],(p+=d-c[1][i]%d)%=d;\r\n\t\t}\r\n\t\tint sum=0;for(int i=1;i<=m;i++)sum+=val[i];\r\n\t\tfor(int i=1;i<=n;i++)f[i]=sum/(m-n);\r\n\t\tfor(int i=1;i<=m;i++)g[i]=f[1]-val[i];\r\n\t}\r\n\telse{\r\n\t\tbs[0][B]=1;\r\n\t\tfor(int i=1;i<=m;i++)bs[i]=(bs[i-1]<<c[1][i])|(bs[i-1]>>c[1][i]);\r\n\t\tvector<int> val(m+1);\r\n\t\tint p=B;\r\n\t\tfor(int i=m;i;i--){\r\n\t\t\tif(bs[i-1][p+c[1][i]])val[i]=-c[1][i],p+=c[1][i];\r\n\t\t\telse val[i]=c[1][i],p-=c[1][i];\r\n\t\t}\r\n\t\tfor(int i=1;i<=m;i++)g[i]=-val[i];\r\n\t}\r\n}\r\nvoid sovle(){\r\n\tn=read(),m=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=m;j++)b[i][j]=c[i][j]=read();\r\n\t}\r\n\tif(n==1&&m==1){puts(\"0\");return ;}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=m;j++)if(c[i][j]!=c[i][1])p1=i;\r\n\t}\r\n\tfor(int j=1;j<=m;j++){\r\n\t\tfor(int i=1;i<=n;i++)if(c[i][j]!=c[1][j])p2=j;\r\n\t}\r\n\tif(p1&&p2){\r\n\t\tp3=1;for(int j=1;j<=m;j++)if(c[p1][p2]!=c[p1][j])p3=j;\r\n\t\tif(!work_dif(c[p1][p2],c[p1][p3])){\r\n\t\t\tif(!work_dif(c[p1][p2],-c[p1][p3])){\r\n\t\t\t\tif(!work_dif(-c[p1][p2],c[p1][p3])){\r\n\t\t\t\t\tif(!work_dif(-c[p1][p2],-c[p1][p3]))puts(\"Wa work_dif\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if(!p1&&!p2)work_sam();\r\n\telse{\r\n\t\tbool fl=0;\r\n\t\tif(!p1){\r\n\t\t\tfl=1;\r\n\t\t\tswap(p1,p2);\r\n\t\t\tfor(int i=1;i<=max(n,m);i++){\r\n\t\t\t\tfor(int j=1;j<i;j++)swap(c[i][j],c[j][i]);\r\n\t\t\t}\r\n\t\t\tswap(n,m);\r\n\t\t}\r\n\t\twork_sam_dif();\r\n\t\tif(fl){\r\n\t\t\tfor(int i=1;i<=max(n,m);i++){\r\n\t\t\t\tfor(int j=1;j<i;j++)swap(c[i][j],c[j][i]);\r\n\t\t\t}\r\n\t\t\tswap(n,m);\r\n\t\t\tswap(f,g);\r\n\t\t}\r\n\t}\r\n\tget();check();\r\n}\r\n```",
      "data": {
        "title": "P10644 题解",
        "date": "2024-11-25 19:46:17",
        "tags": [
          "题解",
          "构造"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p10644-ti-jie"
    },
    {
      "content": "[agc069b](https://www.luogu.com.cn/problem/AT_agc069_b)\r\n\r\n### 思路\r\n\r\n取两个排列 $p,q$。假设第一步问 $(p_1,q_1)$ 返回是，接下来问 $(p_2,q_2),\\dotsb,(p_i,q_i),\\dotsb,(p_{n-1},q_{n-1})$。如果某一步问到了是，就再一步把 $(1,q_i),(p_i,1)$ 分出来。最后剩一个问题和 $(p_1,q_1),(p_1,q_n),(p_n,q_n)$，此时三个位置要求至少存在一个 $0$。如果第一步问 $(p_1,q_1)$ 返回否，删掉 $i=p_1$ 和 $j=q_1$ 一行一列进入 $n-1$ 的子问题。当 $n=1$ 时合法。\r\n\r\n等价于 $n-1$ 次删掉一行一列，要求这一行一列中至少有一个 $0$。套路的对每个 $a_{i,j}=0$ 连边 $(i,j+n)$。对于每个连通块，找出一颗生成树，从叶子开始连起，最后根不要了，即能找出 $siz-1$ 对一行一列。如果 $\\sum siz-1 \\ge n-1$ 就合法了。\r\n\r\n然后写出来发现 WA $18$ 个点就破防了！特别的，当 $n>2$ 且去到了 $n=2$ 的全 $1$ 矩阵，剩两个问题时，可以问矩阵以外的位置排除一行或一列，所以 $n>2$ 时，$\\sum siz-1\\ge n-2$ 就合法了。\r\n\r\n### code\r\n\r\n```cpp\r\nint n;\r\nchar s[maxn];\r\nint a[maxn][maxn];\r\nint f[maxn<<1],siz[maxn<<1];\r\nint fd(int x){\r\n\tif(f[x]==x)return x;\r\n\treturn f[x]=fd(f[x]);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tscanf(\"%s\",s+1);\r\n\t\tfor(int j=1;j<=n;j++)a[i][j]=(s[j]=='1');\r\n\t}\r\n\tfor(int i=1;i<=n*2;i++)f[i]=i,siz[i]=0;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=n;j++)if(!a[i][j])f[fd(i)]=fd(j+n);\r\n\t}\r\n\tfor(int i=1;i<=2*n;i++)siz[fd(i)]++;\r\n\tint ans=0;\r\n\tfor(int i=1;i<=2*n;i++)if(fd(i)==i)ans+=siz[i]-1;\r\n\tif(ans>=n-1||(n>2&&ans>=n-2))puts(\"Yes\");\r\n\telse puts(\"No\");\r\n}\r\n```",
      "data": {
        "title": "agc069b 题解",
        "date": "2024-11-25 14:57:18",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "agc069b-ti-jie"
    },
    {
      "content": "## [CF2038](https://codeforces.com/contest/2038)\r\n\r\n### [A. Bonus Project](https://codeforces.com/contest/2038/problem/A)\r\n\r\n$c_i$ 最多为 $\\frac{a_i}{b_i}$。从后往前考虑。如果到 $n-1$ 个人时还有 $>c_{n-1}+c_n$ 的工作，就都罢工了；否则第 $n-1$ 个人会尽量留给 $n$ 做，且不让 $n$ 罢工。取 $c_n=\\min(k,c_n)$，$k$ 减去 $c_n$ 递归为 $n-1$ 的子问题。\r\n\r\n### [B. Make It Equal](https://codeforces.com/contest/2038/problem/B)\r\n\r\n当 $a_i=x$ 时对所有 $i$ 做一遍得到 $a_i=x-1$，所以 $x$ 可二分。每次检查时暴力做若干轮，能减就减，$\\sum a_i-x\\times n$ 至少减半。\r\n\r\n### [C. DIY](https://codeforces.com/contest/2038/problem/C)\r\n\r\n扔掉只出现一次的，排序。检查取 $(a_1,a_2),(a_{n-1},a_n)$ 还是 $(a_1,a_2),(a_n,a_{n-1})$。\r\n\r\n### [D. Divide OR Conquer](https://codeforces.com/contest/2038/problem/D)\r\n\r\n对于右端点 $i$，合法的值 $x$ 的左端点区间 $[l,r]$ 只有 $O(\\log V)$ 个。二分加 st 表找出来。$dp_{i,x}=\\sum_{l\\le j\\le r}\\sum_{y\\le x}dp_{j-1,y}$。 扫描线 $i$，离散化后树状数组维护 $\\le x$ 的 dp 值之和。对于 $i$ 的区间 $[l,r]$，$dp_{i,x}$ 在扫到 $l-1$ 时减去  $\\le x$ 的 dp 值之和，扫到 $r$ 时加上 $\\le x$ 的 dp 值之和，扫到 $i$ 时加到树状数组里。\r\n\r\n```cpp\r\nint n,a[maxn],ans;\r\nint f[18][maxn];\r\nint calc(int l,int r){\r\n\tint k=__lg(r-l+1);\r\n\treturn f[k][l]|f[k][r-(1<<k)+1];\r\n}\r\nstruct node{\r\n\tint l,r,x,f;\r\n};\r\nint lsh[maxn<<5],len;\r\nvector<node> ask[maxn];\r\nvector<pii> add[maxn],del[maxn];\r\nvoid inc(int &u,int v){((u+=v)>=mod)&&(u-=mod);}\r\n#define lb(x) (x&(-x))\r\nint tree[maxn<<5];\r\nvoid upd(int x,int w){while(x<=len)inc(tree[x],w),x+=lb(x);}\r\nint que(int x){int res=0;while(x)inc(res,tree[x]),x-=lb(x);return res;}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)f[0][i]=a[i]=read();\r\n\tfor(int j=1;j<18;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++)f[j][i]=f[j-1][i]|f[j-1][i+(1<<j-1)];\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint p=i;\r\n\t\twhile(p){\r\n\t\t\tint l=1,r=p,res=p;\r\n\t\t\twhile(l<=r){\r\n\t\t\t\tint mid=l+r>>1;\r\n\t\t\t\tif(calc(mid,i)==calc(p,i))res=mid,r=mid-1;\r\n\t\t\t\telse l=mid+1;\r\n\t\t\t}\r\n\t\t\task[i].pb({res,p,calc(p,i),0});\r\n\t\t\tlsh[++len]=ask[i].back().x;\r\n\t\t\tp=res-1;\r\n\t\t}\r\n\t}\r\n\task[0].pb({0,0,0,1});lsh[++len]=0;\r\n\tsort(lsh+1,lsh+len+1);len=unique(lsh+1,lsh+len+1)-lsh-1;\r\n\tfor(int i=0;i<=n;i++){\r\n\t\tfor(int j=0;j<ask[i].size();j++){\r\n\t\t\task[i][j].x=lower_bound(lsh+1,lsh+len+1,ask[i][j].x)-lsh;\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=0;j<ask[i].size();j++){\r\n\t\t\tint l=ask[i][j].l-1,r=ask[i][j].r-1,x=ask[i][j].x;\r\n\t\t\tdel[l].pb({i,j}),add[r].pb({i,j});\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<=n;i++){\r\n\t\tfor(auto[i,j]:del[i])inc(ask[i][j].f,mod-que(ask[i][j].x));\r\n\t\tfor(int j=0;j<ask[i].size();j++)upd(ask[i][j].x,ask[i][j].f);\r\n\t\tfor(auto[i,j]:add[i])inc(ask[i][j].f,que(ask[i][j].x));\r\n\t}\r\n\tfor(auto[l,r,x,f]:ask[n])inc(ans,f);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n\r\n\r\n### [F. Alternative Platforms](https://codeforces.com/contest/2038/problem/F)\r\n\r\n按 $(a_i,b_i)$ 降序，枚举最大值取到 $a_i$，枚举 $k$，要求在 $[1,i-1]$ 中选 $k-1$ 个且至少有一个 $b_j\\le a_i$。容斥为减去所有都大于 $a_i$ 的情况，记 $num_i=\\sum_{j\\le i}[b_j> a_i]$，$ans_k=a_i\\times(\\binom{i-1}{k-1}-\\binom{num_i}{k-1})$。$a_i\\times\\binom{i-1}{k-1}$ 差卷积。记 $val_j=\\sum a_i\\times [num_i=j]$，$val_j\\times\\binom{j}{k-1}$ 差卷积。交换 $a_i,b_i$，把大于等于改为严格大于再做一遍。\r\n\r\n```cpp\r\nint n;\r\npii a[maxn];\r\nint num[maxn];\r\nint lsh[maxn<<1],len;\r\nint tree[maxn<<1];\r\n#define lb(x) (x&(-x))\r\nvoid upd(int x,int w){\r\n\twhile(x<=len){tree[x]+=w,x+=lb(x);}\r\n}\r\nint que(int x){\r\n\tint res=0;\r\n\twhile(x)res+=tree[x],x-=lb(x);\r\n\treturn res;\r\n}\r\nint fac[maxn],inv[maxn];\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%mod;\r\n\t\ta=a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint C(int m,int n){\r\n\tif(m<n||m<0||n<0)return 0;\r\n\treturn fac[m]*inv[n]%mod*inv[m-n]%mod;\r\n}\r\nint ans[maxn],val[maxn];\r\nusing ploy::mul;\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i].fi=read(),lsh[++len]=a[i].fi;\r\n\tfor(int i=1;i<=n;i++)a[i].se=read(),lsh[++len]=a[i].se;\r\n\tsort(lsh+1,lsh+len+1);len=unique(lsh+1,lsh+len+1)-lsh-1;\r\n\tfor(int i=1;i<=n;i++)a[i].fi=lower_bound(lsh+1,lsh+len+1,a[i].fi)-lsh;\r\n\tfor(int i=1;i<=n;i++)a[i].se=lower_bound(lsh+1,lsh+len+1,a[i].se)-lsh;\r\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;\r\n\tinv[n]=ksm(fac[n]);for(int i=n-1;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;\r\n\tsort(a+1,a+n+1);reverse(a+1,a+n+1);\r\n\tvector<int> f(n+1),g(n+1);\r\n\tf[0]=0;for(int i=1;i<=n;i++)f[i]=lsh[a[i].fi]*fac[i-1]%mod;\r\n\tfor(int i=0;i<=n;i++)g[i]=inv[n-i];\r\n\tf=mul(f,g);\r\n\tfor(int k=1;k<=n;k++)ans[k]=f[k+n]*inv[k-1]%mod;\r\n\t// for(int i=1;i<=n;i++){\r\n\t\t// for(int k=1;k<=n;k++)(ans[k]+=lsh[a[i].fi]*C(i-1,k-1))%=mod;\r\n\t// }\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint num=que(len)-que(a[i].fi);\r\n\t\tif(a[i].se>a[i].fi)(val[num]+=lsh[a[i].fi])%=mod;\r\n\t\tupd(a[i].se,1);\r\n\t}\r\n\tf.resize(n),g.resize(n+1);\r\n\tfor(int i=0;i<n;i++)f[i]=mod-val[i]*fac[i]%mod;\r\n\tfor(int i=0;i<=n;i++)g[i]=inv[n-i];\r\n\tf=mul(f,g);\r\n\tfor(int k=1;k<=n;k++)(ans[k]+=f[n+k-1]*inv[k-1])%=mod;\r\n\t// for(int i=0;i<n;i++){\r\n\t\t// for(int k=1;k<=n;k++)(ans[k]+=mod-val[i]*C(i,k-1)%mod)%=mod;\r\n\t// }\r\n\tfor(int i=0;i<=n;i++)val[i]=0;\r\n\tfor(int i=0;i<=len;i++)tree[i]=0;\r\n\tfor(int i=1;i<=n;i++)swap(a[i].fi,a[i].se);\r\n\tsort(a+1,a+n+1);reverse(a+1,a+n+1);\r\n\tf.resize(n+1),g.resize(n+1);\r\n\tf[0]=0;for(int i=1;i<=n;i++)f[i]=lsh[a[i].fi]*fac[i-1]%mod;\r\n\tfor(int i=0;i<=n;i++)g[i]=inv[n-i];\r\n\tf=mul(f,g);\r\n\tfor(int k=1;k<=n;k++)(ans[k]+=f[k+n]*inv[k-1])%=mod;\r\n\t// for(int i=1;i<=n;i++){\r\n\t\t// for(int k=1;k<=n;k++)(ans[k]+=lsh[a[i].fi]*C(i-1,k-1))%=mod;\r\n\t// }\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint num=que(len)-que(a[i].fi-1);\r\n\t\tif(a[i].se>=a[i].fi)(val[num]+=lsh[a[i].fi])%=mod;\r\n\t\tupd(a[i].se,1);\r\n\t}\r\n\tf.resize(n),g.resize(n+1);\r\n\tfor(int i=0;i<n;i++)f[i]=mod-val[i]*fac[i]%mod;\r\n\tfor(int i=0;i<=n;i++)g[i]=inv[n-i];\r\n\tf=mul(f,g);\r\n\tfor(int k=1;k<=n;k++)(ans[k]+=f[n+k-1]*inv[k-1])%=mod;\r\n\t// for(int i=0;i<n;i++){\r\n\t\t// for(int k=1;k<=n;k++)(ans[k]+=mod-val[i]*C(i,k-1)%mod)%=mod;\r\n\t// }\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld \",ans[i]*ksm(C(n,i))%mod);puts(\"\");\r\n}\r\n```\r\n\r\n### [G. Guess One Character](https://codeforces.com/contest/2038/problem/G)\r\n\r\n问 $1$ 和 $11$ 知道 $1$ 的连续段数，问 $01$ 能确定第一位。\r\n\r\n### [I. Polyathlon](https://codeforces.com/contest/2038/problem/I)\r\n\r\n复制一遍，对每个 $x$，求 $a_i[x,x+m-1]$ 排序后的最大值。因为 $m$ 内一定能区分，等价于对 $a_i[x,2\\times m]$ 排序。考虑基数排序，从后往前对每位排序，复杂度 $O(nm)$。\r\n\r\n```cpp\r\nint n,m;\r\nvector<int> a[maxn];\r\nchar s[maxn];\r\nint id[maxn];\r\nvoid work(int j){\r\n\tvector<int> pos[2];\r\n\tfor(int i=1;i<=n;i++)pos[a[id[i]][j]].pb(id[i]);\r\n\tn=0;\r\n\tfor(int i:pos[0])id[++n]=i;\r\n\tfor(int i:pos[1])id[++n]=i;\r\n}\r\nint ans[maxn];\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=n;i++)a[i].resize(m+1);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tscanf(\"%s\",s+1);\r\n\t\tfor(int j=1;j<=m;j++)a[i][j]=s[j]=='1';\r\n\t}\r\n\tfor(int i=1;i<=n;i++)id[i]=i;\r\n\tfor(int i=m-1;i;i--)work(i);\r\n\tfor(int i=m;i;i--)work(i),ans[i]=id[n];\r\n\tfor(int i=1;i<=m;i++)printf(\"%lld \",ans[i]);\r\n}\r\n```\r\n\r\n### [J. Waiting for...](https://codeforces.com/contest/2038/problem/J)\r\n\r\n模拟。\r\n\r\n### [K. Grid Walk](https://codeforces.com/contest/2038/problem/K)\r\n\r\n取出 $gcd(i,a)$ 和 $gcd(j,b)$ 的 $O(\\log V)$ 个后缀最小值，在这些点组成的矩形上走。\r\n\r\n### [L. Bridge Renovation](https://codeforces.com/contest/2038/problem/L)\r\n\r\n贪心，枚举几个 $(18,21,21)$，$0/1$ 个 $(18,21)$，$0/1$ 个 ($18,25)$。其他的填 $(18,18,18)$，$(21,21)$，$(25,25)$。\r\n\r\n### [M. Royal Flush](https://codeforces.com/contest/2038/problem/M)\r\n\r\n设 $dp_{i,a}$ 表示剩 $i$ 张牌，$n$ 种花色的 $[10,14]$ 各持 $a_i$ 张，$a$ 是一个降序的 vector，里面只存没有被删过的状态的降序数量。枚举各种策略，枚举扔牌之后每种牌各进多少张，算概率，记搜。\r\n\r\n注意取一个 $a$ 的前缀转移不一定最优，例如当前 $n=2$，有 $4$ 张 $x$ 和一张 $y$，扔掉 $y$ 之后一次只能摸一张扔一张，不如扔掉 $x$。策略是枚举一个子集。常数极小，60ms 以内。\r\n\r\n```cpp\r\nint n;\r\nmap<vector<int>,db> dp[55];\r\nmap<vector<int>,bool> vis[55];\r\ndb C(int m,int n){\r\n\tif(m<n||m<0||n<0)return 0;\r\n\tdb ans=1;\r\n\tfor(int i=1;i<=n;i++)ans=ans*(m-i+1)/(1.0*i);\r\n\treturn ans;\r\n}\r\ndb dfs(int dep,vector<int> a){\r\n\tif(dep<=0)return -1;\r\n\tif(a.front()==5)return -1;\r\n\tif(vis[dep][a])return dp[dep][a];vis[dep][a]=1;\r\n\tvector<int> aa=a;\r\n\tdb ans=inf;\r\n\tint num=0;while(a.size()&&!a.back())a.pop_back(),++num;\r\n\tvector<int> aaa=a;\r\n\tfor(int s=0;s<(1<<aaa.size());s++){\r\n\t\ta.clear();\r\n\t\tfor(int i=0;i<aaa.size();i++)if(s&(1<<i))a.pb(aaa[i]);\r\n\t\tfor(int i=1;i<=num;i++)a.pb(0);\r\n\t\tif(!a.size())continue;\r\n\t\tdb res=0;\r\n\t\tint sum=0;for(int i:a)sum+=5-i;\r\n\t\tint in=5;for(int i:a)in-=i;\r\n\t\tif(!in)continue;\r\n\t\tfor(int i=0;i<=(a.size()>0?5-a[0]:0);i++){\r\n\t\t\tif(i)a[0]+=i;\r\n\t\t\tfor(int j=0;j<=(a.size()>1?5-a[1]:0)&&i+j<=in;j++){\r\n\t\t\t\tif(j)a[1]+=j;\r\n\t\t\t\tfor(int k=0;k<=(a.size()>2?5-a[2]:0)&&i+j+k<=in;k++){\r\n\t\t\t\t\tif(k)a[2]+=k;\r\n\t\t\t\t\tfor(int l=0;l<=(a.size()>3?5-a[3]:0)&&i+j+k+l<=in;l++){\r\n\t\t\t\t\t\tif(l)a[3]+=l;\r\n\t\t\t\t\t\tvector<int> aaaa=a;\r\n\t\t\t\t\t\tdb val=C((a.size()>0?5-a[0]+i:0),i)*C((a.size()>1?5-a[1]+j:0),j)*C((a.size()>2?5-a[2]+k:0),k)*C((a.size()>3?5-a[3]+l:0),l)*C(dep-sum,in-i-j-k-l);\r\n\t\t\t\t\t\tval=val/C(dep,in);\r\n\t\t\t\t\t\tsort(a.begin(),a.end(),greater<int>());\r\n\t\t\t\t\t\tres+=val*(dfs(dep-in,a)+1);\r\n\t\t\t\t\t\ta=aaaa;\r\n\t\t\t\t\t\tif(l)a[3]-=l;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(k)a[2]-=k;\r\n\t\t\t\t}\r\n\t\t\t\tif(j)a[1]-=j;\r\n\t\t\t}\r\n\t\t\tif(i)a[0]-=i;\r\n\t\t}\r\n\t\tans=min(ans,res);\r\n\t}\r\n\tif(ans==inf)ans=-1;\r\n\treturn dp[dep][aa]=ans;\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tvector<int> a(n,0);\r\n\tprintf(\"%.9lf\\n\",dfs(13*n,a));\r\n}\r\n```\r\n\r\n### [N. Fixing the Expression](https://codeforces.com/contest/2038/problem/N)\r\n\r\n改运算符优于改数字。\r\n",
      "data": {
        "title": "2024-2025 ICPC, NERC, Southern and Volga Russian Regional Contest 做题记录",
        "date": "2024-11-19 17:12:21",
        "tags": [
          "acm"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "2024-2025-icpc-nerc-southern-and-volga-russian-regional-contest-zuo-ti-ji-lu"
    },
    {
      "content": "## [第十届中国大学生程序设计竞赛 重庆站（CCPC 2024 Chongqing Site）](https://qoj.ac/contest/1840)\r\n\r\n### [A. 乘积，欧拉函数，求和](https://qoj.ac/contest/1840/problem/9619)\r\n\r\n注意到 $53\\times 53\\le 3000$，只要 $16$ 个质数，直接状压有没有选这些质数。每个数除掉掉这 $16$ 个质数，剩下一个大质数或 $1$，把剩下的数相同的一起做，一起乘 $\\frac{x-1}{x}$.\r\n\r\n```cpp\r\nint n,a[maxn],ans;\r\nint pre[15]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%mod;\r\n\t\ta=a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nvector<int> id[maxn];\r\nint dp[1<<15],f[1<<15];\r\nint msk[maxn];\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint x=a[i];\r\n\t\tfor(int j=0;j<15;j++)if(x%pre[j]==0){\r\n\t\t\tmsk[i]|=1<<j;\r\n\t\t\twhile(x%pre[j]==0)x/=pre[j];\r\n\t\t}\r\n\t\tif(x==53*53)x=53;\r\n\t\tid[x].pb(i);\r\n\t}\r\n\tdp[0]=1;\r\n\tfor(int i=1;i<=maxn-10;i++)if(id[i].size()){\r\n\t\tmems(f,0);\r\n\t\tfor(int j:id[i]){\r\n\t\t\tfor(int s=(1<<15)-1;~s;s--){\r\n\t\t\t\t(f[s|msk[j]]+=dp[s]*(i==1?a[j]:a[j]/i*(i-1))+f[s]*a[j])%=mod;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int s=0;s<(1<<15);s++)(dp[s]+=f[s])%=mod;\r\n\t}\r\n\tfor(int s=0;s<(1<<15);s++)if(dp[s]){\r\n\t\tint val=dp[s];\r\n\t\tfor(int i=0;i<15;i++)if(s&(1<<i))val=val*ksm(pre[i])%mod*(pre[i]-1)%mod;\r\n\t\t(ans+=val)%=mod;\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [B. osu!mania](https://qoj.ac/contest/1840/problem/9620)\r\n\r\n模拟，$+0.5+eps$ 下取整。\r\n\r\n### [C. 连方](https://qoj.ac/contest/1840/problem/9621)\r\n\r\n特判全 ```.```  或全 ```#```，剩下的一定可以构造出来。$c_{2,i}$ 与 $c_{1,i}$ 反过来填，使第一行连通。$c_{3,i}$ 取一个单点连接第 $2$ 行，$567$ 行同 $321$ 行，第 $4$ 行将第 $3,5$ 行的单点连通。\r\n\r\n### [D. 有限小数](https://qoj.ac/contest/1840/problem/9622)\r\n\r\n将 $b$ 的 $2,5$ 因子拆出来，令 $b=b'p$，$b'$ 中没有 $2,5$ 因子。发现 $d=2^i5^jb$。枚举 $i,j$，$2^i5^j=q$，有 $\\frac{a}{pb}+\\frac{c}{qb}=\\frac{e}{10^m}$，$aq+pc=be$。exgcd 解 $c,e$。\r\n\r\n```cpp\r\nint a,b;\r\npii ans={inf,inf};\r\nvoid exgcd(int a,int b,int &x,int &y){\r\n\tif(!b){x=1,y=0;return ;}\r\n\texgcd(b,a%b,x,y);\r\n\tint p=x;\r\n\tx=y,y=p-(a/b)*y;\r\n}\r\nvoid work(){\r\n\ta=read(),b=read();ans={inf,inf};int p=1;\r\n\twhile(b%2==0)b/=2,p*=2;\r\n\twhile(b%5==0)b/=5,p*=5;\r\n\tint xx=0,yy=0;exgcd(b,p,xx,yy);\r\n\tif(b==1){puts(\"0 1\");return ;}\r\n\tfor(int i=1;i*b<=inf;i*=2){\r\n\t\tfor(int j=i;j*b<=inf;j*=5){\r\n\t\t\tint q=j,c=yy,d=q*b;\r\n\t\t\tc*=-a*q;c%=b,c+=b,c%=b;\r\n\t\t\tans=min(ans,{c,d});\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld %lld\\n\",ans.fi,ans.se);\r\n}\r\n```\r\n\r\n### [E. 合成大西瓜](https://qoj.ac/contest/1840/problem/9623)\r\n\r\n可以取到所有度数 $\\ge 2$ 的点和次大值。\r\n\r\n### [H. str(list(s))](https://qoj.ac/submission/745689)\r\n\r\n设 $dp_{i,j}$ 表示第 $i$ 轮模 $p$ 为 $j$ 的位置的和，$f_{i,j,0/1}$ 表示第 $i$ 轮模 $p$ 为 $j$ 的位置是否为 ```'``` '的方案数。按规则模拟。\r\n\r\n### [I. 算术](https://qoj.ac/contest/1840/problem/9627)\r\n\r\n$1122\\to33$，$11\\to 22$。\r\n\r\n### [J. 骰子](https://qoj.ac/contest/1840/problem/9628)\r\n\r\n答案为 $6nm$。在一个 $2\\times 2$ 的矩阵内可以从以 $6$ 为底去到相邻位置以 $6$ 为底。\r\n\r\n### [K. 小 C 的神秘图形](https://qoj.ac/contest/1840/problem/9629)\r\n\r\n模拟。\r\n\r\n### [M. Median Replacement](https://qoj.ac/contest/1840/problem/9631)\r\n\r\n如果一个数成为长为 $3$ 的区间的中位数，就可以成为最后的数。将值域离散化，对于 $x$ 计算答案 $\\ge x$ 的方案数，即 $\\prod r_i-l_i+1$ 减去答案 $<x$ 的方案数。转为 $0/1/2$，设 $dp_{i,0/1,0/1}$ 表示这个和上一个是否 $\\ge x$，不能存在 $101$ 或 $110$。很难发现 $val_x$ 是关于 $x$ 的若干次多项式，取 $200$ 个之后插值。\r\n\r\n```cpp\r\nint n,ans;\r\nint l[maxn],r[maxn];\r\nint lsh[maxn],len;\r\nint x[maxn],y[maxn];\r\nint dp[maxn][2][2];\r\nint calc(int v){\r\n\tfor(int i=1;i<=n;i++)dp[i][0][0]=dp[i][0][1]=dp[i][1][0]=0;dp[0][0][0]=1;\r\n\tint mul=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint len=r[i]-l[i]+1,l1=max(0ll,min(len,v-l[i])),l2=max(0ll,min(len,r[i]-v+1));\r\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])*l1%mod;\r\n\t\tdp[i][0][1]=dp[i-1][0][0]*l2%mod;\r\n\t\tdp[i][1][0]=dp[i-1][0][1]*l1%mod;\r\n\t\tmul=mul*len%mod;\r\n\t}\r\n\treturn (mul+3*mod-dp[n][0][0]-dp[n][0][1]-dp[n][1][0])%mod;\r\n}\r\nint lag(int k,int v){\r\n\tint res=0;\r\n\tfor(int i=1;i<=k;i++){\r\n\t\tint mul1=1,mul2=1;\r\n\t\tfor(int j=1;j<=k;j++)if(i!=j){\r\n\t\t\tmul1=mul1*(v+mod-x[j])%mod;\r\n\t\t\tmul2=mul2*(x[i]+mod-x[j])%mod;\r\n\t\t}\r\n\t\t(res+=y[i]*mul1%mod*ksm(mul2))%=mod;\r\n\t}\r\n\treturn res;\r\n}\r\nvoid work(){\r\n\tn=read();ans=0;\r\n\tfor(int i=1;i<=n;i++)l[i]=read();\r\n\tfor(int i=1;i<=n;i++)r[i]=read();\r\n\tlsh[len=1]=1;\r\n\tfor(int i=1;i<=n;i++)lsh[++len]=l[i],lsh[++len]=r[i]+1;\r\n\tsort(lsh+1,lsh+len+1),len=unique(lsh+1,lsh+len+1)-lsh-1;\r\n\tfor(int i=1;i<len;i++){\r\n\t\tint ll=lsh[i],rr=lsh[i+1]-1,k=min(rr-ll+1,200ll);\r\n\t\tfor(int j=ll;j<=ll+k-1;j++)y[j-ll+1]=calc(x[j-ll+1]=j);\r\n\t\tfor(int j=1;j<=k;j++)(y[j]+=y[j-1])%=mod;\r\n\t\tif(rr-ll+1==k)(ans+=y[rr-ll+1])%=mod;\r\n\t\telse (ans+=lag(k,rr))%=mod;\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "CCPC 2024 Chongqing Site 做题记录",
        "date": "2024-11-19 15:49:04",
        "tags": [
          "acm"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ccpc-2024-chongqing-site-zuo-ti-ji-lu"
    },
    {
      "content": "[https://www.frontlinefellowship.io/blog/mixuyang?categoryId=438589](https://www.frontlinefellowship.io/blog/mixuyang?categoryId=438589)",
      "data": {
        "title": "我会找回我的生活吗？我承诺。",
        "date": "2024-11-17 22:46:21",
        "tags": [
          "随机说话"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wo-hui-zhao-hui-wo-de-sheng-huo-ma-wo-cheng-nuo"
    },
    {
      "content": "[CF1270H](https://www.luogu.com.cn/problem/CF1270H)\r\n\r\n暑假讲完，今天再考，一点印象都没有！完全没有任何观察，自己搞了 $O(n\\log^2 n)$ 做法。\r\n\r\n### 思路\r\n\r\n找每个连通块的第一个数，显然是前缀最小值，那就维护前缀最小值的一部分然后楼房重建就好了。\r\n\r\n具体来说，记录左儿子区间最后一个连通块开头位置 $p$，在右儿子区间二分出最大的 $pr$ 使得 $\\min_{i=p}^{pr-1} a_i\\le a_{pr}$，$[mid+1,pr]$ 的连通块开头位置都不要了。再在左儿子区间二分最小的 $pl$ 使得 $a_{pl}<\\max_{i=p}^{pr}a_i$，$[pl,p-1]$ 的连通块开头位置都不要了。pushup 的复杂度 $O(\\log n)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,q,a[maxn];\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nint val[maxn<<2],mn[maxn<<2],mx[maxn<<2],pos[maxn<<2];\r\npii fdr(int nd,int l,int r,int w){\r\n\tif(mx[nd]<w)return {val[nd],l-1};\r\n\tif(l==r){\r\n\t\treturn {0,l};\r\n\t}\r\n\tif(mx[rs]>w)return fdr(rs,mid+1,r,min(w,mn[ls]));\r\n\tpii res=fdr(ls,l,mid,w);\r\n\treturn {val[nd]-val[ls]+res.fi,res.se};\r\n}\r\nint fdl(int nd,int l,int r,int w){\r\n\tif(mn[nd]>w)return val[nd];\r\n\tif(l==r)return 0;\r\n\tif(mn[ls]<=w)return fdl(ls,l,mid,max(w,mx[rs]));\r\n\treturn val[nd]-val[rs]+fdl(rs,mid+1,r,w);\r\n}\r\nint quemx(int nd,int l,int r,int ql,int qr){\r\n\tif(l>=ql&&r<=qr)return mx[nd];\r\n\tif(qr<=mid)return quemx(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return quemx(rs,mid+1,r,ql,qr);\r\n\treturn max(quemx(ls,l,mid,ql,qr),quemx(rs,mid+1,r,ql,qr));\r\n}\r\nint quemn(int nd,int l,int r,int ql,int qr){\r\n\tif(l>=ql&&r<=qr)return mn[nd];\r\n\tif(qr<=mid)return quemn(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return quemn(rs,mid+1,r,ql,qr);\r\n\treturn min(quemn(ls,l,mid,ql,qr),quemn(rs,mid+1,r,ql,qr));\r\n}\r\nvoid up(int nd,int l,int r){\r\n\tmn[nd]=min(mn[ls],mn[rs]),mx[nd]=max(mx[ls],mx[rs]);\r\n\tpii res=fdr(rs,mid+1,r,quemn(ls,l,mid,pos[ls],mid));\r\n\tint p=res.se;val[nd]=res.fi+1;\r\n\tpos[nd]=(p==r?pos[ls]:pos[rs]);\r\n\tint num=fdl(ls,l,mid,quemx(nd,l,r,pos[ls],p));\r\n\tval[nd]+=num;\r\n}\r\nvoid build(int nd,int l,int r){\r\n\tif(l==r){\r\n\t\tval[nd]=1,mn[nd]=mx[nd]=a[l],pos[nd]=l;\r\n\t\treturn ;\r\n\t}\r\n\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n\tup(nd,l,r);\r\n}\r\nvoid updata(int nd,int l,int r,int p){\r\n\tif(l==r){\r\n\t\tval[nd]=1,mn[nd]=mx[nd]=a[l],pos[nd]=l;\r\n\t\treturn ;\r\n\t}\r\n\tif(p<=mid)updata(ls,l,mid,p);\r\n\telse updata(rs,mid+1,r,p);\r\n\tup(nd,l,r);\r\n}\r\nvoid work(){\r\n\tn=read();q=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tbuild(1,1,n);\r\n\twhile(q--){\r\n\t\tint u=read();a[u]=read();\r\n\t\tupdata(1,1,n,u);\r\n\t\twrite(val[1]),puts(\"\");\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "CF1270H 题解",
        "date": "2024-11-05 12:32:03",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1270h-ti-jie"
    },
    {
      "content": "### [P8180](https://www.luogu.com.cn/problem/P8180)\r\n\r\n不同的解法，感觉比较牛。\r\n\r\n### 思路\r\n\r\n对 $ll_i$ 和 $rr_i$ 排序。直接考虑最小值在哪里，假设为位置 $p$。那么 $[1,p-1]$ 的 $rr_i$ 都 $\\le p$，$[p,n]$ 的 $rr_i$ 都 $>p$，$ll_i$ 也有相似的限制。都符合 $ll,rr$ 限制的 $p$ 是唯一的，更进一步，符合 $rr$ 的限制的最右的点和符合 $ll$ 限制的最左的点是同一个点，且就是 $p$。否则不难说明会寄。\r\n\r\n那就分治 $[l,r]$，找到 $p$，真实的 $ll_p$ 是 $ll_l=l$，真实的 $rr_p$ 是 $rr_r=r$，平移 $ll[l,p-1]=ll[l+1,p],rr[p+1,r]=rr[p,r-1]$ 后分治 $[l,p-1],[p+1,rr]$，贡献是 $\\binom{r-l}{r-p}$。$O(n^2)$ 的分治只需要 $ll$ 或 $rr$ 中的一个数组，会被单调递增递减卡 T。难以快速寻找区间对应的 $p$ 。\r\n\r\n但是只要枚举到了 $p$ 可以 $O(1)$ 检查是否合法。从左往右和从右往左同时枚举第一个满足 $ll$ 限制和最后一个满足 $rr$ 限制的点，一找到就退出递归。这样能保证每个区间枚举次数为分治两边的较短的长度，复杂度分析同 [min+sum](https://www.luogu.com.cn/problem/AT_abc282_h)，每个点被枚举一次对应的区间翻倍。注意双指针也要保证严格枚举次数为两边的较短的长度，恰好比当前枚举的位置多 $1$ 即可。\r\n\r\n复杂度 $O(n\\log n)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,ans=1;\r\nint ll[maxn],rr[maxn];\r\nint fac[maxn],inv[maxn];\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%mod;\r\n\t\ta=a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint C(int m,int n){return fac[m]*inv[n]%mod*inv[m-n]%mod;}\r\nvoid sovle(int l,int r,int p1,int p2,int p3,int p4){\r\n\tif(l>=r)return ;\r\n\tint p=0;\r\n\tfor(int ir=r,il=l,jr=p4+1,jl=p1-1;ir>=l;ir--,il++){\r\n\t\twhile(jr-1>=p3&&rr[jr-1]>ir){\r\n\t\t\tjr--;\r\n\t\t\tif(jr-p3<ir-l)break;\r\n\t\t}\r\n\t\tif(ir-l==jr-p3){\r\n\t\t\tp=ir;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\twhile(jl+1<=p2&&ll[jl+1]<il){\r\n\t\t\tjl++;\r\n\t\t\tif(jl-p1>il-l)break;\r\n\t\t}\r\n\t\tif(il-l==jl-p1){\r\n\t\t\tp=il;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// cout<<il<<\" \"<<ir<<\" \"<<jl<<\" \"<<jr<<\"\\n\";\r\n\t}\r\n\t// cout<<l<<\" \"<<r<<\" \"<<p<<\" \"<<p1<<\" \"<<p2<<\" \"<<p3<<\" \"<<p4<<\"\\n\";\r\n\tif(p<l||p>r)exit(0);\r\n\tans=ans*C(r-l,r-p)%mod;\r\n\tsovle(l,p-1,p1+1,p1+p-l,p3,p3+p-l-1),sovle(p+1,r,p1+p-l+1,p2,p3+p-l,p4-1);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)ll[i]=read();\r\n\tfor(int i=1;i<=n;i++)rr[i]=read();\r\n\tsort(ll+1,ll+n+1),sort(rr+1,rr+n+1);\r\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;\r\n\tinv[n]=ksm(fac[n]);for(int i=n-1;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;\r\n\tsovle(1,n,1,n,1,n);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "P8180 题解",
        "date": "2024-11-01 15:45:04",
        "tags": [
          "题解"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p8180-ti-jie"
    },
    {
      "content": "### [P8172](https://www.luogu.com.cn/problem/P8172)\r\n\r\n太良心了，搬题人！联考开了 1.5s 随便过。\r\n\r\n这个复杂度不太对，需要卡常。\r\n\r\n### 思路\r\n\r\n为方便，交换一下定义，是一个 $m$ 行 $n$ 列的矩阵，列从 $0$ 开始编号，$n\\le 13$。\r\n\r\n考虑状压 $n$，设 $dp_{i,s}$ 表示已经填满了 $i-1$ 行，第 $i$ 行填了状态 $s$。从 $dp_{i,s}$ 转移到 $dp_{i+1,t}$ 时，设 $f_{j,ss}$ 表示现在要填 $(i,j)$，第 $i+1$ 行 $[0,j)$ 的部分和第 $i$ 行 $[j,n)$ 部分并起来的状态为 $ss$。发现如果 $(i,j)$ 和 $(i,j+1)$ 都为空，$(i,j),(i+1,j),(i+1,j+1)$ 的三角无用，所以没有后效性。\r\n\r\n发现 $m=10^9$ 很像矩阵优化 dp。对于每个 $s$ 都 $O(2^nn)$ 算能否转移到每个 $t$。然后就是有 $q$ 个第 $p$ 行点不能是状态 $ss$ 的限制，形如要求做完第 $p-1$ 行的状态 $s$ 逻辑与 $ss$ 为 $0$，然后 $s$ 再或上 $ss$ 继续做，分成 $q$ 段查询。能做 $n\\le 6$，跟暴力同分。\r\n\r\n只需要知道可行性用 bitset 优化，预处理出 $2$ 的幂次，然后查询时用 bitset 维护向量。能做 $n\\le 10$，跟暴力同分。\r\n\r\n再观察，猜测经过若干个空的行之后会出现长为 $6$ 的循环节。发现一个状态 $s$ 经过 $6+x$ 个空行之后就能到达所有经过 $6k+x$ 个空行能到达的状态。所以 $len=\\min(len,len\\bmod 6+6)\\le 12$，那只需要维护前 $3$ 个转移矩阵的 $2$ 的幂次。能做 $n\\le 12$，跟暴力同分。\r\n\r\n卡常方面，有值的状态不多，bitset 自带的 ```_Find_first()``` 和 ```_Find_next(i)``` 函数可以快速跳一个 bitset 为 $1$ 的位置，常熟大大减小。然后发现瓶颈在于矩阵乘法，不妨只维护 $2^1,2^2$ 的转移矩阵，稍微增大查询时向量乘法次数。就赢了！\r\n\r\n复杂度 $O((2^n)^2n+\\frac{(2^n)^3}{w}+q\\frac{(2^n)^2}{w})$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,k,l;\r\nmap<int,int> mp;\r\nconst int maxm=1<<13;\r\n#define vec bitset<maxm>\r\nstruct mat{\r\n\tvec e[maxm];\r\n\tmat(){\r\n\t\tfor(int i=0;i<l;i++)e[i].reset();\r\n\t}\r\n\tmat operator*(const mat&tmp)const{\r\n\t\tmat res;\r\n\t\tfor(int i=0;i<l;i++){\r\n\t\t\tfor(int k=e[i]._Find_first();k<l;k=e[i]._Find_next(k)){\r\n\t\t\t\tres.e[i]|=tmp.e[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}pw[30];\r\nvec operator*(vec e,mat tmp){\r\n\tvec res;res.reset();\r\n\tfor(int k=e._Find_first();k<l;k=e._Find_next(k)){\r\n\t\tres|=tmp.e[k];\r\n\t}\r\n\treturn res;\r\n}\r\nvec res;\r\nbitset<maxm> f[maxn+1];\r\nvector<pii> que;\r\nvoid work(){\r\n\tn=read();m=read();k=read();\r\n\tfor(int i=1;i<=k;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tmp[v]|=(1<<u-1);\r\n\t}\r\n\tif(n<=6)return sub1::sovle();\r\n\tl=1<<n;\r\n\tfor(int s=0;s<l;s++){\r\n\t\tfor(int i=0;i<=n;i++)f[i].reset();f[0][s]=1;\r\n\t\tfor(int i=0;i<n;i++){\r\n\t\t\tfor(int t=f[i]._Find_first();t<l;t=f[i]._Find_next(t)){\r\n\t\t\t\tif(t&(1<<i)){\r\n\t\t\t\t\tf[i+1][t^(1<<i)]=1;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(i+1<n&&!(t&(1<<i+1))){\r\n\t\t\t\t\t\tf[i+2][t|(1<<i)]=1;\r\n\t\t\t\t\t\tf[i+2][t|(1<<i+1)]=1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(i&&!(t&(1<<i-1))){\r\n\t\t\t\t\t\tf[i+1][t|(1<<i)|(1<<i-1)]=1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(i+1<n&&(t&(1<<i+1))){\r\n\t\t\t\t\t\tf[i+2][t|(1<<i)]=1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpw[0].e[s]=f[n];\r\n\t}\r\n\tfor(auto [p,s]:mp)que.pb({p,s});\r\n\tque.pb({m+1,l-1});\r\n\tint mx=0,B=6,k=29;\r\n\tfor(int i=0;i<que.size()-1;i++)mx=max(mx,que[i+1].fi-que[i].fi);\r\n\tmx=min(mx,B);k=2;\r\n\tfor(int i=1;i<=k;i++)pw[i]=pw[i-1]*pw[i-1];\r\n\t// return ;\r\n\tint lst=0;res[0]=1;\r\n\tfor(auto[p,s]:que){\r\n\t\tint len=p-1-lst;\r\n\t\tlen=min(len,len%B+B);\r\n\t\twhile(len>=(1<<k))res=res*pw[k],len-=1<<k;\r\n\t\tfor(int i=k;~i;i--)if(len&(1<<i)){\r\n\t\t\tres=res*pw[i];\r\n\t\t}\r\n\t\tfor(int t=res._Find_first();t<l;t=res._Find_next(t)){\r\n\t\t\tif(s&t)res[t]=0;\r\n\t\t}\r\n\t\tif(!res.count()){puts(\"NO\");return ;}\r\n\t\tfor(int t=res._Find_first();t<l;t=res._Find_next(t)){\r\n\t\t\tres[t]=0,res[s|t]=1;\r\n\t\t}\r\n\t\tlst=p-1;\r\n\t}\r\n\tputs(\"YES\");\r\n}\r\n```\r\n\r\n### upd\r\n\r\n关于正解，其实也很脑瘫，你把两个有限制的行间的距离缩为 $12$ 以内，总行数 $12q$，就不用矩阵快速幂了，直接做原 dp 即可。复杂度 $O(nq2^n)$。",
      "data": {
        "title": "P8172 题解",
        "date": "2024-11-01 14:58:49",
        "tags": [
          "题解",
          "dp",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p8172-ti-jie"
    },
    {
      "content": "### [【模板】基于值域预处理的快速离散对数](https://www.luogu.com.cn/problem/P11175)\r\n\r\n记使得 $g^x\\equiv n\\pmod{mod}$ 的最小非负 $x$ 为 $\\log n$，有 $\\log ab=\\log a+\\log b$。\r\n\r\n令 $n=\\sqrt{mod}+1$，预处理 $n$ 以内的 $\\log x$。线性筛，只需要 bsgs 求出 $n$ 以内 $\\frac{n}{\\ln n}$ 个质数的 $\\log p$，就可以 $O(n)$ 求出 $n$ 以内所有 $\\log x$。哈希表，预处理时 $B$ 次插入，$\\frac{n}{\\ln n}$ 次 $\\frac{mod}{B}$ 的查询，取 $B=\\sqrt{\\frac{n\\times mod}{\\ln n}}$。\r\n\r\n查询 $\\log a$ 时，如果 $a\\le \\sqrt{mod}+1$ 直接得出，否则有 $b\\times a+c=mod$，$b\\le \\sqrt{mod}$。$\\log a=\\log \\frac{-c}{b}=\\log(c\\times -1)-\\log b=\\log (mod-1)+\\log c-\\log b$。又因为有 $(b+1)\\times a+c=mod+a$，$\\log a=\\log \\frac{a-c}{b+1}=\\log(a-c)-\\log (b+1)$。$\\log b$ 或 $\\log(b+1)$ 已知，$\\log (mod-1)$ 提前算，$\\min(c,a-c)\\le \\frac{a}{2}$，选 $c$ 和 $a-c$ 较小的一边递归可以做到 $\\log {mod}$ 查询。\r\n\r\n复杂度 $O(\\frac{mod^{\\frac{3}{4}}}{\\log^{\\frac{1}{2}}mod}+q\\log {mod})$\r\n\r\n### code\r\n\r\n```cpp\r\nint mod,g,n,q;\r\nint inc(int u,int v){((u+=v)>=mod-1)&&(u-=mod-1);return u;}\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=1ll*ans*a%mod;\r\n\t\ta=1ll*a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint B,bas,h0;\r\nstruct hsh_table{\r\n\tint head[maxn],tot;\r\n\tstruct nd{\r\n\t\tint nxt;\r\n\t\tint key;\r\n\t\tint val;\r\n\t}e[maxn];\r\n\tint hsh(int u){return u%maxn;}\r\n\tbool find(int key){\r\n\t\tint u=hsh(key);\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tif(e[i].key==key)return 1;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\tint &operator[](int key){\r\n\t\tint u=hsh(key);\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tif(e[i].key==key)return e[i].val;\r\n\t\t}\r\n\t\te[++tot]={head[u],key,0};head[u]=tot;\r\n\t\treturn e[tot].val;\r\n\t}\r\n\tvoid clear(){\r\n\t\ttot=0;\r\n\t\tfor(int i=0;i<maxn;i++)head[i]=0;\r\n\t}\r\n}mp;\r\nint bsgs(int v){\r\n\tint mul=v;\r\n\tfor(int i=0;i<=mod/B;i++){\r\n\t\tif(mp.find(mul))return i*B+mp[mul];\r\n\t\tmul=1ll*mul*bas%mod;\r\n\t}\r\n}\r\n/*\r\nmod=ba+c\r\nlog(a)=log(-c)-log(b)=log(mod-1)+log(c)-log(b)\r\nlog(a)=log(a-c)-log(b+1)\r\nmin(c,a-c)<=a/2\r\n*/\r\nint h[maxn];\r\nint sovle(int a){\r\n\tint b=mod/a,c=mod%a;\r\n\tif(a<=n)return h[a];\r\n\tif(c<a-c)return inc(inc(h0,sovle(c)),(mod-1-h[b]));\r\n\telse return inc(sovle(a-c),mod-1-h[b+1]);\r\n}\r\nbool vis[maxn];\r\nint pre[maxn],cnt;\r\nvoid work(){\r\n\tmod=read();g=read();n=sqrt(mod)+1;B=sqrt(1ll*mod*n/log2(n));\r\n\t// cout<<n<<\" \"<<B<<\"\\n\";\r\n\tint mul=1;for(int i=0;i<B;i++){\r\n\t\tmp[mul]=i;\r\n\t\tmul=1ll*mul*g%mod;\r\n\t}\r\n\tbas=ksm(ksm(g,B));\r\n\th0=bsgs(mod-1);\r\n\th[1]=0;\r\n\tfor(int i=2;i<=n;i++){\r\n\t\tif(!vis[i]){\r\n\t\t\th[i]=bsgs(i);\r\n\t\t\tpre[++cnt]=i;\r\n\t\t}\r\n\t\tfor(int j=1;j<=cnt&&1ll*i*pre[j]<=n;j++){\r\n\t\t\tvis[i*pre[j]]=0;\r\n\t\t\th[i*pre[j]]=(h[i]+h[pre[j]])%(mod-1);\r\n\t\t\tif(i%pre[j]==0)break;\r\n\t\t}\r\n\t}\r\n\tq=read();\r\n\twhile(q--){\r\n\t\tint x=read();\r\n\t\tprintf(\"%lld\\n\",sovle(x));\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "P11175 题解",
        "date": "2024-10-29 22:23:34",
        "tags": [
          "题解",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11175-ti-jie"
    },
    {
      "content": "### 241025\r\n\r\n感觉这周睡眠质量非常差。每天贼晚才睡得着，早上被唐氏宿管搞醒非常不爽；中午 12:30 提前回宿舍睡到下午 2:25 压线出宿舍，补觉近 2h；晚上又睡不着了。\r\n\r\n困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困困\r\n\r\n在机房就是开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，开一道不会一道，mlgbdc。\r\n\r\n难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难难\r\n\r\n摆烂时非常喜欢看别人的闲话，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊，非常的有意思啊。\r\n\r\n唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐唐\r\n\r\n### 241026\r\n\r\n还是睡不着。\r\n\r\n摆。\r\n\r\n感觉没有 cpeditor 写代码效率骤降。\r\n\r\n摆。\r\n\r\n补觉，在 13:55 没人叫就醒了。\r\n\r\n进场，旁边 yjh。搞半天编译器，非常难受。T1 一开始看成最大化想半天为啥是这样，直接红温了。排序后瞎几把贪，就扔了。T2 发现是 $[l,r]$ 至少有一个，想半天差分约束忘了怎么写，写出来之后还 T 了。然后发现是没有负环的从右往左直接转移，sb 了。T3 典题，非常兴奋，导致敲键盘太大声被 yjh 批评了，谢罪。T4 会不了一点，大概会个 $O(n\\log^3n)$，还有点 $O(n\\log n)$ 的思路，感觉非常困难，想着先写个暴力。然后直接被 $O(nm\\log n)$ 的暴力硬控了快 1h。最后剩半个小时什么都写不了，直接摆了。\r\n\r\n出来后发现大家都没过 T4，写暴力非常正确。\r\n\r\n晚上听说 T1 是众数，一想完了，虚空 hack 自己。惯性思维 T3 全局加单点修改单点查，直接写了个线段树，小丑了。\r\n",
      "data": {
        "title": "CSP2024 游记",
        "date": "2024-10-25 20:57:03",
        "tags": [
          "游记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "csp2024-you-ji"
    },
    {
      "content": "[P11225](https://www.luogu.com.cn/problem/P11225)\r\n\r\n基本同 [arc106e](https://www.luogu.com.cn/problem/AT_arc106_e)。\r\n\r\n### 思路\r\n\r\n预处理 $k$ 个关键点的单源最短路。二分答案，就知道点 $u$ 能去哪些关键点。可以网络流，连边 $(S,u,1)$，$(a_i,T,val_i)$，如果 $dis_{i,u}\\le x$ 连边 $(u,a_i,1)$，检查最大流是否为 $n$。用 Hall 定理判定，对于二分图 $G(V1,V2,E)(\\lvert V1\\rvert\\le \\lvert V2\\rvert)$，$V1$ 存在完美匹配的充要条件为 $\\forall X\\subseteq V1,\\lvert X\\rvert\\le\\lvert N(X)\\rvert$，其中 $N(X)$ 是与 $X$ 中点有边的点集。\r\n\r\n状压 $k$ 个关键点，枚举 $N(X)$ 对应的子集为 $s$ ，$X$ 是所有使得 $\\forall dis_{i,u}\\le x,i\\in s$ 的 $u$，高维前缀和计算。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,k;\r\nint a[17],val[17];\r\nint head[maxn],tot;\r\nstruct edge{\r\n\tint nxt,to,w;\r\n}e[maxn*6];\r\nvoid add(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}\r\nint dis[17][maxn];\r\nbool vis[maxn];\r\npriority_queue<pii> q;\r\nint sum[1<<17],dp[1<<17];\r\nbool check(int x){\r\n\tfor(int s=1;s<(1<<k);s++){\r\n\t\tsum[s]=sum[s^(s&(-s))]+val[__builtin_ctz(s&(-s))];\r\n\t}\r\n\tfor(int s=0;s<(1<<k);s++)dp[s]=0;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint s=0;\r\n\t\tfor(int j=0;j<k;j++)if(dis[j][i]<=x)s|=1<<j;\r\n\t\tdp[s]++;\r\n\t}\r\n\tfor(int i=0;i<k;i++){\r\n\t\tfor(int s=0;s<(1<<k);s++){\r\n\t\t\tif(s&(1<<i))dp[s]+=dp[s^(1<<i)];\r\n\t\t}\r\n\t}\r\n\tfor(int s=0;s<(1<<k);s++)if(dp[s]>sum[s])return 0;\r\n\treturn 1;\r\n}\r\nvoid work(){\r\n\tn=read();m=read();k=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read(),w=read();\r\n\t\tadd(u,v,w),add(v,u,w);\r\n\t}\r\n\tfor(int i=0;i<k;i++)a[i]=read(),val[i]=read();\r\n\tfor(int i=0;i<k;i++){\r\n\t\tmems(dis[i],0x3f),mems(vis,0);\r\n\t\tdis[i][a[i]]=0,q.push({0,a[i]});\r\n\t\twhile(!q.empty()){\r\n\t\t\tint u=q.top().se;q.pop();\r\n\t\t\tif(vis[u])continue;vis[u]=1;\r\n\t\t\tfor(int ii=head[u];ii;ii=e[ii].nxt){\r\n\t\t\t\tint v=e[ii].to;\r\n\t\t\t\tif(dis[i][v]>dis[i][u]+e[ii].w){\r\n\t\t\t\t\tdis[i][v]=dis[i][u]+e[ii].w;\r\n\t\t\t\t\tq.push({-dis[i][v],v});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// for(int j=1;j<=n;j++)cout<<dis[i][j]<<\" \";cout<<\"\\n\";\r\n\t}\r\n\tint l=0,r=inf,res=inf;\r\n\twhile(l<=r){\r\n\t\tint mid=l+r>>1;\r\n\t\tif(check(mid))r=mid-1,res=mid;\r\n\t\telse l=mid+1;\r\n\t}\r\n\tprintf(\"%lld\\n\",res);\r\n}\r\n```\r\n\r\n",
      "data": {
        "title": "P11225 题解",
        "date": "2024-10-25 15:27:07",
        "tags": [
          "题解",
          "图论",
          "网络流"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p11225-ti-jie"
    },
    {
      "content": "[https://www.bilibili.com/video/BV1tA4m1N7K4/](https://www.bilibili.com/video/BV1tA4m1N7K4/)\r\n\r\n以祢深邃的智慧和仁心安排一切，赐予万民助益，唯一的造物主，求主安息祢奴仆的灵魂；因他将坚定的希望寄托于祢，造物者、建造者、我们的神。\r\n\r\n“不要让自己被吓倒，不要用他们强大、牛气的幻相欺骗。让我们互相鼓舞。”\r\n\r\n二月用一块白布遮蔽\r\n家家屋顶和门前空地\r\n孩子们，大家手拉手\r\n踏过雪堆去幼儿园\r\n护耳皮帽，小蝴蝶结\r\n就在Bounty广告旁边\r\n谁写下了涂鸦字印——\r\n“快把遗体交还母亲”\r\n是时候去打破诅咒\r\n洗净一百年的铜锈\r\n屠夫都会自食恶果\r\n逃不脱死亡的眼窝\r\n永恒呼唤去它的怀抱\r\n未来不再有花里胡哨\r\n我们刻薄的记忆之肉\r\n对僵化停滞不屑一顾\r\n魔鬼忙于兜售赃物\r\n透过广播妖言惑众\r\n全都只关心无罪托词\r\n把敌对势力名单罗织\r\n如果冷漠把你抽打\r\n如同波罗的海浪涛\r\n记住有氧运动的益处\r\n相信一切都会变好\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n喔，虐杀你的人将要当上将军\r\n可难道抢走尸体者最终会得胜？\r\n不，命运和力量眷顾的才能被听取\r\n有收买不了的法庭，真正的法庭：\r\n人潮汹涌流动，给你献花致敬\r\n大地各处，谁身上有希望的微光：\r\n就让他拥抱你，送你去太空飞翔\r\n当光明回照，当坚冰都退去：\r\n你注定要得到那般幸福的荣光\r\n\r\n永远的怀念——飞鸟迎面\r\n穿梭于时光之间\r\n预言之鸟，来自未来\r\n穿越过去抵达现在\r\n在吾辈生活之地，信仰之地\r\n廖沙，我们不惧黑暗，不会放弃\r\n永远怀念——蜡烛的烟\r\n袅袅升起，不会被抹去\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n求主在有福的安眠中，赐予祢故世的仆人，新近遇害离世的阿历克谢之灵永远安息，并使他得永远怀念\r\n\r\n永远的怀念\r\n永远的怀念\r\n永远的怀念\r\n\r\n一切都有尽头，人民从地狱催眠里醒来\r\n廖哈的视频都将成为不朽的经典\r\n纳瓦利内街48号会是谁家的门牌\r\n或许是学校，或是博物馆和热门景点\r\n我不能以他的名义宣称什么事情\r\n彼此交集只有转推、握手加几条短信\r\n但若廖哈明白自己将被杀害，他会立刻\r\n就地开始创造些什么东西——新的组合\r\n所以，朋友们，要理智，我们现在是继承人\r\n我们的国家被偷走，不行，这群恶之敝屣\r\n我们大家都一起努力——把它带回和平\r\n我们有过一个这么聪明的人，但多么可惜\r\n永远的怀念\r\n\r\n当我们中的正直者死于非命，悲悼或颂歌，悲伤或欢乐——全都一样。何以那里？何以现在？何以我们呼喊“他遇害了”？天空沉默不语。他过去是谁已无法改变，将来是谁——取决于吾辈。铭记他的遇害，我们如何选择生活，将成为这死亡的意义。\r\n\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n脱出肉身后，他在天上嘲笑刽子手——\r\n上帝奴仆阿列克谢在这方面不是新手*\r\n魔鬼走狗在下面巴结，口水直流——\r\n一份详细报告递往自己主人的长桌\r\n讲述他们如何完成计划；如何努力折磨；\r\n在镣铐之外如何再添上一副枷锁；\r\n何以久久挥发不去化学武器的痕迹；\r\n他强大的战斗英灵何以无法消弭\r\n如今他立刻无所不在，占满所有空间\r\n活在百万头脑中，永远与我们同在\r\n仿佛道德音叉，为基本原则做调谐——\r\n他尽了自己的义务，没有躲在国外\r\n你也收起眼泪，伙计，悲伤何时是个终了：\r\n“嘤嘤，国家要剥夺房产，办不下居留证”\r\n你本可以做得更多，而不只是发牢骚\r\n他虽已逝，可我们幸存——未来如何取决于我们\r\n毕竟……\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n从小熟知的圣经寓言故事\r\n道理简单却为何没人愿听？\r\n如果王国早已变成监室，\r\n你又怎么能把童话相信？\r\n如今并非童话、英雄、先知之时……\r\n他只是一介凡人——并非先知！\r\n他相信，若是在黑暗中迷失\r\n正是脚步能把人引向光亮！\r\n追随梦想，成为吾辈的榜样！\r\n刺破无比痛苦的黑暗时代\r\n如同福音，如希望，如信仰\r\n那声熟悉到让人心痛的“嗨！”\r\n惩戒室的刺骨寒冷用微笑化解\r\n三言两语讲清一个简单道理：\r\n不撒谎！不害怕！去战斗！要团结！\r\n永远不能灰心丧气！\r\n\r\n囹圄四壁困不住英灵探求\r\n冰冷的尘土无法掩盖记忆\r\n既然并不存在黑暗的源头\r\n意味着这光明终将会满溢\r\n我们身上映射出他的光芒——\r\n我们彼此彰显都归功于他\r\n走出黑暗会让眼睛被灼伤\r\n但除了启蒙我们别无他法\r\n\r\n“邪恶若想获胜，只需要正义之士毫无作为。不能，不要放弃。终有一日，将会有不曾有过的，而不会再有曾有过的。”",
      "data": {
        "title": "但除了启蒙我们别无他法",
        "date": "2024-10-21 22:05:10",
        "tags": [
          "随机说话"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dan-chu-liao-qi-meng-wo-men-bie-wu-ta-fa"
    },
    {
      "content": "## 10.1\r\n\r\n### [gym104922I](https://codeforces.com/gym/104922/problem/I)\r\n\r\nwqs 二分，维护 dp 值和取到 dp 值的 $k$ 的区间。倒序记录方案，要满足能落到合法区间中。\r\n\r\n## 10.2\r\n\r\n### [AT_s8pc_5_h](https://www.luogu.com.cn/problem/AT_s8pc_5_h)\r\n\r\n模拟赛 T3。\r\n\r\n建子序列自动机，DAG 上 dp 并按字典序出边贪心记录方案。DAG 链剖分。$u$ 向 $2f_v\\ge f_u$ 的 $v$ 连边，形成内向树。重边倍增，轻边跳一次 $f_u$ 减半。\r\n\r\n## 10.3\r\n\r\n### [模拟赛 T2](http://goj.wiki/d/Union2024/p/P1146)\r\n\r\n拆贡献为跨过 $i$ 时的答案，枚举有 $j$ 个 $\\le i$。\r\n\r\n## 10.5\r\n\r\n### [Q9449](https://qoj.ac/contest/1804/problem/9449)\r\n\r\n从后往前加，维护拓展域并查集。每次合并后，需要能凑出和为 $n$。拓展域限制 $siz_i,siz_j$ 只能选一个，维护 $a_i-b_j$。bitset 二进制分组，本质不同数 $O(\\sqrt n)$ 级别。复杂度 $O(\\frac{\\sqrt nn^2}{w})$。\r\n\r\n## 10.8\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1151)\r\n\r\n$u\\to v$ 等价与 a 中的出现顺序 $u\\to u+1$ 先于 $u+1\\to u+2$。设 $dp_{i,j}$ 表示前 $i$ 个，第 $i$ 个排名为 $j$，前缀和维护。\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1152)\r\n\r\n$l$ 最远的合法 $r$ 满足前缀 ```(``` 加 ```?``` 减 ```)``` 大于 $0$。限制为 $g_r\\le l\\le r\\le f_l$，维护奇偶的区间历史和单点修改线段树扫描线。\r\n\r\n## 10.10\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1160)\r\n\r\n计算已知当前可能为 $s$ 的答案，每次分裂，只用算 $k$ 次。将每个起点的状态压为一个数，复杂度 $O(nmk)$。\r\n\r\n## 10.11\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1164)\r\n\r\n建生成树的等效链，线段树 $t_{0/1,0/1}$维护区间 $l$ 和 $r$ 是否与 $0$ 联通。\r\n\r\n### [HDU6757 Hunting Monsters](http://goj.wiki/d/Union2024/p/P1163)\r\n\r\n模拟赛 T3。\r\n\r\n$a_i\\le b_i$ 的在 $a_i>b_i$ 前，$a_i\\le b_i$ 按 $a_i$ 升序i，$a_i>b_i$ 按 $b_i$ 降序。$a_i\\le b_i$ 排序后取前 $k$ 个，$a_i>b_i$ 部分设 $dp_{i,j}$ 表示考虑 $[i,n]$ 取 $j$ 个的最小初始值，有决策单调性，分治合并。\r\n\r\n优化后半部分 dp，$dp_{i,j}=min(a_i+max(f_{i-1,j-1}-b_i,0),f_{i-1,j})$。对于 $f_{i-1,j0}\\ge b_i$，$f_{i-1}$ 下凸，优先队列维护斜率，小于 $b_i$ 的部分不会在更新，大于 $b_i$ 的部分等价于加入一段斜率为 $a_i$ 的线段。 \r\n\r\n### [arc104e](https://www.luogu.com.cn/problem/AT_arc104_e)\r\n\r\n$n^n$ 枚举排名，转换为长为 $m$ 的单调递增序列，每个数有上界的方案数。离散化后设 $dp_{i,j}$ 表示第 $i$ 个数在第 $j$ 段，枚举之前最近的不在同一段的是第 $k$ 个数在第 $l$ 段。\r\n\r\n## 10.12\r\n\r\n### [【5校day5】木棍](http://goj.wiki/d/Union2024/p/TNOI0012)\r\n\r\n差分约束，把线段缩为单点，要求两点间距离大于 $k$。将关键点离散化。数据结构模拟 SPFA $n$ 轮。\r\n\r\n$s_p\\le s_q+\\lceil\\frac{p-q}{k}\\rceil$，维护模 $k$ 为下标的 $\\min dis_q+\\frac{q}{k}$。$s_{y_i}\\le s_{x_i-1}+c_i$。$s_{a_i-1}\\le s_{b_i}+f(a_i,b_i)$，从后往前扫 $l$，$r$ 处线段树维护 $dis_r-f(l,r)$。\r\n\r\n### [The 3rd Universal Cup. Stage 12](https://qoj.ac/contest/1807)\r\n\r\n见 [The 3rd Universal Cup 做题记录 (2)](https://yhddd123.github.io/post/the-3rd-universal-cup-zuo-ti-ji-lu-2/)。\r\n\r\n## 10.14\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1168)\r\n\r\n只计算同时出现 $1,2,3$ 的序列。令 $1$ 为全局众数，在同时出现 $1,2,3$ 的子段中 $1$ 都是众数。即维护前缀和与 $\\max s_{j-1}[s_j=2]$ 和 $\\max s_{j-1}[s_j=2]$ 的差。\r\n\r\n## 10.15\r\n\r\n### [模拟赛 T3](https://qoj.ac/contest/459/problem/3040)\r\n\r\n移动 $d$ 的代价为 $\\lfloor\\frac{d}{2}\\rfloor(C+4)+(d \\bmod 2)(C+3)+x$。 额外的代价为跨越的点。对于下标奇偶性相同的终点，对应的起点单调。设 $dp_{i,j}$ 表示前 $i$ 个起点 $j$ 个终点为奇数的最小代价 dp。\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1172)\r\n\r\n按 [ [JOISC2022] 洒水器](https://www.luogu.com.cn/problem/P9527) 的方式将距离为 $r$ 拆成 $u$ 子树内离 $u$ 为 $r$。其余部分正常线段树打 tag，维护 $r+1$ 个 tag，表示离区间最小深度差 $i$ 的点要加这个 tag，还有一个 tag 维护子树加，对整个区间作用。\r\n\r\n## 10.16\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1175)\r\n\r\n按 $b_i$ 降序做。按 $b_i$ 升序排序，设 $dp_{i,j}$ 表示前 $i$ 人做 $j$ 个，$dp_{i,j}=max(dp_{i-1,j-1},b_i)+a_i$。下凸，维护斜率，基本同上面那道。\r\n\r\n## 10.17\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1180)\r\n\r\n平面图最短路转最小割。在流了最短路的基础上，加入流量 $+\\infty$ 代价为 $1$ 的边，加入超级源点向源点连流量为 $k$ 的边，跑费用流。\r\n\r\n### [P8861](https://www.luogu.com.cn/problem/P8861)\r\n\r\n树状数组维护左右端点的 $\\sum cnt_i$ 和 $\\sum cnt_i\\times i$。线段拍到猫树上，优先队列和并查集维护，每次向中间合并或把一个线段推到下一层。复杂度 $O(n\\log^2 n)$。\r\n\r\n## 10.29\r\n\r\n### [【模板】基于值域预处理的快速离散对数](https://www.luogu.com.cn/problem/P11175)\r\n\r\n记使得 $g^x\\equiv n\\pmod{mod}$ 的最小非负 $x$ 为 $\\log n$，有 $\\log ab=\\log a+\\log b$。\r\n\r\n令 $n=\\sqrt{mod}+1$，预处理 $n$ 以内的 $\\log x$。线性筛，只需要 bsgs 求出 $n$ 以内 $\\frac{n}{\\ln n}$ 个质数的 $\\log p$，就可以 $O(n)$ 求出 $n$ 以内所有 $\\log x$。哈希表，预处理时 $B$ 次插入，$\\frac{n}{\\ln n}$ 次 $\\frac{mod}{B}$ 的查询，取 $B=\\sqrt{\\frac{n\\times mod}{\\ln n}}$。\r\n\r\n查询 $\\log a$ 时，如果 $a\\le \\sqrt{mod}+1$ 直接得出，否则有 $b\\times a+c=mod$，$b\\le \\sqrt{mod}$。$\\log a=\\log \\frac{-c}{b}=\\log(c\\times -1)-\\log b=\\log (mod-1)+\\log c-\\log b$。又应为有 $(b+1)\\times a+c=mod+a$，$\\log a=\\log \\frac{a-c}{b+1}=\\log(a-c)-\\log (b+1)$。$\\log b$ 或 $\\log(b+1)$ 已知，$\\log (mod-1)$ 提前算，$\\min(c,a-c)\\le \\frac{a}{2}$，选 $c$ 和 $a-c$ 较小的一边递归可以做到 $\\log {mod}$ 查询。\r\n\r\n复杂度 $O(\\frac{mod^{\\frac{3}{4}}}{\\log^{\\frac{1}{2}}mod}+q\\log {mod})$。\r\n",
      "data": {
        "title": "2024.10 做题记录",
        "date": "2024-10-18 22:11:46",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "202410-zuo-ti-ji-lu"
    },
    {
      "content": "The 3rd Universal Cup 做题记录\r\n\r\nStage 0 - Stage 9：[The 3rd Universal Cup 做题记录 (1)](https://yhddd123.github.io/post/the-3rd-universal-cup-zuo-ti-ji-lu-1/)\r\n\r\nStage 10 - Stage 19：[The 3rd Universal Cup 做题记录 (2)](https://yhddd123.github.io/post/the-3rd-universal-cup-zuo-ti-ji-lu-2/)\r\n\r\n[Stage 0: Trial Contest](https://qoj.ac/contest/1695) ADFGHIJM\r\n\r\n[Stage 1: St. Petersburg](https://qoj.ac/contest/1696) ACDGHJKNO\r\n\r\n[Stage 2: Zielona Góra](https://qoj.ac/contest/1699) ACDEGH\r\n\r\n[Stage 4: Hongō](https://qoj.ac/contest/1738) BCDEKLN\r\n\r\n[Stage 5: Moscow](https://qoj.ac/contest/1741) ABEFGIKM\r\n\r\n[Stage 6: Osijek](https://qoj.ac/contest/1762) ABCDHIJKL\r\n\r\n[Stage 7: Warsaw](https://qoj.ac/contest/1774) ABEGKL\r\n\r\n[Stage 8: Cangqian](https://qoj.ac/contest/1780) BCDEFHIJLM\r\n\r\n[Stage 9: Xi'an](https://qoj.ac/contest/1784) AEFGHIJN\r\n\r\n## [The 3rd Universal Cup. Stage 0: Trial Contest](https://qoj.ac/contest/1695)\r\n\r\n### [A. Arrested Development](https://qoj.ac/contest/1695/problem/8768)\r\n\r\n$O(n^2V)$ dp 可过。\r\n\r\n### [D. Dihedral Group](https://qoj.ac/contest/1695/problem/8771)\r\n\r\n一定是正序或倒序的连续区间。\r\n\r\n### [F. Magic Bean](https://qoj.ac/contest/1695/problem/8773)\r\n\r\n可以只交换一个环的 $4$ 号和另一个环的 $1$ 号。\r\n\r\n### [G. Manhattan Walk](https://qoj.ac/contest/1695/problem/8774)\r\n\r\n每个位置独立。设 $dp_{i,j}$ 为 $(i,j)$ 去到终点的期望，$dp_{i+1,j},dp_{i,j+1}$ 分别为 $a,b$，$a<b$。如果 $a+p\\le b$ 一定走 $a$，否则按等待时间划分走 $a$ 还是 $b$。\r\n\r\n```cpp\r\nint n,m;\r\ndouble dp[maxn][maxn],p;\r\nvoid work(){\r\n\tn=read();m=read();p=read();\r\n\tdp[n][m]=0.0;\r\n\tfor(int i=n;i;i--){\r\n\t\tfor(int j=m;j;j--){\r\n\t\t\tif(i==n&&j==m)continue;\r\n\t\t\telse if(i==n)dp[i][j]=dp[i][j+1]+p/4.0;\r\n\t\t\telse if(j==m)dp[i][j]=dp[i+1][j]+p/4.0;\r\n\t\t\telse{\r\n\t\t\t\tdouble a=dp[i][j+1],b=dp[i+1][j];\r\n\t\t\t\tif(a>b)swap(a,b);\r\n\t\t\t\tif(b>=a+p)dp[i][j]=a+p/4.0;\r\n\t\t\t\telse{\r\n\t\t\t\t\tdp[i][j]=a/2.0+(b-a)/(2*p)*(a+(b-a)/2.0)+(p-b+a)/(2*p)*b;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprintf(\"%.10lf\\n\",dp[1][1]);\r\n}\r\n```\r\n\r\n### [H. MountainCraft](https://qoj.ac/contest/1695/problem/8775)\r\n\r\n查询区间并。线段树维护区间最小值和区间最小值个数。\r\n\r\n### [I. Not Another Constructive!](https://qoj.ac/contest/1695/problem/8776)\r\n\r\n在 ```A``` 处计算前缀 ```N``` 和后缀 ```C``` 的乘积。设 $dp_{i,j,k,num}$ 为前 $i$ 个，前缀有 $j$ 个，后缀有 $k$ 个，能否有 $num$ 个子序列。bitset 优化。\r\n\r\n### [M. Training, Round 2](https://qoj.ac/contest/1695/problem/8780)\r\n\r\n记录前 $i$ 个题能否达到 $(j,k)$。每个 $(j,k)$ 只会更新一次。set 维护。\r\n\r\n```cpp\r\nint n,a,b,ans;\r\nset<int> s[maxn];\r\nbool vis[maxn][maxn];\r\nvoid work(){\r\n\tn=read();a=read(),b=read();\r\n\ts[0].insert(0);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint la=read()-a,ra=read()-a,lb=read()-b,rb=read()-b;\r\n\t\tif(ra<0||rb<0)continue;\r\n\t\tla=max(la,0ll),ra=min(ra,n),lb=max(lb,0ll),rb=min(rb,n);\r\n\t\tvector<pii> tmp;\r\n\t\tfor(int j=la;j<=ra;j++){\r\n\t\t\tauto it=s[j].lower_bound(lb);\r\n\t\t\twhile(it!=s[j].end()&&(*it)<=rb){\r\n\t\t\t\ttmp.push_back({j,(*it)+1}),tmp.push_back({j+1,(*it)});\r\n\t\t\t\tvis[j][(*it)]=1;\r\n\t\t\t\tit=s[j].erase(it);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(pii p:tmp)if(!vis[p.fi][p.se]){\r\n\t\t\tans=max(ans,p.fi+p.se);\r\n\t\t\ts[p.fi].insert(p.se);\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n## [The 3rd Universal Cup. Stage 1: St. Petersburg](https://qoj.ac/contest/1696)\r\n\r\n### [A. Element-Wise Comparison](https://qoj.ac/contest/1696/problem/8781)\r\n\r\nbitset 维护 $f_{i,j}=a_i<a_j$。每 $m$ 个点划一个段，统计跨过段的答案，维护一段的后缀 or。\r\n\r\n```cpp\r\nint n,m,a[maxn],p[maxn],ans;\r\nbitset<maxn> f[maxn],g[maxn],s;\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read(),p[a[i]]=i;\r\n\tfor(int i=1;i<=n;i++)f[i].set(i);\r\n\tfor(int i=n;i;i--)f[p[i]]|=f[p[i+1]];\r\n\tfor(int i=n;i;i--)f[i]&=s,s.set(i);\r\n\tfor(int i=1;i<=n;i+=m){\r\n\t\tfor(int j=1;j<=m;j++)g[j].reset();\r\n\t\tif(i+m-1>n)break;\r\n\t\tg[m]=f[i+m-1];\r\n\t\tfor(int j=i+m-2;j>=i;j--)g[j-i+1]=g[j-i+2]&(f[j]<<(i+m-1-j));\r\n\t\ts.set();\r\n\t\tfor(int j=i;j<=i+m-1&&j+m-1<=n;j++){\r\n\t\t\tans+=(s&g[j-i+1]).count();\r\n\t\t\tif(j+m<=n)s&=f[j+m]>>(j-i+1);\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [C. Cherry Picking](https://qoj.ac/contest/1696/problem/8783)\r\n\r\n从大往小加，线段树维护区间前缀后缀和最大连续 $1$。\r\n\r\n### [D. Dwarfs' Bedtime](https://qoj.ac/contest/1696/problem/8784)\r\n\r\n在 $0$ 时刻先每个问一次，然后每隔 $49,48,\\dotsb ,1$ 问一次，问到状态翻转就挂到 $12$ 小时后连续的问。\r\n\r\n### [G. Unusual Case](https://qoj.ac/contest/1696/problem/8787)\r\n\r\n随机一个点开始找，当前找到 $a_1,\\dotsb,a_k$，如果找不到新的出边，那么 $a_k$ 连向 $a_p$，将路径改为 $a_1\\to\\dotsb\\to a_{p-1}\\to a_p\\to a_k\\to a_{k-1}\\dotsb\\to a_{p+1}$。据题解说是 $O(n)$ 的。\r\n\r\n```cpp\r\nint n,m,k;\r\nset<pii> s;\r\nvector<int> e[maxn];\r\nmt19937 rnd(time(0));\r\nint id[maxn],tp;\r\nbool vis[maxn];\r\nvoid work(){\r\n\tn=read();m=read();k=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tif(u>v)swap(u,v);\r\n\t\ts.insert({u,v});\r\n\t}\r\n\twhile(k--){\r\n\t\tfor(int i=1;i<=n;i++)vis[i]=0,e[i].clear();\r\n\t\tid[tp=1]=rnd()%n+1;vis[id[1]]=1;\r\n\t\tfor(auto[x,y]:s)e[x].pb(y),e[y].pb(x);\r\n\t\twhile(tp<n){\r\n\t\t\tif(rnd()&1)reverse(id+1,id+tp+1);\r\n\t\t\tint u=id[tp];bool fl=0;\r\n\t\t\tshuffle(e[u].begin(),e[u].end(),rnd);\r\n\t\t\tfor(int v:e[u])if(!vis[v]){\r\n\t\t\t\tvis[v]=fl=1;id[++tp]=v;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif(fl)continue;\r\n\t\t\tfor(int i=1;i<=tp;i++)if(id[i]==e[u].back()){\r\n\t\t\t\treverse(id+i+1,id+tp+1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int i=1;i<=tp;i++)printf(\"%lld \",id[i]);puts(\"\");\r\n\t\tfor(int i=1;i<tp;i++)s.erase({min(id[i],id[i+1]),max(id[i],id[i+1])});\r\n\t}\r\n}\r\n```\r\n\r\n### [H. Page on vdome.com](https://qoj.ac/contest/1696/problem/8788)\r\n\r\n答案为 $\\min(n+1,10)$。\r\n\r\n### [J. First Billion](https://qoj.ac/contest/1696/problem/8790)\r\n\r\n对 $a_i\\bmod B$ 做 bitset 背包，还原方案时如果既可以选也可以不选，就随一个。取 $B=2.5\\times 10^6$。\r\n\r\n```cpp\r\nint n,a[maxn];\r\nint B=2500000;\r\nbitset<2500000> dp[maxn];\r\nmt19937 rnd(1);\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tdp[0][0]=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tdp[i]=(dp[i-1]<<(a[i]%B))|dp[i-1]|(dp[i-1]>>(B-a[i]%B));\r\n\t}\r\n\twhile(1){\r\n\t\tvector<int> id;\r\n\t\tfor(int i=n,s=0;i;i--){\r\n\t\t\tif(dp[i-1][s]&&dp[i-1][(s-a[i]%B+B)%B]&&(rnd()&1))id.pb(i),s=(s-a[i]%B+B)%B;\r\n\t\t\telse if(!dp[i-1][s])id.pb(i),s=(s-a[i]%B+B)%B;\r\n\t\t}\r\n\t\tint sum=0;for(int i:id)sum+=a[i];\r\n\t\tif(sum==1e9){\r\n\t\t\tprintf(\"%lld \",id.size());for(int i:id)printf(\"%lld \",i);\r\n\t\t\treturn ;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n也可以分为若干块，块内折半，块间选绝对值前 $k$ 小合并。对不同块取不同 $k$。\r\n\r\n### [N. (Un)labeled graphs](https://qoj.ac/contest/1696/problem/8794)\r\n\r\n$\\log n$ 个点维护每个点的编号，把 $\\log n$ 个点连成一条链。剩下 $3$ 个点。取 $a$ 为度数最大的点，$b$ 标记所有的 $n$ 个点，$c$ 是唯一不连 $a$ 的点，标记 $b$ 和 $\\log n$ 个点的链头。\r\n\r\n## [The 3rd Universal Cup. Stage 2: Zielona Góra](https://qoj.ac/contest/1699)\r\n\r\n### [A. Interesting Paths](https://qoj.ac/contest/1699/problem/8517)\r\n\r\n正反 dfs，找到可能在 $1\\to n$ 上的点和边，答案为 $m-n+2$。若一条路径经过 $x$ 个之前没经过的点，则会经过 $x+1$ 条之前没经过的边。一定能经过所有可能在 $1\\to n$ 上的点和边。\r\n\r\n### [C. Radars](https://qoj.ac/contest/1699/problem/8519)\r\n\r\n能覆盖矩阵等价于能覆盖 $4$ 个角落，状压 $4$ 个角落是否被覆盖。\r\n\r\n### [D. Xor Partitions](https://qoj.ac/contest/1699/problem/8520)\r\n\r\n$dp_i=\\sum dp_j\\times (s_i\\oplus s_j)$。按位拆开，$dp_i=\\sum_j 2^j\\sum dp_j[(s_i\\oplus s_j) 第 j 位为 1]$。维护 $sum_{j,0/1}$，表示当前 $s_i$ 第 $j$ 位为 $1$ 的 $dp_i$ 之和。\r\n\r\n### [E. Pattern Search II](https://qoj.ac/contest/1699/problem/8521)\r\n\r\n$ans\\le 3n$。最大的 $S_k$ 是 $O(\\log n)$ 级别的。设 $pre_{k,i},suf_{k,i}$ 表示在 $S_k$ 中从 $i$ 出发向前向后能匹配多长的 $t$，需要多长的 $s$，仿 $f_i=f_{i-1}+f_{i-2}$ 合并。\r\n\r\n```cpp\r\nint n,m=30,ans=inf;\r\nchar s[maxn];\r\nstruct nd{\r\n\tint len;\r\n\tpii pre[maxn],suf[maxn];\r\n}f[32];\r\nnd merge(nd u,nd v){\r\n\tnd res;res.len=u.len+v.len;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tres.suf[i]=u.suf[i].fi==n+1?u.suf[i]:make_pair(v.suf[u.suf[i].fi].fi,u.len+v.suf[u.suf[i].fi].se);\r\n\t\tres.pre[i]=v.pre[i].fi==0?v.pre[i]:make_pair(u.pre[v.pre[i].fi].fi,v.len+u.pre[v.pre[i].fi].se);\r\n\t\tif(u.pre[i].fi==0&&v.suf[i+1].fi==n+1)ans=min(ans,u.pre[i].se+v.suf[i+1].se);\r\n\t}\r\n\treturn res;\r\n}\r\nvoid work(){\r\n\tscanf(\"%s\",s+1);n=strlen(s+1);\r\n\tif(n==1){puts(\"1\");return ;}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(s[i]=='a'){\r\n\t\t\tf[1].pre[i]={i-1,1},f[1].suf[i]={i+1,1};\r\n\t\t\tf[0].pre[i]=f[0].suf[i]={i,0};\r\n\t\t}\r\n\t\telse{\r\n\t\t\tf[0].pre[i]={i-1,1},f[0].suf[i]={i+1,1};\r\n\t\t\tf[1].pre[i]=f[1].suf[i]={i,0};\r\n\t\t}\r\n\t}\r\n\tf[0].len=f[1].len=1;\r\n\tfor(int i=2;i<=m;i++)f[i]=merge(f[i-1],f[i-2]);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n### [G. Puzzle II](https://qoj.ac/contest/1699/problem/8523)\r\n\r\n可以两步交换指定的两个数，换掉较少的颜色。序列的变化形如平移的形式，平衡树维护。\r\n\r\n### [H. Weather Forecast](https://qoj.ac/contest/1699/problem/8524)\r\n\r\n二分答案，取 $a_i-x$ 前缀和的最长上升子序列和 $k$ 比较。\r\n\r\n剩下的待补。\r\n\r\n## [The 3rd Universal Cup. Stage 4: Hongō](https://qoj.ac/contest/1738)\r\n\r\n### [B. Black or White 2](https://qoj.ac/contest/1738/problem/9114)\r\n\r\n令 $k=\\min(k,nm-k)$，$n>m$。第 $1$ 行隔一个填一个，之后插空一次填 $(i,j)$ 和 $(i-1,j)$。多出来的填 $(n,m)$。\r\n\r\n### [C. Contour Multiplication](https://qoj.ac/contest/1738/problem/9115)\r\n\r\n$dp_{i,s}$ 为与 $popcount(s\\oplus t)=i$ 的所有 $t$ 的共同系数。依次枚举 $j$ 将 $dp_{i,s}\\to dp_{i-1}{s\\oplus 2^j}$。\r\n\r\n### [D. DRD String](https://qoj.ac/contest/1738/problem/9116)\r\n\r\n设 $dp_i$ 为长为 $i$ 且不存在 $s[1,j]=s[i-j+1,i],j<i-j+1$ 的方案数。前缀和转移。\r\n\r\n### [E. Equally Dividing](https://qoj.ac/contest/1738/problem/9117)\r\n\r\n只要 $sum\\bmod n=0$ 就有解。若 $m$ 为偶，每列交替升序降序；否则 $n$ 为奇，可以构造前 $3$ 列填 $[1,3n]$。\r\n\r\n### [K. Kth Sum](https://qoj.ac/contest/1738/problem/9123)\r\n\r\n升序排序，二分答案 $x$。对于每个 $i$ 可以 $O(n)$ 计算 $(i,j,k)$ 的答案。设阈值 $B$，前 $B$ 个的贡献 $O(nB)$ 计算。如果没超过 $k$，$B$ 的 $(B,j,k)$ 贡献 $\\le \\frac{k}{B}$。后边只需要前 $\\frac{k}{B}$ 小的 $(j,k)$ 对，$O(\\frac{k}{B}\\log n)$ 预处理。\r\n\r\n```cpp\r\nint n,k,B;\r\nint a[maxn],b[maxn],c[maxn];\r\npriority_queue<pii> q;\r\nint pos[maxn];\r\nint d[maxn*200],tp;\r\nint f(int x){\r\n\tint res=0;\r\n\tfor(int i=1,j=n;b[i]+c[1]<=x&&i<=n;i++){\r\n\t\twhile(b[i]+c[j]>x)j--;\r\n\t\tres+=j;\r\n\t}\r\n\treturn res;\r\n}\r\nbool check(int x){\r\n\tint sum=f(x-a[B]);\r\n\tif(sum*B>=k)return 1;\r\n\tfor(int i=1;i<B;i++){\r\n\t\tsum+=f(x-a[i]);\r\n\t\tif(sum>=k)return 1;\r\n\t}\r\n\tfor(int i=1,j=n;i<=tp&&j>B;i++){\r\n\t\twhile(j>B&&a[j]+d[i]>x)j--;\r\n\t\tsum+=j-B;\r\n\t\tif(sum>=k)return 1;\r\n\t}\r\n\treturn 0;\r\n}\r\nvoid work(){\r\n\tn=read();k=read();B=min(n,(int)sqrt(k/n)+1);\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<=n;i++)b[i]=read();\r\n\tfor(int i=1;i<=n;i++)c[i]=read();\r\n\tsort(a+1,a+n+1),sort(b+1,b+n+1),sort(c+1,c+n+1);\r\n\tfor(int i=1;i<=n;i++)q.push({-(b[i]+c[pos[i]=1]),i});\r\n\twhile(!q.empty()&&tp<k/B){\r\n\t\td[++tp]=-q.top().fi;\r\n\t\tint u=q.top().se;q.pop();\r\n\t\tif(pos[u]<n)q.push({-(b[u]+c[++pos[u]]),u});\r\n\t}\r\n\tint l=0,r=inf,res=inf;\r\n\twhile(l<=r){\r\n\t\tint mid=l+r>>1;\r\n\t\tif(check(mid))res=mid,r=mid-1;\r\n\t\telse l=mid+1;\r\n\t}\r\n\tprintf(\"%lld\\n\",res);\r\n}\r\n```\r\n\r\n### [L. Largest Triangle](https://qoj.ac/contest/1738/problem/9124)\r\n\r\n取相邻的 $a_i,a_{i+1},a_{i+2}$ 海伦公式计算。\r\n\r\n### [N. Number of Abbreviations](https://qoj.ac/contest/1738/problem/9126)\r\n\r\n对于 $l<r$ 要求 $s_l\\neq s_r$ 才能交换。\r\n\r\n## [The 3rd Universal Cup. Stage 5: Moscow](https://qoj.ac/contest/1741)\r\n\r\n###  [A. Counting Permutations](https://qoj.ac/contest/1741/problem/9130)\r\n\r\n模 $m1$ 和 $m2$ 相等的可以排列。\r\n\r\n### [B. Bookshelf Tracking](https://qoj.ac/contest/1741/problem/9131)\r\n\r\n在最后一次 ```R```  操作前维护属于前半边还是后半边。\r\n\r\n### [E. Building a Fence](https://qoj.ac/contest/1741/problem/9134)\r\n\r\n分类讨论先做哪些，剩下的部分填到哪里。所有方式取 min。\r\n\r\n### [F. Teleports](https://qoj.ac/contest/1741/problem/9135)\r\n\r\n设 $dp_{l,r}$ 为区间 $[l,r]$ 的答案，枚举 $k$ 翻转，每次要么拆成更小的两个区间要么从相等长度的区间转移而来。先做第一种转移，第二种转移是同层最短路。\r\n\r\n### [G. Exponent Calculator](https://qoj.ac/contest/1741/problem/9136)\r\n\r\n$e^x=\\sum_{n=0}^{\\infty}\\frac{x^n}{n!}$。每个 $n$ 要两次，$|x|$ 增大精度下降。计算 $e^{\\frac{x}{2^B}}$ 后平方 $B$ 次。取 $n=7,B=10$。\r\n\r\n### [I. Marks Sum](https://qoj.ac/contest/1741/problem/9138)\r\n\r\n在后 $2000$ 位一定存在前缀和 $\\bmod 2000=0/1$。 可以写为 $2000x+y$，$x\\le 1000$，传 $2x+y$ 即可。\r\n\r\n### [K. Train Depot](https://qoj.ac/contest/1741/problem/9140)\r\n\r\n区间加，求区间 max。线段树合并。注意到修改的特殊性，合并时如果存在 $tree_x=tag_x$ 就一定不优，返回 $v$，极大减小常数。否则需要递归到 $tree_u=tag_u$ 且 $tree_v=tag_v$ 再比较 $tree_u$ 和 $tree_v$，理论复杂度依然正确但是常数极大。\r\n\r\n### [M. Uniting Amoebas](https://qoj.ac/contest/1741/problem/9142)\r\n\r\n答案为 $\\sum a_i-\\max a_i$。\r\n\r\n## [The 3rd Universal Cup. Stage 6: Osijek](https://qoj.ac/contest/1762)\r\n\r\n### [A. Coprime Array](https://qoj.ac/contest/1762/problem/9167)\r\n\r\n特判 $gcd(s,x)=1$。除非 $s$ 为奇 $x$ 为偶，两步可行。否则多一个 $1$。随机第一个数，失败时对于一个 $x$ 的质因数 $p$ 有 $u\\bmod p=0$ 或 $(s-u)\\bmod p=0$，成功率为 $\\prod_{p|x}\\frac{p-2}{p}$。\r\n\r\n### [B. Square Locator](https://qoj.ac/contest/1762/problem/9168)\r\n\r\n设 B 坐标为 $(x,y)$，绕 A $(0,\\sqrt{OA})$  顺时针或逆时针旋转 $90$ 度得 D。联立解方程。\r\n\r\n### [C. -is-this-bitset-](https://qoj.ac/contest/1762/problem/9169)\r\n\r\n将 $dep_u\\le 12$ 的 $a_u$ 设为 $2^{20-dep_u+1}$，能表示出所有 $512$ 的倍数。对于 $dep_u>12$ 的 $u$ 设 $dp_{u,i}$ 为 $1\\to u$ 链上 $a_x$ 的背包模 $512$ 为 $i$ 最小和为多少。记录修改的位置减少空间。\r\n\r\n### [D. Cycle Game](https://qoj.ac/contest/1762/problem/9170)\r\n\r\n警示：一个 $3\\times 3$ 的全黑矩形也不合法。\r\n\r\n先最外层加一圈全为白。等价于时刻白色区域八连通且每个黑点都与一个白点八连通。线段树分治，初始一些边在一个前缀时间存在。到叶子时检查如果该点为黑与其八连通的黑点会不会无法与白点八连通。如果不删这个点，有些边重新合法。\r\n\r\n### [H. Game Design](https://qoj.ac/contest/1762/problem/9174)\r\n\r\n设 $dp_{i,j}$ 为前 $i$ 层且有 $j$ 条边跨过 $i$ 的方案数。枚举 $i$ 的出入边向前向后转移。\r\n\r\n### [I. Geometry Hacking](https://qoj.ac/contest/1762/problem/9175)\r\n\r\n在凹多边形是可能会死。构造 $(-1,-1)$，$(1,0)$，$(i+2,-i)$，$(0,1)$，面积都相等且最小。\r\n\r\n### [J. Non-Interactive Nim](https://qoj.ac/contest/1762/problem/9176)\r\n\r\n后手要使先手操作时存在二进制最高位的 $a_i$ 只有一个。即后手操作时存在二进制最高位的 $a_i$ 只有 $2$ 个，将其中一个变为 $0$。从高位往低位删即可。\r\n\r\n### [K. String and Nails](https://qoj.ac/contest/1762/problem/9177)\r\n\r\n每次删左下角即可，按 $(x,y)$ 排序。\r\n\r\n### [L. All-You-Can-Eat](https://qoj.ac/contest/1762/problem/9178)\r\n\r\n维护当前选的 $sum$，$[0,200)$ 的集合，$[200,400)$ 的集合，$[400,600)$ 的集合。$sum>600$ 一定合法，否则每次加入 $x$ 时贪心调整三个集合。\r\n\r\n## [The 3rd Universal Cup. Stage 7: Warsaw](https://qoj.ac/contest/1774)\r\n\r\n### [A. Bus Analysis](https://qoj.ac/contest/1774/problem/9220)\r\n\r\n代价 $2\\to 1,6\\to 3$。dp 套 dp。内层 dp，设 $dp_{i,j}$ 为前 $i$ 个点，代价为 $j$ 最长向后多远。只有 $mn,mn+1,mn+2$ 的 dp 值有用。外层 dp 设 $f_{i,x,y,z}$ 为前 $i$ 个点，$mn,mn+1,mn+2$ 的 dp 值分别在 $x,y,z$。当 mn 增加时增加答案。除了最开始只有 $a+20\\le b,b+20\\le c$ 的三元组有用。\r\n\r\n```cpp\r\nint n,a[maxn],ans;\r\nint dp[2][76][76][76],pw[maxn],f[6],cur;\r\nvoid inc(int &u,int v){((u+=v)>=mod)&&(u-=mod);}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tpw[0]=1;for(int i=1;i<=n;i++)inc(pw[i]=pw[i-1],pw[i-1]);\r\n\tdp[0][0][0][0]=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint d=a[i]-a[i-1];\r\n\t\tmems(dp[i&1],0);\r\n\t\tif(i==1){\r\n\t\t\tint a=0,b=0,c=0;\r\n\t\t\tint aa=max(0ll,a-d),bb=max(0ll,b-d),cc=max(0ll,c-d);\r\n\t\t\tf[0]=aa,f[1]=bb,f[2]=cc,f[3]=f[4]=f[5]=0;\r\n\t\t\tfor(int j=0;j<5;j++){\r\n\t\t\t\tf[j+1]=max(f[j+1],f[j]+20);\r\n\t\t\t\tif(j+3<6)f[j+3]=max(f[j+3],f[j]+75);\r\n\t\t\t}\r\n\t\t\tfor(int j=1;j<=5;j++)f[j]=max(f[j],f[j-1]);\r\n\t\t\tinc(dp[i&1][f[0]][f[1]][f[2]],dp[cur][a][b][c]);\r\n\t\t\tint p=0;while(!f[p])p++;\r\n\t\t\t(ans+=dp[cur][a][b][c]*pw[n-i]%mod*p)%=mod;\r\n\t\t\tinc(dp[i&1][f[p]][f[p+1]][f[p+2]],dp[cur][a][b][c]);\r\n\t\t}\r\n\t\tfor(int a=0;a<=75;a++){\r\n\t\t\tfor(int b=a+20;b<=75;b++){\r\n\t\t\t\tfor(int c=b+20;c<=75;c++)if(dp[cur][a][b][c]){\r\n\t\t\t\t\tint aa=max(0ll,a-d),bb=max(0ll,b-d),cc=max(0ll,c-d);\r\n\t\t\t\t\tf[0]=aa,f[1]=bb,f[2]=cc,f[3]=f[4]=f[5]=0;\r\n\t\t\t\t\tfor(int j=0;j<5;j++){\r\n\t\t\t\t\t\tf[j+1]=max(f[j+1],f[j]+20);\r\n\t\t\t\t\t\tif(j+3<6)f[j+3]=max(f[j+3],f[j]+75);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor(int j=1;j<=5;j++)f[j]=max(f[j],f[j-1]);\r\n\t\t\t\t\tinc(dp[i&1][f[0]][f[1]][f[2]],dp[cur][a][b][c]);\r\n\t\t\t\t\tint p=0;while(!f[p])p++;\r\n\t\t\t\t\t(ans+=dp[cur][a][b][c]*pw[n-i]%mod*p)%=mod;\r\n\t\t\t\t\tinc(dp[i&1][f[p]][f[p+1]][f[p+2]],dp[cur][a][b][c]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcur^=1;\r\n\t}\r\n\tprintf(\"%lld\\n\",ans*2%mod);\r\n}\r\n```\r\n\r\n### [B. Missing Boundaries](https://qoj.ac/contest/1774/problem/9221)\r\n\r\n有不确定的端点先当成 $[p,p]$。按左端点排序，记录最多最少能放多少 $(-1,-1)$。\r\n\r\n### [E. Express Eviction](https://qoj.ac/contest/1774/problem/9224)\r\n\r\n将横纵坐标都小于等于 $2$ 的障碍连边，等价于不存在左下边界到右上边界的路径。最小割。\r\n\r\n### [G. Game of Geniuses](https://qoj.ac/contest/1774/problem/9226)\r\n\r\n答案为最大的行的最小值。\r\n\r\n### [K. Routing K-Codes](https://qoj.ac/contest/1774/problem/9230)\r\n\r\n设 $f_u$ 为 $u$ 为根的和，$sum_u=\\sum_{v\\in subtree(u)} 2^{dep_v}$，$mxdep_u$ 为最大深度。换根 dp。\r\n\r\n### [L. Random Numbers](https://qoj.ac/contest/1774/problem/9231)\r\n\r\n$a_i$ 期望为 $\\frac{n}{2}$。所以检查长度为 $[1,B]$ 和 $[\\frac{n}{2}-B,\\frac{n}{2}+B]$ 的区间。\r\n\r\n## [The 3rd Universal Cup. Stage 8: Cangqian](https://qoj.ac/contest/1780)\r\n\r\n### [B. Simulated Universe](https://qoj.ac/contest/1780/problem/8933)\r\n\r\n设 $dp_{i,j,k}$ 为前 $i$ 个，$i$ 之前有 $j$ 个没匹配的祝福，向后能匹配 $k$ 个祝福是否可行。把 $k$ 压入状态，即 $dp_{i,j}$ 表示最大的 $k$ 是多少。\r\n\r\n### [C. Challenge NPC](https://qoj.ac/contest/1780/problem/8934)\r\n\r\n构造二分图，$1,4$ 为左，$2,3$ 为右，$1\\to 2,4\\to 3$。然后奇数为左向之前的右连边，偶数为右向除了 $2\\times i-1$ 之前的左连边。\r\n\r\n### [D. Puzzle: Easy as Scrabble](https://qoj.ac/contest/1780/problem/8935)\r\n\r\n一个格子如果有两个方向的要求则为矛盾格子，最后为空。队列维护矛盾格子向后推。\r\n\r\n### [E. Team Arrangement](https://qoj.ac/contest/1780/problem/8936)\r\n\r\n注意到划分数不多，搜出来每组大小后贪心检查。按组的大小从小往大，在一个人的左端点处将他的右端点加入优先队列，对每个组优先取队列中最小的。\r\n\r\n### [H. Permutation](https://qoj.ac/contest/1780/problem/8939)\r\n\r\n二分，时刻维护当前区间次大值位置。如果次大值和最大值在同一边则用一次，否则两次。每次将 $len$ 变为 $d\\times len$ 用 $1$ 次，$(1-d)\\times len$ 用 $2$ 次，取 $d=0.6$。\r\n\r\n### [I. Piggy Sort](https://qoj.ac/contest/1780/problem/8940)\r\n\r\n按位置之和排序，可以知道每张照片的先后顺序。$m>n$ 所以必然有一只猪出现在相邻照片的同一位置。枚举这个位置，检查是否存在这样一条直线经过 $m$ 个点。每只猪只可能出现在一条直线上。\r\n\r\n### [J. Even or Odd Spanning Tree](https://qoj.ac/contest/1780/problem/8941)\r\n\r\n找到最小生成树，只替换一条边，维护奇偶边权的路径最大值。\r\n\r\n### [L. Challenge Matrix Multiplication](https://qoj.ac/contest/1780/problem/8943)\r\n\r\n每次找一条从 $d_u>0$ 到 $d_v<0$ 的路径，$\\sum |in_u-out_u|$ 减少 $2$。对于一条路径，$a_i$ 的答案包含 $a_{i+1}$ 的答案。从 $v$ 到 $u$ 依次 bfs 计算答案增量，每个点只经过一次。\r\n\r\n```cpp\r\nint n,m;\r\nvector<int> e[maxn],g[maxn];\r\nint d[maxn];\r\nint st[maxn],tp;\r\nint ans[maxn];\r\nbool vis[maxn];\r\nqueue<int> q;\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\te[u].pb(v),g[u].pb(v);\r\n\t\td[u]++,d[v]--;\r\n\t}\r\n\tfor(int t=1;t<=60;t++){\r\n\t\tint p=0;for(int i=1;i<=n;i++)if(d[i]>0){p=i;break;}\r\n\t\tif(!p)break;\r\n\t\ttp=0;d[p]--;\r\n\t\twhile(d[p]>=0){\r\n\t\t\tst[++tp]=p;\r\n\t\t\tint v=e[p].back();e[p].pop_back();\r\n\t\t\tp=v;\r\n\t\t}\r\n\t\tst[++tp]=p;d[p]++;\r\n\t\tfor(int i=1;i<=n;i++)vis[i]=0;\r\n\t\tint num=0;\r\n\t\tfor(int i=tp;i;i--){\r\n\t\t\tq.push(st[i]),vis[st[i]]=1;\r\n\t\t\twhile(!q.empty()){\r\n\t\t\t\tint u=q.front();q.pop();;++num;\r\n\t\t\t\tfor(int v:g[u]){\r\n\t\t\t\t\tif(!vis[v])q.push(v),vis[v]=1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!ans[st[i]])ans[st[i]]=num;\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(!ans[i])ans[i]=1;\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld \",ans[i]);\r\n}\r\n```\r\n\r\n## [The 3rd Universal Cup. Stage 9: Xi'an](https://qoj.ac/contest/1784)\r\n\r\n### [A. An Easy Geometry Problem](https://qoj.ac/contest/1784/problem/9242)\r\n\r\n差分，哈希 $a_i$ 和反过来的 $k-a_i$。线段树维护哈希值。二分答案。\r\n\r\n### [E. Dominating Point](https://qoj.ac/contest/1784/problem/9246)\r\n\r\n出度最大的点 $u$ 为支配点。设 $u$ 连向 $S$，$T$ 连向 $u$。如果存在 $x$ 使得 $dis(u,x)>2$，那么 $x$ 连向所有 $S$ 和 $u$，$d_x>d_u$，矛盾。如果 $T$ 为空，无解。否则 $T$ 组成的子图的支配点 $uu$ 也符合条件。如果 $uu$ 不是指向 $T$ 所有点，递归下去得到 $uuu$。否则指向 $uu$ 且属于 $S$ 的部分的支配点符合条件。\r\n\r\n### [F. An Easy Counting Problem](https://qoj.ac/contest/1784/problem/9247)\r\n\r\nlucas 定理，等价于拆成 $p$ 进制数下每一位的组合数之积。设 $dp_{i,j}$ 为填到前 $i$ 位，组合数之积为 $j$，$cnt_k$ 为一位时的答案。$dp_{i,j}=\\sum_{kl\\mod p=j} dp_{i,k}\\times cnt_l$。满足结合律，快速幂优化。$p$ 为质数有原根，下标 $i$ 改为 $g^x\\bmod p=i$ 的 $x$，加法卷积。\r\n\r\n### [H. Elimination Series Once More](https://qoj.ac/contest/1784/problem/9249)\r\n\r\n从小到大加入，每次更新 $n$ 个点。\r\n\r\n### [I. Max GCD](https://qoj.ac/contest/1784/problem/9250)\r\n\r\n质因数分解，枚举答案。可能贡献的 $(i,j,k)$ 满足 $i,j$ 是相邻的 $v$ 的倍数，双指针最近的 $k$。共 $O(n\\sqrt n)$ 组。把 $(k,v)$ 挂在 $i$ 上，二位数点，做 $O(1)$ 插入 $O(\\sqrt n)$ 查询的分块。\r\n\r\n### [J. Graph Changing](https://qoj.ac/contest/1784/problem/9251)\r\n\r\n$>3$ 一次后无解，分讨 $n$ 和 $t$。",
      "data": {
        "title": "The 3rd Universal Cup 做题记录 (1)",
        "date": "2024-10-18 21:53:09",
        "tags": [
          "ucup",
          "做题记录",
          "acm"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "the-3rd-universal-cup-zuo-ti-ji-lu-1"
    },
    {
      "content": "The 3rd Universal Cup 做题记录\r\n\r\nStage 0 - Stage 9：[The 3rd Universal Cup 做题记录 (1)](https://yhddd123.github.io/post/the-3rd-universal-cup-zuo-ti-ji-lu-1/)\r\n\r\nStage 10 - Stage 19：[The 3rd Universal Cup 做题记录 (2)](https://yhddd123.github.io/post/the-3rd-universal-cup-zuo-ti-ji-lu-2/)\r\n\r\n[Stage 10: West Lake](https://qoj.ac/contest/1803) ACDGHKL\r\n\r\n[Stage 11: Sumiyosi](https://qoj.ac/contest/1804) ABCHIKLMO\r\n\r\n[Stage 12: Qinhuangdao](https://qoj.ac/contest/1807) ABCDEGHKLM\r\n\r\n[Stage 13: Sendai](https://qoj.ac/contest/1812) BCDEFGHIKMO\r\n\r\n[Stage 14: Harbin](https://qoj.ac/contest/1817) ABCDEGJKLM\r\n\r\n[Stage 15: Chengdu](https://qoj.ac/contest/1821) ABCDEGIJKL\r\n\r\n[Stage 16: Nanjing](https://qoj.ac/contest/1828) BCEFGIJKM\r\n\r\n[Stage 17: Jinan](https://qoj.ac/contest/1843) ABCDEFIJL\r\n\r\n## [The 3rd Universal Cup. Stage 10: West Lake](https://qoj.ac/contest/1803)\r\n\r\n### [A. Italian Cuisine](https://contest.ucup.ac/contest/1803/problem/9434)\r\n\r\n复制一遍，枚举 $i$ 维护右端点 $j$。要求 $(x,y)$ 到过 $(a_i,b_i),(a_j,b_j)$ 的直线距离大于 $r$ 或 等于 $r$ 且交点不在线段上，即 $\\angle OIJ$ 和 $\\angle OJI$ 至少一个为钝角，即两个向量的数量积小于零。要求 $(a_i,b_i),(x,y),(a_j,b_j)$ 的夹角和 $(a_i,b_i),(x,y),(a_{j-1},b_{j-1})$ 的夹角同正负，即两个向量的叉积同正负。三点坐标求面积 $S=\\frac{\\lvert x1y2+x2y3+x3y1-x1y3-x2y1-x3y2\\rvert}{2}$。\r\n\r\n### [C. Permutation](https://contest.ucup.ac/contest/1803/problem/9432)\r\n\r\n大概在 $\\frac{2}{3}n\\log n$ 级别。线段树维护区间 $[l,r]$ 有什么数，每次随机取出两个数，将左半边设为 $u$，右半边设为 $v$ 询问。如果 $ans=0/2$ 可以将 $u,v$ 放入左右儿子，否则如果这是第一次，就把 $u,v$ 放回去重来，否则一定找得到一个数 $x$，将某半边设为 $x$ 再问一遍。理论上是 $\\frac{3}{4}n\\log n$，加上剪枝次数就差不多刚好了，偶尔会超。\r\n\r\n![](https://yhddd123.github.io/post-images/1729259469582.png)\r\n\r\nupd：正解是已知 $u,v$ 在同半边后并查集将 $u,v$ 当作一个点继续做。\r\n\r\n### [D. Collect the Coins](https://contest.ucup.ac/contest/1803/problem/9427)\r\n\r\n按 $t_i$ 排序，二分答案 $x$。设 $dp_{i,j}$ 为前 $i$ 个询问，另一个人在询问 $j$。如果 $\\lvert p_i-p_{i-1}\\rvert\\le x\\times (t_i-t_{i-1})$，$dp_{i,j}$ 继承 $dp_{i-1,j}$。然后再考虑 $j$ 更新 $dp_{i,i-1}$。拆绝对值有 $p_i+xt_i\\ge p_j+xt_j$ 且 $p_i-ct_i\\le p_j-xt_j$。维护对应的 $mn$ 和 $mx$ 即可。\r\n\r\n### [G. Stop the Castle 2](https://qoj.ac/contest/1803/problem/9424)\r\n\r\n优先破坏两对车的障碍。枚举障碍，如果一个障碍能破坏一横一竖两对车，连边二分图匹配。其余的一次断一队车，set 维护是否存在一横或一竖相邻的车。\r\n\r\n### [H. Intersection of Paths](https://qoj.ac/contest/1803/problem/9416)\r\n\r\n按 $k$ 从大往小回答，不断加入两端的 siz 较小值符合 $k$ 的边。动态修改边权求直径。直径表示为欧拉序上连续的 $u,v,w$ 的 $dis_u-2dis_v+dis_w$，线段树维护区间加和式子的部分的最大值。\r\n\r\n### [K. Palindromic Polygon](https://contest.ucup.ac/contest/1803/problem/9417)\r\n\r\n复制一遍，设 $dp_{i,j,0/1/2}$ 为区间 $[i,j]$ 中选了 $i,j$ 且是回文串、除了 $i$ 是回文串，除了 $j$ 是回文串的最大面积。\r\n\r\n### [L. Cosmic Travel](https://qoj.ac/contest/1803/problem/9411)\r\n\r\n建 trie 树，对于每个节点求出异或上所有 $j\\in [0,2^d)$ 的 前 $k\\le siz$ 的和，可以由左右儿子推知。询问时在 $l,r$ 覆盖整个 $[0,2^d)$ 时回答。复杂度 $O(n\\log V)$。\r\n\r\n## [The 3rd Universal Cup. Stage 11: Sumiyosi](https://qoj.ac/contest/1804)\r\n\r\n### [A. Welcome to NPCAPC](https://qoj.ac/contest/1804/problem/9435)\r\n\r\n矩阵快速幂，预处理 $2^i$ 处的矩阵。\r\n\r\n### [B. Some Sum of Subset](https://qoj.ac/contest/1804/problem/9436)\r\n\r\n倒序背包，在第一次 $>m$ 处统计答案。预处理有 $i$ 个可以任选对 $j<i$ 的贡献系数。\r\n\r\n### [C. Solve with Friends](https://qoj.ac/contest/1804/problem/9437)\r\n\r\n枚举 A 做几个，预处理前缀和，按 $a_i-b_i$ 排序依次把 B 做改为 A 做。\r\n\r\n### [H. Music Game](https://qoj.ac/contest/1804/problem/9442)\r\n\r\n期望做 $\\prod \\frac{1}{p_i}$ 次，每个前缀都有概率失败，失败有代价。按 $t_u*(1-p_u)+(t_u+t_v)*p_u<t_v*(1-p_v)+(t_u+t_v)*p_v$ 排序。\r\n\r\n### [I. Left Equals Right](https://qoj.ac/contest/1804/problem/9443)\r\n\r\n直接 dp 前 $i$ 个选 $j$ 个和为 $s$，左右随便排列。\r\n\r\n### [K. Peace with Magic](https://qoj.ac/contest/1804/problem/9445)\r\n\r\n设 $dp_{i,j}$ 为前 $i$ 个，$h_i=j$ 的代价。前后缀 min 转移。\r\n\r\n### [L. Construction of Town](https://qoj.ac/contest/1804/problem/9446)\r\n\r\n先连成菊花，然后 $[2,n]$ 中两两连边。\r\n\r\n### [O. New School Term](https://qoj.ac/contest/1804/problem/9449)\r\n\r\n从后往前加，维护拓展域并查集。每次合并后，需要能凑出和为 $n$。拓展域的限制为 $siz_i,siz_j$ 只能选一个，维护 $a_i-b_j$ 的 01 背包。bitset 二进制分组，本质不同数 $O(\\sqrt n)$ 级别。复杂度 $O(\\frac{\\sqrt nn^2}{w})$。\r\n\r\n## [The 3rd Universal Cup. Stage 12: Qinhuangdao](https://qoj.ac/contest/1807)\r\n\r\n### [A. Balloon Robot](https://qoj.ac/contest/1807/problem/9450)\r\n\r\n可以找到一个起点 $p$ 使得从 $p$ 出发 $t_i$ 时在 $a_i$。贡献形如区间加一次函数，且只能在所有的 $p_i$ 和 $m$ 处取得最小值。离散化后差分。\r\n\r\n### [B. Expected Waiting Time](https://qoj.ac/contest/1807/problem/9451)\r\n\r\n设 $f_i$ 为长为 $2\\times i$ 的合法括号序列数，即卡特兰数 $\\frac{\\binom{2n}{n}}{n+2}$。枚举 $i$，$i$ 作为左端点的方案数为 $\\sum_{j=i+1}^{2\\times n} f_{j-i-1}f_{n-(j-i+1)}$，其他情况 $i$ 作为右端点。是一个前缀的形式，预处理前缀和。总代价除以方案数得期望。\r\n\r\n### [D. Graph Generator](https://qoj.ac/contest/1807/problem/9453)\r\n\r\n合并形如一颗树，有 $d_{fa}\\ge d_u$。令 $d_{fa}$ 最小的可行的 $fa$ 作为 $u$ 的父亲。从下往上检查答案，要求 $fa$ 的出边在 $u$ 子树中的数量等于 $siz_u$。\r\n\r\n### [E. String of CCPC](https://qoj.ac/contest/1807/problem/9454)\r\n\r\n加一个字符最多贡献为 $1$，最多只加一个字符。\r\n\r\n### [G. Numbers](https://qoj.ac/contest/1807/problem/9456)\r\n\r\n按二进制从高位到低位贪心，使用 python。\r\n\r\n### [H. Prime Set](https://qoj.ac/contest/1807/problem/9457)\r\n\r\n除了 $1+1=2$ 特例外，奇数向偶数连边，二分图匹配。先不加 $1$ 求出最大匹配，再加上 $1$ 匹配，最后剩下的 $1$ 两两匹配。\r\n\r\n### [K. Diversity and Variance](https://qoj.ac/contest/1807/problem/9460)\r\n\r\n令 $m=n-m$ 为保留的数。特判 $m=1$。答案一定为一段前缀加一段后缀，值相同的数要选字典序小的。按 $(a_i,i)$ 和 $(a_i,-i)$ 分别排序。方差拆为 $\\sum x_i^2$ 和 $\\sum x_i$ 相关，求出可能贡献答案的是那些前缀。两个方案的字典序比较时，分类讨论比较两边不重叠的区间的最小值。\r\n\r\n### [L. One-Dimensional Maze](https://qoj.ac/contest/1807/problem/9461)\r\n\r\n向左走 ```R``` 的数量和向右走 ```L``` 的数量的 min。\r\n\r\n### [M. Safest Buildings](https://qoj.ac/contest/1807/problem/9462)\r\n\r\n离原点近的一定不劣。离原点距离小于 $\\lvert R-2r\\rvert$ 的一样优，如果没有这样的点，离原点最近的点最优。\r\n\r\n## [The 3rd Universal Cup. Stage 13: Sendai](https://qoj.ac/contest/1812)\r\n\r\n### [B. Topological Sort](https://qoj.ac/contest/1812/problem/9477)\r\n\r\n枚举 $i$，找到 $p_j>p_i,j<i$ 的最大 $j$，要求 $j+1,\\dotsb,i-1$ 到 $i$ 不能没有边，如果不存在 $j$ 则为 $2^{i-1}$。\r\n\r\n### [C. Shift Puzzle](https://qoj.ac/contest/1812/problem/9478)\r\n\r\n乱搞冲过去的。\r\n\r\n倒序做把 T 的第 $m$ 列改为全 $1$，然后 S 通过第 $m$ 列不断调整。大常数写法对 $n$ 小有优势，两种写法拼起来。\r\n\r\n### [D. And DNA](https://qoj.ac/contest/1812/problem/9479)\r\n\r\n$m=0$ 时 $ans=1$，$m=1$ 时不存在 ```00``` 或 ```111```，建图 $01\\to 10,01\\to11,10\\to 01,11\\to 10$，矩乘快速幂维护一个点走 $n$ 步回到自己的方案数。$m$ 为偶数 $a_i$ 同奇偶，等于 $ans_{\\frac{m}{2}}+ans_{\\frac{m}{2}-1}$。否则最下一位与上面位独立，等于 $ans_1\\times ans_{\\frac{m-1}{2}}$。记搜。\r\n\r\n### [F. Min Nim](https://qoj.ac/contest/1812/problem/9481)\r\n\r\n$n$ 为奇或非最小值数量 $num$ 为奇先手赢。\r\n\r\n### [G. Count Pseudo-Palindromes](https://qoj.ac/contest/1812/problem/9482)\r\n\r\n对于 $[l,r]$，$i$ 是跨过 $l$ 或 $r$ 的最小/大的数。随机异或哈希，预处理 $f_i,g_i$ 表示前后缀 $sum_i$ 的出现次数。并查集从 $l_{a_i}$ 开始跳没有到过的点到 $r_{a_i}$，跳到的点是 $i$ 对 $l/r$ 有贡献。哈希表做到 $O(n)$。\r\n\r\n### [H. Maximize Array](https://qoj.ac/contest/1812/problem/9483)\r\n\r\n贪心取最大的且下标最小的。维护模 $k$ 的位置的后缀 min。\r\n\r\n### [I. Colored Complete Graph](https://qoj.ac/contest/1812/problem/9484)\r\n\r\n先问 $1$ 和 $2,\\dotsb,n$。维护红点集合和蓝点集合，每次各取出一个点 $u,v$，如果 $col(u,v)$ 为红就删掉 $v$，否则删掉 $u$，直到一个集合为空。$n-1+n-2$ 次。\r\n\r\n### [K. Random Mex](https://qoj.ac/contest/1812/problem/9486)\r\n\r\n来自 AT 官方题解。\r\n\r\n考虑组合意义：有 $0,\\dotsb ,m$ 个盒子，给第 $a_i$ 个盒子放一个球，找到一个编号小于最小空盒子编号的盒子将其中所有的球放入 $m$ 号盒子的方案数。即 $\\sum_{k=0}^mk\\times\\sum [mex(a)=k]$，即为答案。反过来，$n$ 个球分给 $m+1$ 个盒子，第 $m$ 个盒子不为空，存在至少一个空盒子，把第 $m$ 个盒子中的球放到编号最小的空盒子中。即 $(m+1)^n-m^n-(m+1)!S(n,m+1)$。$S(n,m)$ 为第二类斯特林数。\r\n\r\n### [M. Do Not Turn Back](https://qoj.ac/contest/1812/problem/9488)\r\n\r\n设 $dp_{t,u}$ 为时刻 $t$ 位置 $u$ 的答案，容斥掉 $u\\to v\\to u$ 和 $v\\to u\\to v\\to u$ 的情况，特判 $t=2$ 不存在一来一去一回。$dp_{t,u}=\\sum_{(u,v)\\in E} dp_{t-1,v}-(d_u-[t\\neq 2])\\times dp_{t-2,u}$。矩乘快速幂。\r\n\r\n### [O. Sub Brackets](https://qoj.ac/contest/1812/problem/9490)\r\n\r\n当两个线段交为奇数时存在矛盾。连边求最大独立集，等价于总数减最小覆盖集。\r\n\r\n## [The 3rd Universal Cup. Stage 14: Harbin](https://qoj.ac/contest/1817)\r\n\r\n### [A. Build a Computer](https://qoj.ac/contest/1817/problem/9519)\r\n\r\n类似线段树的结构，按不同长度分别线段树查询，完全包含一个区间就加上一个 $d$ 个点表示 $[0,2^d)$ 的结构。只有最短和最长的长度区间进入线段树查询，其余的直接在第一次返回。\r\n\r\n### [B. Concave Hull](https://qoj.ac/contest/1817/problem/9520)\r\n\r\n最优结构是凸包挖去一个凸包内的点和一条凸包上的边构成的三角形。有贡献的凸包内的点是凸包内的点的凸包上的点，且内层凸包上每个点贡献到外层凸包上的边是单调的。叉积计算。\r\n\r\n```cpp\r\nint n;\r\nstruct poi{\r\n\tint x,y;\r\n\tbool operator<(const poi&tmp)const{return x<tmp.x||(x==tmp.x&&y<tmp.y);}\r\n\tpoi operator-(const poi&tmp)const{return {x-tmp.x,y-tmp.y};}\r\n\tint operator*(const poi&tmp)const{return x*tmp.y-y*tmp.x;}\r\n};\r\nvector<poi> a;\r\nvector<int> tubao(vector<poi> a){\r\n\tif(a.size()==1)return vector<int>({0});\r\n\tif(a.size()==2)return vector<int>({0,1});\r\n\tvector<int> res;\r\n\tfor(int i=0;i<a.size();i++){\r\n\t\twhile(res.size()>1){\r\n\t\t\tint lst=res.back();res.pop_back();\r\n\t\t\tif((a[lst]-a[res.back()])*(a[i]-a[lst])>=0){res.pb(lst);break;}\r\n\t\t}\r\n\t\tres.pb(i);\r\n\t}\r\n\tint sz=res.size();\r\n\tfor(int i=a.size()-2;~i;i--){\r\n\t\twhile(res.size()>sz){\r\n\t\t\tint lst=res.back();res.pop_back();\r\n\t\t\tif((a[lst]-a[res.back()])*(a[i]-a[lst])>=0){res.pb(lst);break;}\r\n\t\t}\r\n\t\tres.pb(i);\r\n\t}\r\n\tres.pop_back();\r\n\treturn res;\r\n}\r\nbool vis[maxn];\r\nvoid work(){\r\n\tn=read();a.resize(n);\r\n\tfor(int i=0;i<n;i++)a[i]={read(),read()};\r\n\tsort(a.begin(),a.end());\r\n\tvector<int> res=tubao(a);\r\n\tvector<poi> b,c;\r\n\tfor(int i=0;i<n;i++)vis[i]=0;\r\n\tfor(int i:res)vis[i]=1,b.pb(a[i]);\r\n\tif(b.size()==n){puts(\"-1\");return ;}\r\n\tfor(int i=0;i<n;i++)if(!vis[i])c.pb(a[i]);\r\n\ta=c;c.clear();\r\n\tres=tubao(a);\r\n\tfor(int i:res)c.pb(a[i]);\r\n\tint m=c.size(),pos=0;\r\n\tfor(int i=1;i<m;i++)if((c[i]-b[0])*(c[i]-b[1])<(c[pos]-b[0])*(c[pos]-b[1]))pos=i;\r\n\tint ans=inf,sum=0;\r\n\tfor(int i=0;i<b.size();i++)sum+=b[i]*b[(i+1)%b.size()];\r\n\tfor(int i=0;i<b.size();i++){\r\n\t\twhile((c[pos]-b[i])*(c[pos]-b[(i+1)%b.size()])>(c[(pos+1)%m]-b[i])*(c[(pos+1)%m]-b[(i+1)%b.size()]))pos=(pos+1)%m;\r\n\t\tans=min(ans,(c[pos]-b[i])*(c[pos]-b[(i+1)%b.size()]));\r\n\t}\r\n\tprintf(\"%lld\\n\",sum-ans);\r\n}\r\n```\r\n\r\n### [C. Giving Directions in Harbin](https://qoj.ac/contest/1817/problem/9521)\r\n\r\n模拟，特判 $\\Delta x=\\Delta y=0$ 是要绕一圈。\r\n\r\n### [D. A Simple String Problem](https://qoj.ac/contest/1817/problem/9522)\r\n\r\n不妨令 $s$ 中存在答案字符串的一半及以上，翻转并交换 $s$ 和 $t$ 再做一遍。枚举答案长度 $len$，每隔 $len$ 取一个点 $i$，一定能经过答案字符串的一半上的一点，在讨论另一半对应的点在 $s_{i+len}$ 或 $t_{i+len-1}$，二分哈希求两串和 $s$ 串两个位置的 lcp 和 lcs。\r\n\r\n### [E. Marble Race](https://qoj.ac/contest/1817/problem/9523)\r\n\r\n按每个球在每个起点出发到零点的时间升序枚举。设 $f_i$ 表示有 $i$ 个球在零点右边的概率，$f_i=af_i+bf_{i-1}$。维护球 $i$ 经过零点的次数 $tim_i$，撤销 $a=n-tim_i,b=tim_i$，$tim_i$ 加 $1$，加入 $a=n-tim_i,b=tim_i$。\r\n\r\n### [J. New Energy Vehicle](https://qoj.ac/contest/1817/problem/9528)\r\n\r\n每次优先用下一个充电点近的电池，set 模拟。\r\n\r\n### [K. Farm Management](https://qoj.ac/contest/1817/problem/9529)\r\n\r\n要么操作最大的 $a_i$，收益 $(m-\\sum l_i)\\times \\max a_i$。要么操作较小的 $a_i$，然后不选这个 $a_i$，二分剩下的分到那些地方。\r\n\r\n### [L. A Game On Tree](https://qoj.ac/contest/1817/problem/9530)\r\n\r\n算方案数。对于 $e_1,\\dotsb,e_k$，贡献为 $\\sum |e_i|^2+2\\sum_{i<j} |e_i||e_j|$。维护 $s_u=\\sum_{v\\in subtree(u)} siz_v^2$，dfs 时维护贡献。\r\n\r\n```cpp\r\nint n,ans;\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nint siz[maxn],sum[maxn];\r\nvoid dfs(int u,int fa){\r\n\tsiz[u]=1,sum[u]=0;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);\r\n\t\t(ans+=2*sum[u]*sum[v])%=mod;\r\n\t\t(ans+=2*(n-siz[v])*(n-siz[v])%mod*(sum[v]+mod-siz[v]*siz[v]%mod))%=mod;\r\n\t\t(sum[u]+=sum[v])%=mod;siz[u]+=siz[v];\r\n\t}\r\n\t(sum[u]+=siz[u]*siz[u])%=mod;\r\n\t(ans+=siz[u]*siz[u]%mod*(n-siz[u])%mod*(n-siz[u]))%=mod;\r\n}\r\nvoid work(){\r\n\tn=read();ans=0;\r\n\tfor(int i=1;i<=n;i++)head[i]=0;tot=0;\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t}\r\n\tdfs(1,0);\r\n\tint ss=(n*(n-1)/2)%mod;ss=ss*ss%mod;\r\n\tans=ans*ksm(ss)%mod;\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```\r\n\r\n## [The 3rd Universal Cup. Stage 15: Chengdu](https://qoj.ac/contest/1821)\r\n\r\n### [A. Arrow a Row](https://qoj.ac/contest/1821/problem/9535)\r\n\r\n要求最后三个为 ```>>>```，第一个为  ```>```，至少有一个 ```-```。\r\n\r\n### [B. Athlete Welcome Ceremony](https://qoj.ac/contest/1821/problem/9536)\r\n\r\n$dp_{i,j,k}$ 表示取多少个 a,b,c 的答案，在三个维度做 $3$ 次前缀和。\r\n\r\n注意到有 $x>n$ 这样的无意义询问，对 $n$ 取 min。\r\n\r\n### [C. Chinese Chess](https://qoj.ac/contest/1821/problem/9537)\r\n\r\n处理出两两点间不同种棋的最短路。发现询问次数 $\\le 3$，对 $ans=1/2/3$ 分别做。直接枚举决策点，按答案将询问分为几个部分，要求递归下去的子问题也符合能区分。而且发现对于 $ans=3$，第一步问 $(0,0)$ 就可以了，不会接着往下枚举。\r\n\r\n### [D. Closest Derangement](https://qoj.ac/contest/1821/problem/9538)\r\n\r\n偶数只有一种情况，$a_i=2k$ 和 $a_j=2k+1$ 交换。\r\n\r\n奇数有 $n-1$ 种情况，$123$ 被换为 $231$ 或 $312$。重载比较函数排序。分类讨论，比较两边不重叠的部分的一个区间的下标最小值。\r\n\r\n```cpp\r\nint n,k;\r\nint a[maxn],p[maxn];\r\nint id[maxn];\r\npii mn[20][maxn];\r\npii que(int l,int r){\r\n\tif(l>r)return {inf,0};\r\n\tint k=log2(r-l+1);\r\n\treturn min(mn[k][l],mn[k][r-(1<<k)+1]);\r\n}\r\nbool cmp(int uu,int vv){\r\n\tint u=uu,v=vv,fl=0;\r\n\tif(u==v)return 0;\r\n\tif(u>v)swap(u,v),fl=1;\r\n\tif(u/2==v/2){\r\n\t\tpii pos=que(u-1,v);\r\n\t\treturn fl^(pos.se&1);\r\n\t}\r\n\tint l=(u&1)?u-2:u,r=(v&1)?v:v+1;\r\n\tpii pos=min({que(l,u-2),que(u,v-1),que(v+1,r)});\r\n\tif(v&1){\r\n\t\tif((pos.se&1)&&pos.se>=u)return fl^1;\r\n\t\treturn fl;\r\n\t}\r\n\telse{\r\n\t\tif((pos.se&1)&&pos.se>=u&&pos.se<v)return fl^1;\r\n\t\treturn fl;\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();k=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read(),p[a[i]]=i,mn[0][a[i]]={i,a[i]};\r\n\tfor(int j=1;j<=18;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++)mn[j][i]=min(mn[j-1][i],mn[j-1][i+(1<<j-1)]);\r\n\t}\r\n\tif(n&1){\r\n\t\tif(k>n-1){puts(\"-1\");return ;}\r\n\t\tfor(int i=2;i<=n;i++)id[i]=i;\r\n\t\tsort(id+2,id+n+1,cmp);\r\n\t\tint pos=id[k+1];\r\n\t\tfor(int i=1;i<=((pos&1)?pos-3:pos-2);i+=2)swap(a[p[i]],a[p[i+1]]);\r\n\t\tfor(int i=((pos&1)?pos+1:pos+2);i<=n;i+=2)swap(a[p[i]],a[p[i+1]]);\r\n\t\tif(pos&1)swap(a[p[pos-2]],a[p[pos]]),swap(a[p[pos-1]],a[p[pos]]);\r\n\t\telse swap(a[p[pos-1]],a[p[pos+1]]),swap(a[p[pos-1]],a[p[pos]]);\r\n\t\tfor(int i=1;i<=n;i++)printf(\"%lld \",a[i]);puts(\"\");\r\n\t}\r\n\telse{\r\n\t\tif(k>1)puts(\"-1\");\r\n\t\telse{\r\n\t\t\tfor(int i=1;i<=n;i+=2)swap(a[p[i]],a[p[i+1]]);\r\n\t\t\tfor(int i=1;i<=n;i++)printf(\"%lld \",a[i]);puts(\"\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### [E. Disrupting Communications](https://qoj.ac/contest/1821/problem/9539)\r\n\r\n点边容斥，设 $dp_{u}$ 为子树 $u$ 的答案，$dp_{u}=\\prod dp_v+1$，记录前后缀积。换根求出所有 $u$ 为根和跨过边 $(u,v)$ 的答案，维护 lca 求路径和。\r\n\r\n### [G. Expanding Array](https://qoj.ac/contest/1821/problem/9541)\r\n\r\n只有 $a_i,a_i|a_{i+1},a_i\\oplus a_{i+1},a_i\\&a_{i+1},a_i\\oplus (a_i\\& a_{i+1}),(a_i\\&a_{i+1})\\oplus a_{i+1},0$ 能被取到，去重计数。\r\n\r\n### [I. Good Partitions](https://qoj.ac/contest/1821/problem/9543)\r\n\r\n对于 $a_i>a_{i+1}$ 的位置，要求 $i$ 整除 $k$，单点修，求全局 gcd。\r\n\r\n### [K. Magical Set](https://qoj.ac/contest/1821/problem/9545)\r\n\r\n每个 $a_i\\to a'_i$，代价为 $\\frac{a_i}{a'_i}$ 的质因数数。连边最大费用最大流。\r\n\r\n## [The 3rd Universal Cup. Stage 16: Nanjing](https://qoj.ac/contest/1828)\r\n\r\n### [B. Birthday Gift](https://qoj.ac/contest/1828/problem/9565)\r\n\r\n反转奇数位，变为相临的 $01$ 可以消掉，等价于 $\\min(num0,num1)$，将 $2$ 填到少的一边。\r\n\r\n### [C. Topology](https://qoj.ac/contest/1828/problem/9566)\r\n\r\n设 $dp_{u,i}$ 表示 除去 $u$ 子树，$u$ 的拓扑序排名为 $i$。预处理挖去子树 $v$，$v$ 的兄弟及其子树的拓扑序方案数 $f_v$。$dp_{v,j}=\\sum_{i<j}dp_{u,i}\\times f_v\\times\\binom{n-i-siz_u+1+siz_u-siz_v-1}{siz_u-siz_v-1}$。前缀和转移。\r\n\r\n### [F. Subway](https://qoj.ac/contest/1828/problem/9569)\r\n\r\n$dis_{i,j}$ 表示 在第 $i$ 条线第 $j$ 个站（编号为 $u$ ）的最短路，dij，线路上的转移容易。当松弛 $dis_{i,j}$ 时，$dis_{i,j}$  越小，$b_i$ 越大，在每个 $u$ 维护凸包。对于可以更新的 $dis_{p,q}$，$id_{i,j}=id_{p,q}=u$ ，更新 $a_p$ 最小的 $dis_{p,q}$。每个 $u$ 的 $(p,q)$ 按 $a_p$ 排序，双指针维护 $u$ 处没被松弛的最小 $p$，在凸包上二分 $x=a_p$ 时的最小值。\r\n\r\n```cpp\r\nint n,k;\r\nint a[maxn],b[maxn];\r\nvector<pii> e[maxn];\r\nvector<int> dis[maxn];\r\nvector<bool> vis[maxn];\r\nvector<pii> pos[maxn];\r\nint p[maxn];\r\nvector<pii> st[maxn];\r\nbool chk(pii u,pii v,pii w){\r\n\treturn (__int128)(w.se-u.se)*(u.fi-v.fi)<=(__int128)(v.se-u.se)*(u.fi-w.fi);\r\n}\r\npriority_queue<pair<int,pii>> q;\r\nint calc(pii l,int x){return x*l.fi+l.se;}\r\nint fd(int u,int x){\r\n\tint l=0,r=st[u].size()-1,res=0;\r\n\twhile(l<r){\r\n\t\tint mid=l+r>>1;\r\n\t\tif(calc(st[u][mid],x)<=calc(st[u][mid+1],x))r=mid;\r\n\t\telse l=mid+1;\r\n\t}\r\n\treturn calc(st[u][l],x);\r\n}\r\nvoid work(){\r\n\tn=read();k=read();\r\n\tfor(int i=1;i<=k;i++)a[i]=read();\r\n\tfor(int i=1;i<=k;i++)b[i]=read();\r\n\tfor(int i=1;i<=k;i++){\r\n\t\tint len=read();\r\n\t\te[i].resize(len),vis[i].resize(len),dis[i].resize(len);\r\n\t\tfor(int j=0;j<len-1;j++)e[i][j]={read(),read()};\r\n\t\te[i][len-1].fi=read();\r\n\t\tfor(int j=0;j<len;j++){\r\n\t\t\tpos[e[i][j].fi].pb({i,j});\r\n\t\t\tdis[i][j]=inf;\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++)sort(pos[i].begin(),pos[i].end(),[&](pii u,pii v){return a[u.fi]<a[v.fi];});\r\n\tfor(int i=0;i<pos[1].size();i++){\r\n\t\tdis[pos[1][i].fi][pos[1][i].se]=0;\r\n\t\tq.push({0,{pos[1][i].fi,pos[1][i].se}});\r\n\t}\r\n\twhile(!q.empty()){\r\n\t\tint i=q.top().se.fi,j=q.top().se.se;q.pop();\r\n\t\tif(vis[i][j])continue;vis[i][j]=1;\r\n\t\tif(j+1<e[i].size()){\r\n\t\t\tif(dis[i][j+1]>dis[i][j]+e[i][j].se){\r\n\t\t\t\tdis[i][j+1]=dis[i][j]+e[i][j].se;\r\n\t\t\t\tq.push({-dis[i][j+1],{i,j+1}});\r\n\t\t\t}\r\n\t\t}\r\n\t\tint u=e[i][j].fi;\r\n\t\tif(!st[u].size()||b[i]<st[u].back().fi){\r\n\t\t\twhile(st[u].size()>1&&chk(st[u][st[u].size()-2],st[u].back(),{b[i],dis[i][j]}))st[u].pop_back();\r\n\t\t\tst[u].pb({b[i],dis[i][j]});\r\n\t\t}\r\n\t\twhile(p[u]<pos[u].size()&&vis[pos[u][p[u]].fi][pos[u][p[u]].se])p[u]++;\r\n\t\tif(p[u]<pos[u].size()){\r\n\t\t\tint v=fd(u,a[pos[u][p[u]].fi]);\r\n\t\t\tif(dis[pos[u][p[u]].fi][pos[u][p[u]].se]>v){\r\n\t\t\t\tdis[pos[u][p[u]].fi][pos[u][p[u]].se]=v;\r\n\t\t\t\tq.push({-dis[pos[u][p[u]].fi][pos[u][p[u]].se],{pos[u][p[u]].fi,pos[u][p[u]].se}});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=2;i<=n;i++){\r\n\t\tint res=inf;\r\n\t\tfor(auto[id,j]:pos[i])res=min(res,dis[id][j]);\r\n\t\tprintf(\"%lld \",res);\r\n\t}\r\n}\r\n```\r\n\r\n### [I. Bingo](https://qoj.ac/contest/1828/problem/9572)\r\n\r\n等于每行每列最大值的最小值。Min-Max 容斥。$\\min_{x\\in S} x=\\sum(-1)^{|T|-1}\\max_{x\\in T} x$。枚举 $T$ 有 $i$ 行 $j$ 列，有 $i\\times m+j\\times n-i\\times j$ 个格子。设选 $num$ 个格子的最大值为 $i$，$sum_{num}=\\binom{i-1}{num-1}num!(n\\times m-num)!$，差卷积。\r\n\r\n### [J. Social Media](https://qoj.ac/contest/1828/problem/9573)\r\n\r\n对每个非朋友 $i$ 求出与 $d_i$ 个朋友有边，要么是最大的两个 $d_i$ 之和，要么是有边的 $(i,j)$ 的 $d_i+d_j+w(i,j)$。\r\n\r\n### [K. Strips](https://qoj.ac/contest/1828/problem/9574)\r\n\r\n黑点和左右端点将序列分为若干子问题。只有无法覆盖下一个红点时放纸条，如果超过右端点在往回调整。\r\n\r\n### [M. Ordainer of Inexorable Judgment](https://qoj.ac/contest/1828/problem/9576)\r\n\r\n原点到每个点为圆心半径为 $d$ 的园求切线，取最大最小的夹角。因为有跨过 X 轴正方向的情况，所以是求与当前边界的夹角是否为正。\r\n\r\n```cpp\r\nint n;\r\ndb x,y,d,t,ans;\r\npii a[maxn];\r\nint sgn(db x){\r\n\tif(x>eps)return 1;\r\n\tif(x<-eps)return -1;\r\n\treturn 0;\r\n}\r\npii rotate(pii u,db c){\r\n    return {u.fi*cosl(c)-u.se*sinl(c),u.fi*sinl(c)+u.se*cosl(c)};\r\n}\r\nint cross(pii u,pii v){return u.fi*v.se-u.se*v.fi;}\r\nvoid work(){\r\n\tn=read();x=read(),y=read(),d=read(),t=read();\r\n\tfor(int i=1;i<=n;i++)a[i]={read(),read()};\r\n\tpii l={0,0},r={0,0};\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tdb v=atan2l(d,sqrtl(a[i].fi*a[i].fi+a[i].se*a[i].se-d*d));\r\n\t\tpii ll=rotate(a[i],-v),rr=rotate(a[i],v);\r\n\t\tif(i==1)l=ll,r=rr;\r\n\t\telse{\r\n\t\t\tif(sgn(cross(ll,l))>=0)l=ll;\r\n\t\t\tif(sgn(cross(rr,r))<=0)r=rr;\r\n\t\t}\r\n\t}\r\n    db a=atan2l(y,x),al=atan2l(l.se,l.fi),ar=atan2l(r.se,r.fi);\r\n    al-=a,ar-=a;\r\n    if(sgn(al)<0)al+=2*pi;\r\n    if(sgn(ar)<0)ar+=2*pi;\r\n\ta=ar-al;\r\n\tif(sgn(a)<0)a+=2*pi;\r\n\twhile(sgn(t-2*pi)>=0){\r\n\t\tt-=2*pi;\r\n\t\tans+=a;\r\n\t}\r\n\tif(sgn(ar-al)>=0){\r\n\t\tif(t>al)ans+=min(t,ar)-al;\r\n\t}\r\n\telse{\r\n\t\tans+=min(t,ar);\r\n\t\tif(t>al)ans+=t-al;\r\n\t}\r\n\tprintf(\"%.12Lf\\n\",ans);\r\n}\r\n```\r\n## [The 3rd Universal Cup. Stage 17: Jinan](https://qoj.ac/contest/1843)\r\n\r\n### [B. The Magician](https://qoj.ac/contest/1843/problem/9549)\r\n\r\n记每种花色几张，搜索。\r\n\r\n### [C. The Empress](https://qoj.ac/contest/1843/problem/9550)\r\n\r\n构造 ```POP i GOTO i+1;PUSH i GOTO i``` 使 $x=x+2$，```POP i GOTO i+1;PUSH i GOTO 1```  使 $x=2x+2$。\r\n\r\n### [D. The Emperor](https://qoj.ac/contest/1843/problem/9551)\r\n\r\n设从栈顶为 $a$ 进入指令 $i$ 出来时在 $to$，长度为 $len$。记搜。如果 $i$ 处 ```POP a``` 结束，否则进入 ```PUSH b GOTO x```，搜 $(x,b)$，再搜 $to_{x,b},a$，$len_{i,a}=len_{x,b}+len_{to_{x,b},a}+1$。如果搜索次数过大则无解。\r\n\r\n```cpp\r\nint n,tim;\r\nint op[maxn],to1[maxn],to2[maxn],v1[maxn],v2[maxn];\r\nchar s[maxn];\r\nbool vis[maxn][maxn];\r\npii dp[maxn][maxn];\r\npii sovle(int x,int a){\r\n\tif(dp[x][a].fi)return dp[x][a];\r\n\t++tim;if(tim>=2*n*n)return {0,0};\r\n\tif(!a&&op[x])return dp[x][a]={1,0};\r\n\tif(v1[x]==a)return {1,to1[x]};\r\n\tpii res=sovle(to2[x],v2[x]);\r\n\tif(res.se==0){return dp[x][a]={res.fi+1,0};}\r\n\tint len=res.fi;res=sovle(res.se,a);\r\n\treturn dp[x][a]={(res.fi+len+1)%mod,res.se};\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tscanf(\"%s\",s+1);\r\n\t\tif(s[1]=='H')op[i]=1;\r\n\t\telse{\r\n\t\t\tv1[i]=read();scanf(\"%s\",s+1);\r\n\t\t\tscanf(\"%s\",s+1);int l=strlen(s+1);\r\n\t\t\tfor(int j=1;j<l;j++)to1[i]=to1[i]*10+s[j]-'0';\r\n\t\t}\r\n\t\tscanf(\"%s\",s+1);v2[i]=read();\r\n\t\tscanf(\"%s\",s+1);to2[i]=read();\r\n\t}\r\n\tpii res=sovle(1,0);\r\n\tprintf(\"%lld\\n\",tim>=2*n*n?-1:res.fi);\r\n}\r\n```\r\n\r\n### [E. The Chariot](https://qoj.ac/contest/1843/problem/9552)\r\n\r\n分讨，python。\r\n\r\n```python\r\nt=int(input())\r\nwhile t>0:\r\n\tt-=1\r\n\ts=input().split();\r\n\ta=int(s[0])\r\n\tb=int(s[1])\r\n\tc=int(s[2])\r\n\tx=int(s[3])\r\n\ty=int(s[4])\r\n\td=int(s[5])\r\n\tres=(d+x-1)//x\r\n\tans=a*res\r\n\tres=d//x;\r\n\tif res!=0:\r\n\t\tans=min(ans,a*res+b*max(0,min(d-res*x,y))+c*max(0,d-res*x-y));\r\n\tif d>=x+y:\r\n\t\tres=d%(x+y);\r\n\t\tans=min(ans,(a+b*y)*(d//(x+y))+min(a+b*max(res-x,0),res*c))\r\n\t\tans=min(ans,a+b*y+(d-x-y)*c)\r\n\telse:\r\n\t\tans=min(ans,a+b*max(d-x,0))\r\n\tif d>=x:\r\n\t\tu=d%x\r\n\t\tv=d//x\r\n\t\tif v*y>=u:\r\n\t\t\tans=min(ans,a*v+b*u)\r\n\t\tk=(d+x+y-1)//(x+y)\r\n\t\tif d-k*x>0:\r\n\t\t\tans=min(ans,a*k+b*(d-k*x))\r\n\tprint(ans)\r\n```\r\n\r\n### [F. The Hermit](https://qoj.ac/contest/1843/problem/9553)\r\n\r\n$\\binom{m}{n}n$ 减去每个数被删除的次数。$i$ 被删除时比 $i$ 小的部分为上一个数的倍数，比 $i$ 大的部分都是 $i$ 的倍数。$i$ 前只能选 $\\log m$ 个，枚举倍数转移。\r\n\r\n### [I. The Hanged Man](https://qoj.ac/contest/1843/problem/9556)\r\n\r\n选出一个偶度数点，一个点连向的叶子两两匹配。否则无解。\r\n\r\n### [J. Temperance](https://qoj.ac/contest/1843/problem/9557)\r\n\r\n从小往大删，删 $\\max(a,b,c)$ 小的不影响 $\\max (a',b',c')$ 大的点，所以初始状态下 $<k$ 的删掉。\r\n\r\n### [L. The Tower](https://qoj.ac/contest/1843/problem/9559)\r\n\r\n对每个人维护动态开点线段树。加的时候从代表空节点的线段树上分裂一个前缀，删的时候和代表空节点的线段树合并。提前把点开到询问的位置，询问时从对应的线段树节点跳线段树父亲至根，记录每个根对应哪个人。",
      "data": {
        "title": "The 3rd Universal Cup 做题记录 (2)",
        "date": "2024-10-18 21:49:38",
        "tags": [
          "ucup",
          "做题记录",
          "acm"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "the-3rd-universal-cup-zuo-ti-ji-lu-2"
    },
    {
      "content": "## 9.1\r\n\r\n### [arc108e](https://www.luogu.com.cn/problem/AT_arc108_e)\r\n\r\n当已经选了 $a_l,a_r$ 时，$(l,r)$ 与外面无关。区间 dp，$dp_{l,r}=\\frac{\\sum_{k=l,a_l<a_k<a_r}^r dp_{l,k}+dp_{k,r}}{num_{l,r}}+1$。维护 $num_{l,r},\\sum dp_{l,k},\\sum dp_{k,r}$ 转移。\r\n\r\n## 9.2\r\n\r\n### [P5188](https://www.luogu.com.cn/problem/P5188)\r\n\r\n模拟赛 T2。\r\n\r\n容斥强行不选 $s$ 这些材料，矩阵快速幂。\r\n\r\n### [CF1949H](https://www.luogu.com.cn/problem/CF1949H)\r\n\r\n模拟赛 T3。\r\n\r\n按对角线向后推，计算经过次数。不能经过 $3$ 次。经过次数形如 $0,\\dotsb,0,1,2,\\dotsb,2,1,0,\\dotsb,0$ 或 $0,\\dotsb,0,2,2,0,\\dotsb,0$。维护两个 $1$ 的位置 $l,r$ 或是不是状态 2。如果 $0,\\dotsb,0,1,2,1,0,\\dotsb,0$ 的 $2$ 被禁止，去到状态 2，否则如果有 $2$ 的位置被禁止则无解。如果 $l,r$ 有被禁止，每次 $2$ 的区间 $(l,r)$ 会增加 $1$，否则 $(l,r)$ 会缩短 $1$，$2\\times n$ 个对角线后结束。\r\n\r\n### [P10998](https://www.luogu.com.cn/problem/P10998)\r\n\r\n按 $d_u<d_v<d_w$ 排序，对于每个 $u$ 对 $(v,w)$ 进行三元组计数。\r\n\r\n$m$ 条边的三元组计数 $O(m^{1.5})$。如果 $d_u\\le m^{\\frac{2}{3}}$，有 $\\sum d_u=m$，复杂度 $O(m^{\\frac{1}{3}}(m^{\\frac{2}{3}})^{1.5})=O(m^{\\frac{4}{3}})$。否则 $u,v,w$ 至多 $m^{\\frac{1}{3}}$ 个，复杂度 $O(m^{\\frac{1}{3}}((m^{\\frac{1}{3}})^2)^{1.5})=O(m^{\\frac{4}{3}})$。\r\n\r\n### [P4843](https://www.luogu.com.cn/problem/P4843)\r\n\r\n有源汇上下界最小流，建超级源汇点补齐流量，跑最大流，从汇点向源点连容量 $+\\infty$，再跑最大流。答案为汇点到源点的流量。\r\n\r\n### [P4043](https://www.luogu.com.cn/problem/P4043)\r\n\r\n最小费用可行流，建超级源汇点补齐流量，费用加上下界流量乘代价，从汇点向源点连容量 $+\\infty$ 代价 $0$ 的边。费用加上超级源汇点的最小费用最大流。\r\n\r\n### [CF1288F](https://www.luogu.com.cn/problem/CF1288F)\r\n\r\n将边 $(u,v)$ 拆为 $(u,v,1,r)$ 和 $(v,u,1,b)$，分别表示红边或蓝边，都不流就不染色。左边的红点的右边的蓝点流出大于流入，连 $(s,i,1,+\\infty,0)$，反之连 $(i,t,1,+\\infty,0)$。最小费用可行流。如果超级源点出边满流则合法。\r\n\r\n## 9.3\r\n\r\n### [P9338](https://www.luogu.com.cn/problem/P9338)\r\n\r\n要求前缀和时刻大于零。设 $c_i$ 为第 $i$ 个 A 前有多少个 B，$w(l,r)=\\sum_{i=l}^r max(c_i-l+1,0)$，外层 wqs 二分。拆开 max，预处理 $*p_i$ 为最小的位置使得 $c_{p_i}−i>0$，内层 $dp_i=\\min dp_j+sum_j-sum_{p_j-1}-j\\times(i-p_j+1)$，斜率优化。\r\n\r\n### [CF2006E](https://codeforces.com/problemset/problem/2006/E)\r\n\r\n等价于度数 $\\le 2$ 的点到其余点的距离最大值。动态维护直径，每次中心偏移 $1$，dfn 序上子树加，全局 min。度数 $=3$ 就不贡献，度数 $>3$ 无解。\r\n\r\n### [Q9123](https://qoj.ac/problem/9123) \r\n\r\n升序排序，二分答案 $x$。对于每个 $i$ 可以 $O(n)$ 计算 $(i,j,k)$ 的答案。设阈值 $B$，前 $B$ 个的贡献 $O(nB)$ 计算。如果没超过 $k$，$B$ 的 $(B,j,k)$ 贡献 $\\le \\frac{k}{B}$。后边只需要前 $\\frac{k}{B}$ 小的 $(j,k)$ 对，$O(\\frac{k}{B}\\log n)$ 预处理加 $O(n+\\frac{k}{B})$ 计算。$B$ 取 $\\sqrt{\\frac{k}{B}}$。\r\n\r\n### [Q5095](https://qoj.ac/problem/5095)\r\n\r\n模拟赛 T3。\r\n\r\n最优策略决策为从下往上每个人删掉存在的最劣的数。$O(n^3)$ 模拟，开始点下移时每个人的决策点单调，复杂度 $O(n^2)$。\r\n\r\n## 9.4\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1071)\r\n\r\n按值从小往大 dp，枚举笛卡尔树子树内哪个位置不被确定。保证数据随机，笛卡尔树深度 $O(n\\log n)$，只用以 $2$ 为底的幂，$O(\\sqrt(V))$ 预处理 $O(1)$ 查询。\r\n\r\n### [P9850](https://www.luogu.com.cn/problem/P9850)\r\n\r\n容斥，设 $f_i$ 为至少 $i$ 条红边的方案，蓝色四元完全子图的数量为 $f_0-f_1+f_2−f_3+f_4−f_5+f_6$，红色四元完全子图的数量为$f_6$。分类讨论，三/四元环计数。\r\n\r\n### [P7386](https://www.luogu.com.cn/problem/P7386)\r\n\r\n将一个 $1$ 和 $0$ 捆绑起来。设有 $n$ 个 $01$ 和 $m$ 个 $0$。最后一层 $1$ 的贡献为 $\\binom{n+m-1}{n-1}$。对于一个 $0$，枚举上面有 $i$ 个 $10$ 和 $j$ 个 $0$，有 $\\binom{i+j}{i}$ 种可能，即有 $\\binom{i+j}{i}$ 个这样的 $0$。$10$ 同理，算作一个大小为 $2$ 的点。要求形如 $\\sum_{i=0}^n\\sum_{j=0}^m \\binom{i+j}{i}$。有 $\\sum_{i=0}^n\\binom{i}{m}=\\binom{n+1}{m+1}$。所以 $\\sum_{i=0}^n\\sum_{j=0}^m \\binom{i+j}{i}=\\binom{n+m+2}{n+1}-1$。lucas 定理计算。\r\n\r\n## 9.5\r\n\r\n### [gym102428J](https://codeforces.com/gym/102428/problem/J)\r\n\r\n模拟赛 T3\r\n\r\n初始在 $x$，先向左走，令 $vl=\\max_{i=1}^{x-1}a_i,vr=\\max_{i=x+1}^n a_i$，若 $vl<v$，答案为 $[x+1,n]$ 中第一个 $>vl$ 的位置；否则为 $[1,x-1]$ 中最后一个 $>\\max(a_i,vr)$ 的位置。线段树上二分。\r\n\r\n### [Q7899](https://qoj.ac/problem/7899)\r\n\r\n模拟赛 T4。\r\n\r\n分治。记 $vl_i=\\max_{j=i}^{mid}a_j,vr_i=\\max_{j=mid+1}^i a_j$，$[i,j]$ 合法等价于 $\\max(vl_i,vr_j)\\le j-i+1$，即 $j\\ge i+vl_i+1,i\\le j-r_j+1$，按 $i+vl_i-1$ 排序，树状数组维护 $j$。正反做一遍得到划分 $[1,i]$ 的答案 $f_i$ 和划分 $[i,n]$ 的答案 $g_i$。\r\n\r\n分治维护修改的变化量。当某个 $a_i$ 改为 $1$ 时，对于分治区间 $[l,r],l\\le i\\le mid$ ，当 $vl_i>vl_{i+1}$ 是，区间 $[ll,i]$ 的 $vl$ 值发生变化，合法的 $j$ 发生变化，重新计算 $\\sum g'_{j+1}$，和原先应当贡献的 $\\sum g_{j+1}$ 做差。·\r\n\r\n## 9.6\r\n\r\n### [arc165f](https://www.luogu.com.cn/problem/AT_arc165_f)\r\n\r\n模拟赛 T4。\r\n\r\n如果 $l_x<l_y,r_x<r_y$ 则 $x$ 在 $y$ 前，跑字典序最小的拓扑序。主席树优化建图，优先拓扑主席树点，优先队列拓扑。\r\n\r\n## 9.9\r\n\r\n### [P7230](https://www.luogu.com.cn/problem/P7230)\r\n\r\n模拟赛 T4。\r\n\r\n对每个左端点维护右端点 $res_i$。操作形如删去一个数再加入一个数。如果删掉 $p$ 上的 $a_p$，找到左右最近的 $l,r$ 使得 $a_l=a_r=a_p$。那么 $res_{l+1},\\dotsb,res_p$ 对 $r$ 取 max。实际上要维护 $\\max res_i-i+1$，因为 $res_i$ 单调，所以相当于线段树上二分找到最左的小于 $r$ 的位置然后区间覆盖。\r\n\r\n删除好做，加入难做，考虑线段树分治。先把所有的时刻的 $a_i$ 都当作存在，右移右端点维护出所有 $res_i$。 multiset 维护每个值出现的位置来求 $l,r$。进入一个区间后进行删除操作。撤销操作记录下所有修改和下传的位置和值。\r\n\r\n### [P4617](https://www.luogu.com.cn/problem/P4617)\r\n\r\n$u$ 先手胜当且仅当 $u$ 一定在最大匹配上。找出一个最大流， $u$ 一定在最大匹配上当且仅当 $u$ 被选且残量网络缩点后 $u$ 和 $s$ 不在同一强连通分量。\r\n\r\n## 9.10\r\n\r\n### [模拟赛 T2](http://goj.wiki/d/Union2024/p/P1086)\r\n\r\n去掉头尾相等的。枚举回文中心 $i$，取最长回文串 $s[l,r]$，求最大 $j$ 使得 $s[1,j]=s'[r+1,r+j]$。等价于反串和自己匹配，kmp。翻转再做一遍。\r\n\r\n### [CF1149D](https://www.luogu.com.cn/problem/CF1149D)\r\n\r\n模拟赛 T3。\r\n\r\n令 $a<b$，$a$ 边构成若干连通块，合法 $b$ 边跨过两个连通块。不能走 $b$ 边离开一个连通块再走 $b$ 边返回，$3a>2b$，只有 $siz>3$ 的连通块有用，状压，最短路， $2^{\\frac{n}{4}}m\\log {2^{\\frac{n}{4}}m}$。\r\n\r\n## 9.11\r\n\r\n### [P6684](https://www.luogu.com.cn/problem/P6684)\r\n\r\n模拟赛 T4。\r\n\r\n等价对于每个 $r$ 求最小的 $l$ 使得 $[1,l]$ 和 $[r,m]$ 的边能组成奇环。将边复制一遍接在后面，即对于每个 $i$ 求最小的 $p$ 使得 $[i,p]$ 间的边组成奇环。$p$ 有单调性。依次求每个 $i$，每次右移 $p$，加入的这条边 $p$ 会在求 $[i,p]$ 时都有贡献。插入容易删除困难，用线段树分治。初始没有边，分治到 $i$ 时会对之后一个区间加入若干条边，一共加边 $m$ 次。\r\n\r\n### [P7307](https://www.luogu.com.cn/problem/P7307)\r\n\r\n答案为最大度数。允许误差，每次将边集一分为二。希望将每个点度数除以 $2$ 上取整，在左右部点各建一个虚点，将度数补齐为全是偶数，存在欧拉回路，将相邻的边分开得到两个边集，分别递归。$\\log \\max d_i$ 轮后 $\\max d_i=1$，将此时边集中的点染成一种颜色。\r\n\r\n### [ucup 做题记录](https://www.cnblogs.com/yhddd/p/18415768)\r\n\r\n## 9.12\r\n\r\n### [joisc2017e](https://www.luogu.com.cn/problem/AT_joisc2017_e)\r\n\r\n将 $x$ 三进制拆分，$0\\to 01,1\\to 10,2\\to 11$，如果 $i$ 或 $i+1$ 被影响就不选。两边用同个随机排列来遍历数组，并尽量利用坏段。\r\n\r\n### [Q9237](https://qoj.ac/problem/9237)\r\n\r\n先补一个 $0$，在一直补 $1$ 至 $1024$。还原时把最后一个 $0$ 以后扔掉。有 $16\\times 66=1056$ 个有效位，要用 $1056-1024=32$ 位说明哪些位置被控制。令 $c_i=0$ 后最近的 $c_j=0$，前 $j-i-1$ 条信息第 $i$ 位为 $0$，第 $j-i$ 条信息第 $i$ 位为 $0$。还原时可以建图，找 $31$ 个点的内向基环树的长为 $16$ 的环，是唯一的。\r\n\r\n### [agc034e](https://www.luogu.com.cn/problem/AT_agc034_e)\r\n\r\n记 $sum=\\sum_{c_i=1} dis_{i,x}$，每步 $sum$ 减小 $2$ 最优。维护 $mn_u,mx_u$ 表示最多最少能将 $u$ 子树内 $\\sum_{v=subtree(u),c_v=1}dis(u,v)$ 变为多少。讨论最大的子树是否大于一半。\r\n\r\n### [arc110e](https://www.luogu.com.cn/problem/AT_arc110_e)\r\n\r\n用异或表示。令 $a\\to 1,b\\to 2,c\\to 3$，$f(s)=\\oplus s_i$ 不变。设 $dp_i$ 为划分 $s[1,i]$ 的方案，枚举最后一个字符是什么。\r\n\r\n### [P6790](https://www.luogu.com.cn/problem/P6790)\r\n\r\n广义串并联图。删 $1$ 度点，缩 $2$ 度点，叠合重边。记 $f_i$ 为第 $i$ 条边在生成树上的方案数，$g_i$ 为不在的方案数。删一度点，$f_i$ 乘进答案；缩 $2$ 度点，$f_i=f_uf_v,g_i=f_ug_v+f_vg_u$；叠合重边，$f_i=f_ug_v+f_vg_u,g_i=g_ug_v$。\r\n\r\n## 9.13\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1096)\r\n\r\n建 trie 树。先假设全选 $A$，计算答案与 $\\sum d_iAc_i$ 的差值。按 dfn 序转移，设 $dp_i$ 为上一个单词在 $i$ 的答案，$dp_x=\\max dp_i+(B-dep_{lca-1}A)c_x$。李超线段树维护转移。\r\n\r\n## 9.14\r\n\r\n### [abc308h](https://www.luogu.com.cn/problem/AT_abc308_h)\r\n\r\n枚举连向环外的点 $u$。在挖掉 $u$ 的子图中求全源最短路，答案为 $\\min dis_{x,y}+e_{u,x}+e_{u,y}+\\min_{i\\ne x,i\\ne y}e_{u,i}$。线段树分治，加入点时进行松弛操作。复杂度 $O(n^3\\log n)$。\r\n\r\n## 9.15\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1100)\r\n\r\nBoruvka 算法。每次对于每个连通块找到最小的到连通块外的边，全部连起来。每次连通块数量减半。将矩阵加对对角线翻转，扫描线找到每个 $i$ 的最小边。线段树分别维护最小值和连通块不同的次小值。\r\n\r\n## 9.16\r\n\r\n### [CF901D](https://www.luogu.com.cn/problem/CF901D)\r\n\r\n模拟赛 T3。\r\n\r\n找出一颗生成树，满足除了根以外的所有点。调整根，只有奇环有用。只要有一个奇环，$a_1$ 就可以减去 $2\\times val$。因为保证 $a_1$ 和 $d_1$ 奇偶性相同，找一颗 bfs 的生成树即可。\r\n\r\n## 9.18\r\n\r\n### [Q8948](https://qoj.ac/problem/8948)\r\n\r\n模拟赛 T3。\r\n\r\n对于一个菊花，有 $n0$ 个黑色儿子，$n1$ 个白色儿子，$n0>n1$ 当做 $n0-n1+1$ 个黑；$n1>n0$ 当做 $n1-n0-1$ 个白；否则若 $n$ 为偶 Bob 要先走当做黑；否则当做白。\r\n\r\n### [P10214](https://www.luogu.com.cn/problem/P10214)\r\n\r\n模拟赛 T4。\r\n\r\n设 $dp_u$ 为 $u$ 被投出时的票数，$(dp_u,u)$ 和 $(dp_v,v)$ 较大者先出。$u$ 的儿子 $v$ 影响 $dp_u$。对 $v$ 按投出先后排序，二分一个前缀在 $u$ 前被投出，即 $a_u+\\sum b_v-s_{i-1}>dp_{v_i}$。平衡树维护每个点的儿子，支持插入删除二分。\r\n\r\n此时单点修改复杂度为 $O(dep)$。重链剖分，求出 $u$ 在轻儿子中二分的结果 $ans$，若 $ans>dp_{son}$，$dp_u=ans$；否则在轻儿子中二分 $a_u+\\sum b_v-b_{son}$。$dp_u$ 为关于 $dp_{son}$ 的分段常函数，段数为 $2$，可以合并。线段树维护重链信息乘积，修改时改链顶父亲的轻儿子的平衡树，查询时从链底 dp 值加上区间信息求 dp 值。\r\n\r\n## 9.19\r\n\r\n### [CF1647F](https://www.luogu.com.cn/problem/CF1647F)\r\n\r\n模拟赛 T3。\r\n\r\n假设一个最大值为左边峰顶。设 $f_i$ 表示前缀 $[1,i]$，一个序列在 $i$，另一个序列最小在哪里。$g_j$ 为后缀。从左边峰顶到 $n$ 枚举右边峰顶，设 $dp_{i,0/1}$ 表示当前左/右序列在 $i$，另一序列的最大最小值。\r\n\r\n### [CF1494F](https://www.luogu.com.cn/problem/CF1494F)\r\n\r\n模拟赛 T4。\r\n\r\n最后是菊花，枚举菊花中心 $u$，删去与 $u$ 连边的奇度数点找欧拉路径。\r\n\r\n## 9.23\r\n\r\n### [CF1635F](https://www.luogu.com.cn/problem/CF1635F)\r\n\r\n模拟赛 T3。\r\n\r\n枚举可能贡献的答案对的较大值，只有左右第一个比 $i$ 小的 $j$ 才有贡献。\r\n\r\n### [CF1784F](https://www.luogu.com.cn/problem/CF1784F)\r\n\r\n模拟赛 T4。\r\n\r\n被删除的连续段长度一定是偶数；不会删去 $n+k$ 以后的数；第二段关于中心对称。\r\n\r\n枚举第一段长度 $i$，$2i<n$，枚举第二段在 $n$ 左侧长为 $j$。$\\sum_{i=0}^k[2i<n]\\sum_{j=0}^{\\min(k-i,n-2i-1)} \\binom{i}{k-i-j}$。下指标关于 $i$ 变换量为 $O(1)$，$\\sum_{i=l}^r\\binom{p}{i}=2\\times\\sum_{i=l}^r\\binom{p-1}{i}-\\binom{p-1}{r}+\\binom{p-1}{l-1}$。否则剩余长度 $n+k-2i-1$，剩 $k-i$ 次操作，$\\binom{n+k-2i-1-(k-i)}{k-i}$。\r\n\r\n### [arc184b](https://www.luogu.com.cn/problem/AT_arc184_b)\r\n\r\n对于不是 $2,3$ 倍数的 $i$，将 $\\frac{n}{i}$ 中的 $2^a3^b$ 找出来，每次加入 $(a,b),(a+1,b),(a,b+1)$，有 $\\log_3 n$ 级别宽的网格。状压 $dp_{i,j,s}$ 表示前 $i-1$ 行已经选完，第 $i$ 行选到 $j$ 列，当前面上状态为 $s$。$\\frac{n}{i}$ 只有 $O(\\sqrt n)$级别，可过。 \r\n\r\n## 9.24\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1119)\r\n\r\n扫描线维护编号较小的最大编号为 $i$，点边容斥强行选 $i$，主席树维护矩阵。交换 $a_x,a_{x+1}$ 时重新做第 $x,x+1$ 棵主席树即可。\r\n\r\n## 9.25\r\n\r\n### [【5校day1】构造题](http://goj.wiki/d/Union2024/p/TNOI0002)\r\n\r\n从右上往左下确定每个点的颜色。对于点 $u$ 最多有 $4$ 个入边。如果不包含所以颜色，就赋没有出现的颜色。否则如果 $v1,v3$ 通过 $col_{v1},col_{v3}$ 的连通块联通，那么 $v2,v4$ 一定不通过 $col_{v2},col_{v4}$ 的连通块联通。\r\n\r\n### [【5校day2】祖先](http://goj.wiki/d/Union2024/p/TNOI0006)\r\n\r\n设 $s_u$ 为 $\\sum_{v\\in subtree(u)}a_v$，答案为 $\\frac{s_u^2-a_u^2-\\sum_{v\\in son(u)}s_v^2}{2}$。单点加为链加。类似动态 dp 维护轻儿子处的 $\\sum s_v^2$。区间加单点查。子树加，先加上 $u$ 到根的贡献，再打上子树 tag，维护 $0/1/2$ 次方和。树剖时先进入重儿子，再去到每个儿子，再进入轻儿子子树。\r\n\r\n## 9.26\r\n\r\n### [joisc2020q](https://www.luogu.com.cn/problem/AT_joisc2020_q)\r\n\r\n模拟赛 T4。\r\n\r\n对 $\\lvert t_i-t_j\\rvert\\le r_i-l_j+1$ 连 $i\\to j$ 求 $1\\to n$ 的最短路。边权赋在点上，一个点只入队一次。按 $t_i$ 建线段树，取出合法的 $v$ 并删除。\r\n\r\n### [【5校day5】签到题](http://goj.wiki/d/Union2024/p/TNOI0010)\r\n\r\n先二分出 $cnt_a,cnt_b,cnt_c$，令 $cnt_a\\le cnt_b\\le cnt_c$。先将序列放 $cnt_a$ 个 $a$，每次加一个 $b$，每次加一个 $c$。次数为 $2cnt_a+2cntb_cntc\\le \\frac{5}{3}n$。\r\n\r\n## 9.27\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1127)\r\n\r\ndij 状求答案，与除去 $(u,v)$ 的 $u\\to t$ 最短路相关。找出最短路树，非树边进行路径取 min。\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1127)\r\n\r\n有决策单调性，二分栈，主席树维护前 $k$ 大的和。统计答案，只有不交区间有贡献，区间对区间 $k$ 大取 min，如果一个点最后的值小于自己的值就可以选。\r\n\r\n## 9.29\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1132)\r\n\r\n每个位置对答案的贡献为向下递归的层数。设 $\\le i$ 的数最后出现在 $p_i$，$(i,i+1)$ 被断开的层为 $p_i-i$。$i$ 的贡献为 $\\max (p_{i-1}-(i-1),p_i-i)$。取到后面的为 $a_{p_i}=i$。\r\n\r\n$$ans=\\sum_i(n-i)!(\\sum_j\\binom{j-1}{i-1}(i-1)!(j-i)+\\binom{j}{i}(i!-(i-1)!)(j-i+1))$$\r\n\r\n上指标求和，最后只与 $i$ 有关的式子。\r\n\r\n## 9.30\r\n\r\n### [CF1648F](https://www.luogu.com.cn/problem/CF1648F)\r\n\r\n模拟赛 T4。\r\n\r\n建出 dfs 树，非树边赋随机权值，随机异或哈希。如果割两条树边，只能是 $hsh_u=hsh_v$。相同的 $hsh_i$ 都在到根的链上，且有决策单调性，对于每个相同权值放在序列上分治。两边 $(u,fa_u),(v,fa_v)$ 的答案为：跨过 $u$ 的点对减跨过 $v$ 的点对加两倍没有跨过 $u$ 但跨过 $v$ 的点对。后面的贡献在 dfs 序上维护主席树，在两点处 $+2$，lca 处 $-4$。\r\n\r\n",
      "data": {
        "title": "2024.9 做题记录",
        "date": "2024-10-01 22:17:48",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20249-zuo-ti-ji-lu"
    },
    {
      "content": "## 8.1\r\n\r\n### [P6222](https://www.luogu.com.cn/problem/P6222)\r\n\r\n$$ans=\\sum_{T=1}^n T^kS(\\frac{n}{k})\\sum_{d\\mid T}d\\mu^2(d)\\mu(\\frac{T}{d})$$\r\n令 $f(T)=\\sum_{d\\mid T}d\\mu^2(d)\\mu(\\frac{T}{d})$，为积性函数，讨论 $f(p^k)$ 的取值。\r\n\r\n### [P10636](https://www.luogu.com.cn/problem/P10636)\r\n\r\n枚举第一个点和第三个点的横纵坐标之差 $i,j$，第二个点有 $gcd(i,j)-1$ 种选择。\r\n$$ans=\\sum_{i=1}^n\\sum_{j=1}^m (n-i)(m-j)(gcd(i,j)-1)$$\r\n莫比乌斯反演。\r\n\r\n## 8.3\r\n\r\n### [P3598](https://www.luogu.com.cn/problem/P3598)\r\n\r\n对每个指数 min-max 容斥，乘起来得到 gcd-lcm 容斥。\r\n$$lcm(T)=\\prod_{S\\subseteq T} gcd(S)^{(-1)^{|S|+1}}$$\r\n$f(n)=\\frac{x^{n+1}-1}{x-1}$。提出 $x-1$。因为 $gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1$，用 map 储存指数。\r\n\r\n## 8.6\r\n\r\n### [arc069d](https://www.luogu.com.cn/problem/AT_arc069_d)\r\n\r\n二分答案，线段树优化建图跑 2-sat。要保证 $i$ 不会连到 $i'$，向排序后一个编号区间连边，中间挖空。\r\n\r\n### [P10833](https://www.luogu.com.cn/problem/P10833)\r\n\r\n枚举每个 $a_i=1$ 将序列划分开，枚举左/右端点，钦定最大值在左/右边，可以确定一段区间。随机异或哈希比较 $\\oplus_{i=l}^r f_{a_i}=\\oplus_{i=1}^{r-l+1} f_i$。\r\n\r\n## 8.7\r\n\r\n### [arc072d](https://www.luogu.com.cn/problem/AT_arc072_d)\r\n\r\n模拟赛 T2。\r\n\r\n设 $f_{i,j}$ 为前 $i$ 天体积为 $j$ 的最大质量，图像上凸。$f_{i-1}$ 到 $f_i$ 即删去 $[v_i,L]$，在最开始加上 $(v_i,v_it_i)$，在将前面取 max 为上凸。双端队列维护。\r\n\r\n### [arc070c](https://www.luogu.com.cn/problem/AT_arc070_c)\r\n\r\n模拟赛 T3。\r\n\r\n设 $f_{i,j}$ 表示前 $i$ 条线段，第 $i$ 条左端点为 $j$ 的最小代价。$f_{i,j}=\\min_{k=j-len_{i-1}}^{j+len_i} f_{i-1,j}+\\mid j-l_i\\mid$。\r\n\r\n取 min 和加绝对值函数，下凸，slope trick 维护。\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1008)\r\n\r\n从小到大放入特殊点，当前在点 $i$，已选的比赛集合为 $s$，有 $j$ 个点在 $[1,a_i]$ 中没被选。每个和 $1$ 比赛的特殊点都是子树中最大的。dp 套 dp 维护上升子序列长度，做前缀最大值后差分后状压得 $t$，$t$ 是 $s$ 的子集。枚举没选过的比赛 $l$，$dp_{i,upd(s,t,l)，j+a_i-a_{i-1}-2^l}=dp_{i-1,s,t,j}\\times \\binom{j+a_i-a_{i-1}-1}{2^l-1}\\times (2^l)!$。\r\n\r\n### [P3343](https://www.luogu.com.cn/problem/P3343)\r\n\r\n$n$ 个 $[0,1]$ 之间的随机变量第 $k$ 小的为 $\\frac{k}{n+1}$。引入第 $n+1$ 个随机变量 $x$，第 $k$ 小的数值等于 $x$ 比第 $k$ 小小的概率 $\\frac{kn!}{(n+1)!}$。\r\n\r\n$dp_{s,i}$ 表示选点集 $s$，连了 $i$ 条边，不连通的方案数，$d_s$ 为 $s$ 内部的边，连通的方案数为 $\\binom{b_s}i -dp_{s,i}$。枚举 $s$ 的子集 $t$，$dp_{s,i}=(\\binom{b_t}{j}-dp_{t,j})\\times \\binom {b_{s\\oplus t}} {i-j}$。枚举答案为第 $i$ 条边，$ans=\\sum \\frac{i}{m+1}\\times(\\frac{dp_{U,k-1}}{\\binom{m}{k-1}}-\\frac{dp_{U,k}}{\\binom{m}{k}})$。\r\n\r\n## 8.8\r\n\r\n### [P9047](https://www.luogu.com.cn/problem/P9047)\r\n\r\n模拟赛 T3。\r\n\r\n$dp_{u,0/1/2/3}$ 表示 $u$ 子树并向上传长为 $0/1/2/3$ 的链的最大贡献。转移时背包 $f_{i,0/1}$ 记录上传长度 $1$ 的儿子比上传长度 $3$ 的多多少，以及上传长度 $2$ 儿子的奇偶性。随机排列儿子，期望前缀和最大值是 $O(\\sqrt n)$ 级别的。\r\n\r\n### [agc061c](https://www.luogu.com.cn/problem/AT_agc061_c)\r\n\r\n选 $a_i$ 或 $(a_i,b_i)$ 有被选过选 $b_i$。容斥，取最大的 $b_l<a_i$ 和 $a_r<b_i$，$(l,r]$ 间选法固定，$-dp_l\\to dp_r$。\r\n\r\n## 8.9\r\n\r\n### [CF925E](https://www.luogu.com.cn/problem/CF925E)\r\n\r\n链加，树剖 dfn 区间加，分块维护。先减去 $t_i$，维护 $>0$ 的白点数量。\r\n\r\n### [Q4815](https://qoj.ac/problem/4815)\r\n\r\n点分治，树上依赖性背包，$dp_{i,j}=\\max(dp_{i+1,j-1}+a_{rnk_u},dp_{i+siz_{rnk_i},j})$。如果一定要选 $rt,u$，就 $O(k)$ 合并在前序遍历 dfn 序在 $[dfn_u,n]$ 中的背包和后序遍历 dfn 序在 $[1,dfn_u-siz_u]$ 的背包选出 $k-dep_u$ 个数。当分治的区域小于 $k$ 时停止，复杂度 $O(nk\\log\\frac{n}{k})$。\r\n\r\n### [abc269h](https://www.luogu.com.cn/problem/AT_abc269_h)\r\n\r\n树形背包写成生成函数形式，$f_u(x)=\\prod_v f_v(x)+x$。分为重儿子和轻儿子贡献。分治 ntt 维护 $g_u(x)=\\prod_{v\\in son(u),v\\neq s_u} f_v(x)$，所有轻儿子子树大小之和为 $O(n\\log n)$。重链上 $f_u(x)=g_uf_{s_u}(x)+x$。只需要知道链顶的值，$f_{a_1}(x)=g_{a_1}(g_{a_2}(\\dotsb(g_{a_k}+x)\\dotsb)+x)+x=(\\sum_{i=1}^{n-1}x\\prod_{j=1}^i g_{a_j})+x$。分治 ntt 维护前缀乘积之和和乘积。复杂度 $O(n\\log^3 n)$。\r\n\r\n### [hdu7503](https://acm.hdu.edu.cn/showproblem.php?pid=7503)\r\n\r\n树形背包写成生成函数形式，$f_u(x)=\\prod_v f_v(x)+1$。特别的，需要求出重链上所有 $f_u(x)$ 每项的系数和，即 $g_u(x)$ 的区间乘积之和。分治 ntt 维护前缀乘积之和、后缀乘积之和、乘积和区间乘积之和。\r\n\r\n## 8.10\r\n\r\ncf rmj 暴毙！\r\n\r\n### [CF1733E](https://www.luogu.com.cn/problem/CF1733E)\r\n\r\n模拟赛 T3。\r\n\r\n$t$ 时刻可能在 $(x,y)$ 的是 $t-x-y$ 出发的人。设 $dp_{t,i,j}$ 表示前 $t$ 个人会经过 $(i,j)$ 几次，$dp_{i,j}=\\lceil \\frac{dp_{i,j-1}}{2}\\rceil+\\frac{dp_{i-1,j}}{2}$。差分看 $dp_{t,x,y}-dp_{t-1,x,y}$ 是否为 $1$。\r\n\r\n### [Q6815](https://qoj.ac/problem/6815)\r\n\r\n模拟赛 T4。\r\n\r\n线段树维护 $\\max a_i,\\sum a_i,\\sum\\max_{j=l}^i a_j,\\sum a_i\\times \\max_{j=l}^i a_j$。$O(\\log n)$ 线段树上二分的 pushup。区间加和区间覆盖。线段树上二分。\r\n\r\n## 8.11\r\n\r\n### [arc182c](https://www.luogu.com.cn/problem/AT_arc182_c)\r\n\r\n### 思路\r\n\r\n有 $6$ 个小于 $14$ 的质数，设这 $6$ 个质数的指数分别为 $x_1,\\dotsb,x_6$。$ans=\\sum (\\prod_{i=1}^d (x_i+1))$。状压这 $6$ 个数，维护 $val_s=\\prod_{i=1}^6 (x_i\\times [s二进制第 i位为1]+[s二进制第 i位为0])$。当加入一个数时，某些 $x_i$ 会加 $d$，$s$ 二进制第 $i$ 位为 $1$ 的 $val_s$ 会从 $s$ 的子集且一些二进制第 $i$ 位为 $0$ 的 $t$ 的 $val_t$ 转移来。\r\n\r\n## 8.12\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1023)\r\n\r\n设 $f_i$ 表示当前有 $i$ 种状态的期望次数。$f_i=i+\\frac{f_{ik\\mod n}}{k}$。转移有环，设 $f_i=a_i f_{m+1}+b_i$，递推 $a_i,b_i$，找到 $a_p=a_{m+1}$ 可以计算 $f_p$ 真正的值，$f_1=a_1\\times f_p+b_1$。\r\n\r\n### [P8996](https://www.luogu.com.cn/problem/P8996)\r\n\r\n让前缀最大值 $a_l$ 代表整个区间，可以看做合并是将两个序列的前缀最大值排序。每次合并相当于在 $\\frac{n}{2}$ 处断开跨过序列中点的区间 $[l,r]$，然后再重新按区间左端点的值排序。最多操作 $n$ 次，最多 $n$ 种区间。将询问离线，维护每次合并后的区间信息。建权值线段树表示前缀最大值 $l$ 代表的区间长度之和。\r\n\r\n### [P8997](https://www.luogu.com.cn/problem/P8997)\r\n\r\n按题意模拟，用栈建出二叉树，叶子节点是要填的值，非叶子是运算符。\r\n\r\n判断一个叶子能贡献能填哪些数并最终成为答案，设 $dp_{u,0/1,0/1}$ 表示 $u$ 子树内，$u$ 处的值 $\\le ans$ 或 $>ans$，$num0$ 或 $num1$ 最少为多少。根据 $u$ 处的运算符分类讨论转移。对于每个叶子算限制，只与从根到 $u$ 的 dp 值有关。可以发现放在一个叶子的答案是一个区间 $[num0+1,n-num1]$，差分维护区间加，最后计算大于 $0$ 的位置数。\r\n\r\n## 8.13\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1027)\r\n\r\n合并连续段写为二元组 $(a_i,t_i)$。每次找到区间最小值合并，如果 $c_i$ 为奇数，一定不可能被跨过，写为 $(a_i+1,\\frac{t_i}{2}),(inf,1),(a_i+1,\\frac{t_i}{2})$。线段树维护。\r\n\r\n## 8.14\r\n\r\n### [arc080d](https://www.luogu.com.cn/problem/AT_arc080_d)\r\n\r\n模拟赛 T4。\r\n\r\n将 $a$ 数组差分，得到 $2$ 倍连续段个数个 $1$，一次操作形如 $a_i$ 和 $a_{i+prime}$ 同时异或 $1$。$i$ 向 $i+prime$ 连边，即为 $0\\to |u-v|$ 的最短路。由哥德巴赫猜想，$10^7$ 内 $>4$ 的偶数可以写成两个质数之和，$2=0+5-3$，$4=0+7-3$，所以所以 $0$ 到偶数 $i$ 的最短路为 $2$。如果 $i$ 为奇质数，最短路为 $1$；否则 $i+3$ 为偶数，最短路为 $3$。\r\n\r\n现在要将 $2\\times num$ 个数两两分组，代价为 $1/2/3$，最小化代价和。当选完若干个代价为 $1$ 的组时，奇偶性相同组的代价为 $2$，尽量匹配，代价为 $3$ 的至多只有一组。所以最大化代价为 $1$ 的组数。代价为 $1$ 时 $u,v$ 奇偶性不同，等于二分图最大匹配，网络流即可。复杂度 $O(n^2\\sqrt n+x_i)$。\r\n\r\n### [abc216h](https://www.luogu.com.cn/problem/AT_abc216_h)\r\n\r\n概率转为方案数除以 $2^{nm}$。由 LGV 引理，$ans=\\sum_p(-1)^{\\sigma (p)}\\prod e(i,p_i)$。$e(i,j)$ 为 $m$ 步选 $j-x_i$ 步向前走。设 $dp_{s,i}$ 表示选了 $s$ 里的终止点，终止点 $\\le i$ 的方案数。\r\n\r\n### [agc034d](https://www.luogu.com.cn/problem/AT_agc034_d)\r\n\r\n最大化曼哈顿距离，拆绝对值变成 $4$ 个 $x_i,y_i$ 独立的式子。只要匹配的点对选的同一种式子即可。最小费用最大流。\r\n\r\n## 8.15\r\n\r\n### [【模板】矩阵求逆](https://www.luogu.com.cn/problem/P4783)\r\n\r\n将矩阵和单位矩阵放在一起高斯消元，把左边的矩阵消为单位矩阵时右边的单位矩阵变成逆矩阵。\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1031)\r\n\r\n求 $x$ 使得 $n\\times n$ 的矩阵 $A^x=C$。\r\n\r\n$det(A)det(B)=det(AB)$。对 $det(A)^x\\equiv det(C)\\pmod{10^9+7}$ 做 BSGS。对于 $1$ 个可能的 $x$ ，判断 $x,x+mod-1,x+2\\times(mod-1),\\dotsb$。只有 $\\frac{10^{10}}{mod}$ 个 $x$，复杂度 $O(\\sqrt{mod}+\\frac{10^{10}}{mod} n^3)$。\r\n\r\n## 8.17\r\n\r\n### [模拟赛 T2](http://goj.wiki/d/Union2024/p/P1034)\r\n\r\n$$ans\\times n^m=\\sum_{i=1}^n (n-1)^ai^b(n-i+1)^c\\times val(s_k,i)\\times n^{m-k}$$\r\n\r\n是关于 $i$ 的 $m+1$ 次多项式，维护 $m+2$ 个点值插值。\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1035)\r\n\r\n对于每个连通块，二分图染色分为 $a_i$ 和 $b_i$ 个点。每次要么选 $a_i$ 要么选 $b_i$，要最小化 $sum$ 和 $n-sum$ 的差。bitset 维护背包，只有 $O(\\sqrt n)$ 个本质不同物品，相同的物品二进制优化。复杂度 $O(\\frac{n\\sqrt n}{w})$。\r\n\r\n### [模拟赛 T4](http://goj.wiki/d/Union2024/p/P1036)\r\n\r\n找出最小生成树。从小到大加入边，维护边双，一定能去到一个边双的最小权值的边。并查集维护每个点属于哪个边双，维护边双最浅的点，维护 $1\\to u$ 的最小边权 $mn$ 和最小答案 $ans$。\r\n\r\n对于 $(u,v)$，如果 $u,v$ 已经属于同个边双，不会贡献。如果 $(u,v)$ 是最小生成树中的边，如果 $1$ 能新到一些点，bfs 拓展，赋值答案。否则将 $u\\to v$ 路径上的边双合并，设新边双最浅点为 $p$，将 $p$ 子树的所有点的 $mn$ 和 $ans$ 更新。如果更新到了非法的点，一定是没有被拓展到的，会在被拓展到时被覆盖。\r\n\r\n## 8.19\r\n\r\n### [CF622F](https://www.luogu.com.cn/problem/CF622F)\r\n\r\n是 $k+1$ 次多项式，算 $k+2$ 个点值插值。维护阶乘，$\\prod n-i$，$\\prod (n-k-2+i)$。如果 $n-i$ 是奇数取负号。\r\n\r\n### [arc165e](https://www.luogu.com.cn/problem/AT_arc165_e)\r\n\r\n等价于每种情况出现的概率之和。概率为连通块相邻的点被选都在连通块被选之前，即 $\\frac{i!j!}{(i+j)!}$。设 $dp_{u,i,j}$ 表示根为 $u$，子树内选 $i$ 个点，有 $j$ 个相邻的点的连通块的概率，$O(n^4)$ 转移。\r\n\r\n### [abc249g](https://www.luogu.com.cn/problem/AT_abc249_g)\r\n\r\n模拟赛 T3。\r\n\r\n枚举 $\\oplus x_i$ 和 $k$ 的最高相同的位 $i$，$i$ 位以下不用管。按位贪心确定 $\\oplus y_i$，将 $2^i\\frac{a}{2^i}$ 和 $2^i\\frac{b}{2^i}$ 拼在一起放入线性基中。复杂度 $O(n\\log^3V)$。\r\n\r\n减少有用的 $(a_i,b_i)$。如果 $a_i$ 能被 $a_1,\\dotsb ,a_{i-1}$ 表示出，那 $b_i$ 消去对应的 $b_j$，变成 $(0,b_i')$ 不会造成影响。只有 $O(\\log V)$ 个 $(a_i,b_i)$。复杂度 $O(n\\log V+\\log^3 V)$。\r\n\r\n## 8.20\r\n\r\n### [模拟赛 T3](http://goj.wiki/d/Union2024/p/P1043)\r\n\r\n从深度大往小维护线段树，启发式合并。$u$ 和 $v$ 处 $[l,r]$ 差分维护加 $1$，lca 对应 $u,v$ 的儿子处删除。每次修改后，线段树上二分极长非零连续段的左右端点，回答能回答的询问并删除询问。将询问挂在 $r$ 上，线段树维护区间 $l$ 的最大值，每次取出并删除。\r\n\r\n### [CF1174E](https://www.luogu.com.cn/problem/CF1174E)\r\n\r\n$a_1$ 一定是 $2^x3^y$，且 $y=0/1$。每次 $x$ 或 $y$ 减一或不变，dp 即可。\r\n\r\n## 8.21\r\n\r\n### [CF1264D2](https://www.luogu.com.cn/problem/CF1264D2)\r\n\r\n模拟赛 T2。\r\n\r\n等于在唯一一个 $pre_i=suf_{i+1}$ 的地方计算答案。枚举分界点，设左边有 $x$ 个 ```(```，$l$ 个 ```?```，右边有 $y$ 个 ```)```，$r$ 个 ```?```，答案为 $\\sum_{i=0}^l \\binom l i\\times \\binom r{x+i-y}\\times (x+i)=x\\times \\sum_{i=0}^l\\binom l i\\times \\binom r{r-x+y-i}+l\\times\\sum_{i=0}^l \\binom{l-1}{i-1}\\times \\binom{r}{r-x+y-i}=x\\binom{l+r}{r+y-x}+l\\binom{l+r-x}{r-x+y-1}$。\r\n\r\n### [CF1616H](https://www.luogu.com.cn/problem/CF1616H)\r\n\r\n模拟赛 T4。\r\n\r\n建 trie dp，设 $f_u$ 表示 $u$ 子树内选点两两异或小于等于 $x$ 的方案数，$g_{u1,u2}$ 表示 $u1,u2$ 子树内选点两两异或小于等于 $x$ 的方案数。分讨向下递归，每个点只经过一次。",
      "data": {
        "title": "2024.8 做题记录",
        "date": "2024-09-01 22:24:32",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20248-zuo-ti-ji-lu"
    },
    {
      "content": "## 7.7\r\n\r\n### [P6891](https://www.luogu.com.cn/problem/P6891)\r\n\r\n设 $dp_{i,j,0/1}$ 为前 $i$ 个选了 $j$ 个 A 中的数，结尾是 A/B。交换维度，改为 pair $dp_{i,0/1}$ 表示前 $i$ 个，结尾是 A/B，合法的 $j$ 的范围。\r\n\r\n### [CF1919F2](https://www.luogu.com.cn/problem/CF1919F2)\r\n\r\n网络流建图，$(s,i,a_i),(i,i+1,c_i),(i,t,b_i)$。转为最小割，线段树维护区间左右两端割 $s$ 还是 $t$。如果 $mid$ 割 $t$ 且 $mid+1$ 割 $s$，还要额外割 $(i,i+1)$。\r\n\r\n### [abc310g](https://www.luogu.com.cn/problem/AT_abc310_g)\r\n\r\n期望转为总和除以 $k$。贡献分环和树做前缀和。\r\n\r\n### [P4370](https://www.luogu.com.cn/problem/P4370)\r\n\r\n有 $\\binom n m>\\binom{n-1}m$，加入优先队列。数存不下，取对数比较。\r\n\r\n$$\\log \\binom n m=\\log n!-\\log m!-\\log (n-m)!=\\sum^n \\log i-\\sum^m \\log i-\\sum^{n-m} \\log i$$\r\n\r\n## 7.8\r\n\r\n### [CF1830D](https://www.luogu.com.cn/problem/CF1830D)\r\n\r\nMEX 值为 $0/1/2$，先令值都为 $2$ 计算损耗。同时连通块之间有损耗。$dp_{u,0/1,i}$ 表示当前包含 $u$ 的同色连通块颜色和大小时的最小损耗。大小一维不超过 $O(\\sqrt n)$，计算完儿子就释放空间。\r\n\r\n### [Q1281](https://qoj.ac/problem/1281)\r\n\r\n枚举前后 $i$ 个 $1$，$j$ 个 $3$。$\\max i+j+\\min(sa_{ra_j-1}-sa_{la_i},sb_{rb_j-1}-sb_{lb_i})$。\r\n\r\n拆 $min$，从后向前遍历 $i$，权值线段树。\r\n\r\n### [CF1656H](https://www.luogu.com.cn/problem/CF1656H)\r\n\r\n等价于 $x\\in SA,\\gcd_{y\\in SB} \\frac{x}{\\gcd(x,y)}=1$。建 $n+m$ 个线段树，单点删除。\r\n\r\n### [CF1270H](https://www.luogu.com.cn/problem/CF1270H)\r\n\r\n连通块一定是序列上的一段连续的区间。等价于计算分段点，多少 $p$ 使得 $\\min_{i\\le p} a_i>\\max_{i>p} a_i$。对于每个 $v$ 将序列改写为 01 序列，维护有几个 $10$ 和 $v$ 是否出现。\r\n\r\n### [Q1163](https://qoj.ac/problem/1163)\r\n\r\n树剖，讨论 $v$ 是否是 $u$ 的祖先。$\\sum_v dis(u,v)a_v$ 等价于以 $u$ 为根，每条边下的子树的 $a$ 和。维护区间加一次函数，加子树大小。\r\n\r\n### [CF1548E](https://www.luogu.com.cn/problem/CF1548E)\r\n\r\n给每个连通块定一个代表，按 $a_i+b_j,a_i,i$ 比较。预处理 $i$ 左右比 $a_i$ 大的 $la_i,ra_i$ 和 $ma_i=\\min (\\max_{la_i\\le j\\le i} a_j,\\max_{i\\le j\\le ra_i} a_j)$。$(i,j)$ 能向更小的走一定能去到 $(la_i/ra_i,j)/(i,lb_j/rb_j)$ 。所以满足条件的 $(i,j)$ 满足 $a_i+b_j\\le x,a_i+mb_j>x,ma_i+b_j>x$。扫描线。\r\n\r\n### [Q1838](https://qoj.ac/problem/1838)\r\n\r\n记 $v1$ 为两个相交且第三个都无交，$v2$ 为一个和两个都有交且另两个无交，$v3$ 为三个两两有交。扫描线算出与 $i$ 相交的数量 $d_i$。$\\sum \\binom {d_i}2=v2+3v3,\\sum d_i(n-2)=2v1+4v2+6v3$。只要求 $v3$。\r\n\r\n扫描线，在 $l_i$ 最大的矩形上计数，再容斥为 $\\binom {d_i}2$ 减两个无交。$l_i<r_a<l_b<r_i$。线段树维护区间有几个左右端点，有多少对先右后左的端点对。\r\n\r\n### [Q3029](https://qoj.ac/problem/3029)\r\n\r\n求出每条边的断裂时间，用重构树回答询问。考虑树的情况，在 $u$ 记录当前 $v$ 对 $u$ 高低的上下界要求。对于 $u$ 变化，判断在不在上下界内，再更新 $fa$ 的上下界。到平面图，给边定向，希望 $u\\to fa$ 这样的出边尽可能少。每次找到度最小的点全部定为出边，出度小于 $5$。\r\n\r\n## 7.10\r\n\r\n### [CF1844E](https://www.luogu.com.cn/problem/CF1844E)\r\n\r\n确定了第一行第一列就可以确定整个矩阵，每行每列差分值相同，取值只有 $1,2$。限制转换为差分值相等或相反，二分图染色。\r\n\r\n### [CF1693F](https://www.luogu.com.cn/problem/CF1693F)\r\n\r\n希望每次操作 $cnt0=cnt1$ 使贡献为 $1$。若整个序列 $0$ 少于 $1$，就翻转并取反序列。每次找到最长的 $cnt0=cnt1$ 前缀并删去 $cnt0$ 个 $0$，直到 $cnt0<cnt1$ 就补满 $0$ 一次做完。\r\n\r\n### [CF1656G](https://www.luogu.com.cn/problem/CF1656G)\r\n\r\n相当于从 $(1,n)$ 到 $(\\frac{n}{2},\\frac{n}{2}+1)$ 一对对填数，维护若干条链。除了最后一步，无论如何都能找到一对 $(i,j)$ 入度为 $0$ 且 $a_i=a_j$ 且不会形成环。如果 $n$ 为奇数，找到一个 $v$ 使得 $v\\neq \\frac{n+1}{2}$ 且 $t_{a_v}$ 为奇数，可能无解。\r\n\r\n### [Q5416](https://qoj.ac/problem/5416)\r\n\r\n时间逆流，覆盖等于将区域设为通配符。每次保证至少增加一个通配符即可。\r\n\r\n### [Q5504](https://qoj.ac/problem/5504)\r\n\r\n线段树优化建图跑 2-sat。要在 DAG 上找到大小之和在 $[n,2n]$ 中的后缀。如果不存在某个点大小大于 $n$，取拓扑序的一段前缀。否则判断一个大小大于 $n$ 的点的前缀后缀是否符合条件。\r\n\r\n### [CF1209G2](https://www.luogu.com.cn/problem/CF1209G2)\r\n\r\n对于每个颜色的 $[l,r)$ 加 $1$，每个极长非零连续段答案独立，选区间出现次数最多的颜色。按最小值分割，线段树维护。\r\n\r\n## 7.11\r\n\r\n### [uoj698](https://uoj.ac/problem/698)\r\n\r\n前缀线性基求交，二分。\r\n\r\n线性基 A,B 的交：对于每个 $b_i$，如果能被 $a\\cup {b_1\\dotsb b_{i-1}}$ 子集异或出来，就把方案中属于 a 的异或和加入交中。\r\n\r\n### [P2260](https://www.luogu.com.cn/problem/P2260)\r\n\r\n整除分块，$\\lfloor\\frac{n}{i}\\rfloor$ 只有 $\\sqrt n$  种取值。\r\n\r\n### [P3455](https://www.luogu.com.cn/problem/P3455)\r\n\r\n$$\\sum_{i=1}^n\\sum_{j=1}^m [gcd(i,j)=k]$$\r\n\r\n$$=\\sum_{i=1}^{\\frac{n}{k}}\\sum_{j=1}^{\\frac{m}{k}} [gcd(i,j)=1]$$\r\n\r\n$$=\\sum_{i=1}^{\\frac{n}{k}}\\sum_{j=1}^{\\frac{m}{k}}\\sum_{d\\mid gcd(i,j)}\\mu (d)$$$$\r\n\r\n$$=\\sum_{d=1}^n \\mu(d)\\frac{n}{kd}\\frac{m}{kd}$$\r\n\r\n预处理 $\\mu(d)$ 前缀和，整除分块。\r\n\r\n## 7.13\r\n\r\n### [loj3627](https://loj.ac/p/3627)\r\n\r\n$\\sum [a_i=c_{i,j}]+[b_j=c_{i,j}]-[a_i=b_j]\\le n^2$，且当且仅当 a,b 合法时取等。\r\n\r\n枚举 $x=\\sum a_i$ 和 $y=\\sum b_j$，$\\sum [a_i=b_j]$ 为定值，贪心最大化 $\\sum [a_i=c_{i,j}]+[b_j=c_{i,j}]$ 检查。\r\n\r\n### [P8340](https://www.luogu.com.cn/problem/P8340)\r\n\r\n从小到大加数，要保证 $a_i\\le sum_{i-1}$。容斥，$dp_i$ 表示当前能表示出 $[1,i]$ 。且总和为 $i$。等价于 $i$ 的互异拆分数减去之前的 $dp_j$ 乘上 $[j+2,i]$ 中的数和为 $i-j$ 的方案数。\r\n\r\n求互异拆分数，数字个数 $O(\\sqrt n)$ 个，等于从 $\\sqrt n$ 到 $1$ 完全背包加入 $i$，表示有多少个数大于 $i$。\r\n\r\n$dp_j$ 贡献给 $dp_i$ 也形如求互异拆分数，有 $i\\ge 2\\times j$。类似半在线卷积，前一半贡献给后一半。\r\n\r\n## 7.14\r\n\r\n### [P10778](https://www.luogu.com.cn/problem/P10778)\r\n\r\n找出一棵生成树，给非树边赋随机值，随机异或哈希，树边等于跨过该边的非树边的权值异或和。图不连通等价于若干条边的权值中存在子集异或和为 $0$，线性基。\r\n\r\n### [P6647](https://www.luogu.com.cn/problem/P6647)\r\n\r\n每 $k$ 分一段，每一段中使用的天数相同。$dp_i=\\max_{j=i-k}^{k\\times \\lfloor \\frac{i-1}{k}\\rfloor} dp_j+\\max_{k=j+1}^{i}a_k$。一段段计算，预处理前一段的后缀最大值，更新当前段的前缀最大值。\r\n\r\n### [CF1730F](https://www.luogu.com.cn/problem/CF1730F)\r\n\r\n按 $p_{q_i}$ 从小到大填入，设当前填完前缀 $[1,i]$，$i+1$ 没填，状压 $[i+1,i+k]$ 是否填入。\r\n\r\n### [CF1781F](https://www.luogu.com.cn/problem/CF1781F)\r\n\r\n合法状态数除以 $\\prod 2\\times i-1$。$dp_{i,x}$ 表示还有 $i$ 次插入，当前前缀和为 $x$。\r\n\r\n$$dp_{n,x}=\\sum_{i=1}\\sum_{j=1}^{n-1-i}\\binom {n-1}{i}\\times \\binom {n-1-i}{j}\\times(p\\times dp_{i,x}\\times dp_{j,x+1}\\times dp_{n-1-i-j,x}+(1-p)\\times dp_{i,x}\\times dp_{j,x-1}\\times dp_{n-1-i-j,x})$$\r\n\r\n前缀和优化。\r\n\r\n### [P10207](https://www.luogu.com.cn/problem/P10207)\r\n\r\n离散化后不同位置的球数小于 $\\sqrt T$。球会在最后一次经过时取到，设 $dp_{l,r,0/1}$ 表示取了 $[1,l)\\cup (r,n]$ 的球。分类预处理先去 $1$ 还是 $n$ 号球。\r\n\r\n### [CF1119F](https://www.luogu.com.cn/problem/CF1119F)\r\n\r\n设 $dp_{u,0/1}$ 表示当前在 $u$ ，父亲边断不断。先令 $dp_{u,0}=dp_{u,1}=\\sum dp_{v,0}$，再加上前 $d-x-0/1$ 小的 $dp_{v,1}+w-dp_{v,0}$。\r\n\r\n从小到大计算 $ans_x$。如果 $d_u\\le x$，就不用再考虑了，将 $w(u,v)$ 加入 $v$ 的堆中永不删除。每次要操作的点数之和为 $\\sum d_i$ 是 $O(n)$ 级别。\r\n\r\n### [Q1251](https://qoj.ac/problem/1251)\r\n\r\n关键点在前后缀最大值。设 $dp_{i,j,k}$ 表示前 $i$ ，之前的最大位于 $j$ ，用了 $k$ 次删除操作的面积奇偶性。只有删除操作才可能改变最大值位置，$j$ 只有 $k$ 种取值。对前后缀分别做，枚举最大值位置合并。\r\n\r\n### [arc117e](https://www.luogu.com.cn/problem/AT_arc117_e)\r\n\r\n连续段 dp，按前缀和从大往小加数，枚举这一层放多少点。\r\n\r\n## 7.15\r\n\r\n### [arc063d](https://www.luogu.com.cn/problem/AT_arc063_d)\r\n\r\n答案不小于 $2\\times (n+m)$。如果答案矩形被包含于上左下右四个子矩阵中，一定不优，所以一定跨过横向中线或竖向中线。\r\n\r\n扫描线枚举右边界，单调栈加线段树维护。\r\n\r\n## 7.16\r\n\r\n### [P5537](https://www.luogu.com.cn/problem/P5537)\r\n\r\n维护走向第几个儿子，记录从根到 $u$ 的哈希值。二分，维护区间哈希值拼上根到 $u$ 的哈希值，map 查找是否存在这个点。\r\n\r\n### [P7717](https://www.luogu.com.cn/problem/P7717)\r\n\r\n找出生成树，对于每个连通块给根找一个数 $v$ 使得 $v\\oplus dis_u\\le k$ 。等价于在 trie 树上禁止进入某个子树。\r\n\r\n### [P1117](https://www.luogu.com.cn/problem/P1117)\r\n\r\n枚举答案长度，每个 $k$ 分为一段。二分两段的最长公共前缀和最长公共后缀，平移后相交的区间意味着可以放下长为 $k$ 的合法串。差分。\r\n\r\n### [P3735](https://www.luogu.com.cn/problem/P3735)\r\n\r\n等于有一个长为 $k$ 的通配符区间的方案数减去有长为 $k-1$ 的通配符的方案数。AC 自动机加入正着和反着的串。$[1,p]$ 和 $[p+k,n]$ 必须匹配，等于查询 $u$ 的子树内有多少点与 $v$ 有关，树状数组维护，在进入退出 $u$ 时查询字子树和。\r\n\r\n## 7.17\r\n\r\n### [P7361](https://www.luogu.com.cn/problem/P7361)\r\n\r\n用 set 启发式合并 edp 集合，一个长度的贡献为相邻的 edp 点。贡献为 $min(pl-l+1,len)$。离线，扫描线。",
      "data": {
        "title": "2024.7 做题记录",
        "date": "2024-08-01 22:24:05",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20247-zuo-ti-ji-lu"
    },
    {
      "content": "## 5.09\r\n\r\n### [CF575A](https://www.luogu.com.cn/problem/CF575A)\r\n\r\n维护转移矩阵，线段树维护一段区间的矩阵乘法。\r\n\r\n### [CF1575H](https://www.luogu.com.cn/problem/CF1575H)\r\n\r\n建 KMP 自动机，$dp_{i,j,k}$ 表示前 $i$ 位，当前自动机上走到 $j$，已经匹配了 $k$ 次的最小代价。当转移到终止节点时匹配次数加 $1$。\r\n\r\n### [AT_codefestival_2016_final_h](https://www.luogu.com.cn/problem/AT_codefestival_2016_final_h)\r\n\r\n$f_{i,0/1}$ 表示从后往前走到 $i$，谁先手。发现 $f_{i,0}=-f_{i,1}$，改为一维。$f_i=\\min -f_j+sum_{j-1}-sum_{i-1}$。只与 $(i,n]$ 的 $\\min -f_j+sum_{j-1}$ 有关。$mn=\\min(mn,2\\times sum_{i-1}-mn)$。\r\n\r\n因为 $a_i\\le 10^6$，改变 $a_n$ 时 $mn$ 的初值也只有 $10^6$ 种，而中间 $sum_{i-1}$ 不变。连边 dfs 记录每个 $mn$ 初值会变成什么。\r\n\r\n## 5.10\r\n\r\n### [CF1517F](https://www.luogu.com.cn/problem/CF1517F)\r\n\r\n容斥求出半径小于 $r$ 的方案数。$dp_{u,x,y}$ 表示 $u$ 的子树内，最深的未染色点的距离和最浅的染色点的距离。发现 $x,y$ 只有一个有用。前后缀和优化，状态数 $O(dep)<O(siz)$。\r\n\r\n### [CF1951G](https://www.luogu.com.cn/problem/CF1951G)\r\n\r\n用相邻两个球之间的距离来描述一个状态，鞅与停时定理。\r\n\r\n$$1=\\frac{1}{n}\\sum f(a_i)+f(a_{i\\mod n+1})-f(a_i-1)-f(a_{i\\mod n+1}-1)$$\r\n\r\n差分 $g(x)=f(x\\mod n+1)-f(x)$。\r\n\r\n$$n\\sum g(a_i-1)-g(a_i)$$\r\n\r\n令 $g(x)-g(x-1)=\\frac{n}{m}x$，$g(0)=f(0)=0$，$g(x)=-\\frac{n}{m}\\binom{x+1}{2},f(x)=-\\frac{n}{m}\\binom{x+1}{3}$。终止势能为 $f(m)$。\r\n\r\n### [CF1007B](https://www.luogu.com.cn/problem/CF1007B)\r\n\r\n$O(n\\sqrt n)$ 预处理出每个数的所有因数，记为集合 $p_i$。显然题目要求计数 $u\\mid A,v\\mid B,w\\mid C$。容斥，大力分讨。可以用 bitset 维护交集。如果把分解因数写成先分解质因数再 dfs 求因数，复杂度 $O(n)$，常数约为 $400$。\r\n\r\n## 5.12\r\n\r\n### [CF662C](https://www.luogu.com.cn/problem/CF662C)\r\n\r\n状压每一行，记录每种状态在 $m$ 列上出现的次数和最小代价，fwt。$ans_{i\\oplus j}=\\sum num_i\\times val_j$。\r\n\r\n### [模板 子集卷积](https://www.luogu.com.cn/problem/P6097)\r\n\r\n加一维记录集合元素个数，$f_{popcount(i),i}=a_i$。先将每一维 or 卷积，再 $O(n^2)$ 将外层加法卷积。复杂度 $O(n^2 2^n)$。\r\n\r\n### [CF1034E](https://www.luogu.com.cn/problem/CF1034E)\r\n\r\n无法子集卷积。因为对 $4$ 取模，可以将 $a_i$ 乘 $4^{popcount(i)}$，然后进行不取模 or 卷积。如果 $a_i\\times b_j\\to c_k$ 且 $i\\text{&} j\\neq 0$，$popcount(i)+popcount(j)>popcount(k)$。最后 $c_i$ 除 $4^{popcount(i)}$ 再对 $4$ 取模。\r\n\r\n### [CF960G](https://www.luogu.com.cn/problem/CF960G)\r\n\r\n枚举最大值的位置，左边有 $a-1$ 个最大值，右边有 $b-1$ 个。分治NTT求 $\\prod (x+i)$。\r\n\r\n## 5.13\r\n\r\n### [CF377D](https://www.luogu.com.cn/problem/CF377D)\r\n\r\n$\\max l_i\\le L\\le \\min v_i\\le \\max v_i\\le R\\le \\min r_i$。矩形的交，扫描线。\r\n\r\n## 5.14\r\n\r\n### [CF1895F](https://www.luogu.com.cn/problem/CF1895F)\r\n\r\n容斥。存在 $a_i\\in [x,x+k-1]$ 的方案数等于 $\\min a_i\\le x+k-1$ 的方案数减 $\\max a_i<x$ 的方案数。当确定了一个序列的最小值和差分数组就可以确定一个序列。前半部分方案数为 $(x+k)\\times (2k+1)^{n-1}$。后半部分矩阵快速幂 $O(x^3\\log n)$。\r\n\r\n## 5.15\r\n\r\n### [CF1886E](https://www.luogu.com.cn/problem/CF1886E)\r\n\r\n观察发现每个项目只与程序员数量和最小值有关，所以每个项目对应能力值连续的程序员最优。状压项目数。设 $dp_{i,s}$ 为前 $i$ 个程序员匹配的项目状态为 $s$ 是否可行，无法接受。交换维度，改为 $dp_s$ 表示状态 $s$ 能与前缀 $[1,i]$ 匹配的最小 $i$。\r\n\r\n全选不一定优。预处理 $f_{i,s}$ 表示第 $i$ 个项目从 $j$ 开始匹配程序员，最少要匹配到哪里。\r\n\r\n## 5.17\r\n\r\n### [CF249D](https://www.luogu.com.cn/problem/CF249D)\r\n\r\n$j$ 贡献到 $i$ 满足 $x_j<x_i,y_i\\times b-x_i\\times a>y_j\\times b-x_j\\times a,y_i\\times d-x_i\\times c<y_j\\times d-x_j\\times c$。发现第一个限制无用，随便维护。\r\n\r\n## 5.20\r\n\r\n### [CF79D](https://www.luogu.com.cn/problem/CF79D)\r\n\r\n异或差分后 $2k$ 个关键位置，状压。$u,v$ 最短路等于同时删 $u,v$ 的代价。\r\n\r\n### [CF626F](https://www.luogu.com.cn/problem/CF626F)\r\n\r\n$dp_{i,j,k}$ 表示分了前 $i$ 人，$j$ 组没封闭，代价为 $k$。按权值从小到大加入，每个人代价是所有没封闭的组的数量乘相邻两个权值的差。\r\n\r\n## 5.21\r\n\r\n### [CF1575E](https://www.luogu.com.cn/problem/CF1575E)\r\n\r\n点分治，记录当前子树到分治中心的权值和和换车次数。将新子树的答案合并时分类讨论分治中心到子树祖先 $u\\to v$ 的颜色。树状数组维护前缀和。\r\n\r\n### [agc035d](https://www.luogu.com.cn/problem/AT_agc025_d)\r\n\r\n向距离为 $\\sqrt d$ 的点连边，为二分图。写为 $(2^ka,2^kb)$，$a\\times b \\mod 4=1/2$。在两个 $4n^2$ 个点的图上分别二分图染色，一定存在 $n^2$ 个在两张图上都同色的点。\r\n\r\n### [QTREE6](https://www.luogu.com.cn/problem/SP16549)\r\n\r\n树剖，对每个点维护当 $u$ 为 0/1 时 $u$ 子树内的最大连通块大小。还需要支持询问 $u$ 到根第一个与 $u$ 异色的点的位置，线段树上维护区间从右往左第一个 0/1 的位置。\r\n\r\n## 5.22\r\n\r\n### [agc014e](https://www.luogu.com.cn/problem/AT_agc014_e)\r\n\r\n每次选择只被覆盖一次的边删掉。树剖，线段树维护覆盖次数的最小值和位置，以及用异或维护覆盖这条边的红边编号。\r\n\r\n### [P5354](https://www.luogu.com.cn/problem/P5354)\r\n\r\n按二进制拆位贪心，树剖维护从左右进入 0/1 出来的值。压位用位运算一起做。\r\n\r\n### [CF603E](https://www.luogu.com.cn/problem/CF603E)\r\n\r\n等价于只存在大小为偶数的连通块。按权值排序加边，维护奇连通块的个数。\r\n\r\n线段树分治，每条边都有一个影响范围。从右往左分治，每次右移加边的位置。",
      "data": {
        "title": "2024.5 做题记录",
        "date": "2024-06-01 22:21:52",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20245-zuo-ti-ji-lu"
    },
    {
      "content": "## 4.7\r\n\r\n### [CF1648D](https://www.luogu.com.cn/problem/CF1648D)\r\n\r\n设 $dp_i$ 为从 $(1,1)$ 到 $(2,i)$ 的最小代价。答案为 $\\max dp_i+s3_n-s3_{i-1}$。\r\n\r\n$$dp_i=max(\\max_{l_x\\le i} dp_{l_x-1}+s2_i-s2_{l_x-1}-w_x,\\max_{l_x\\le j\\le i} s1_j+s2_i-s2_{j-1}-w_x)$$\r\n\r\n前面线段树维护 dp 值，按转移顺序区间 max，单点查。后面从后往前枚举 $i$，不断加入区间，维护 $\\max_{x\\le y} a(x)+b(y)$。另一个线段树分别维护 $maxa,maxb,maxv$。\r\n\r\n### [CF1949F](https://www.luogu.com.cn/problem/CF1949F)\r\n\r\n不合法情况要么完全包含要么不交，建立树形结构。按 $k_i$ 大小从小到大排序。实时记录每个爱好 $j$ 对应的最后的人 $f_j$。枚举 $i$ 的每个爱好 $j$，如果最后不合法意味着每个 $f_j$ 的爱好都被 $i$ 完全包含，否则找到一组解。如果最后不合法，所有 $f_j$ 的爱好数之和为 $k_i$。\r\n\r\n## 4.16\r\n\r\n### [CF1951F](https://www.luogu.com.cn/problem/CF1951F)\r\n\r\n对于 $i<j$，如果 $p_i$>p_j$ ，无论顺序逆序对贡献为 $1$；否则一个逆序对贡献为 $2$，顺序对贡献为 $0$。构造一些位置上的逆序对数为 $\\frac{k−inv(p)}{2}$ 。\r\n\r\n### [abc348g](https://www.luogu.com.cn/problem/AT_abc348_g)\r\n\r\n有决策单调性，主席树上二分。\r\n\r\n## 4.18\r\n\r\n### [CF1542E2](https://www.luogu.com.cn/problem/CF1542E2)\r\n\r\n枚举前 $i-1$ 位相同，$p_i=x$ 且 $q_i=y$。逆序对数的差异只与后 $n-i-1$ 的排列有关。$dp_{i,j}$ 表示 $i$ 个数有 $j$ 个逆序对。\r\n\r\n$$ans=\\sum_{i=0}^{n-1} A_n^i \\sum_{x=1}^{n-i-1}\\sum_{y=x+1}^{n-i-1} \\sum_{j=0}^{n^2}\\sum_{k=0}^{j+x-y-1} dp_{n-i-1,j}\\times dp_{n-i-1,k}$$\r\n\r\n记 $f_j=\\sum dp_k$。\r\n\r\n$$ans=\\sum_{i=0}^{n-1} A_n^i \\sum_{j=0}^{n^2}dp_{n-i-1,j}\\sum_{x=1}^{n-i-1}\\sum_{y=x+1}^{n-i-1} f_{j+x-y-1}$$\r\n\r\n记 $g_j=\\sum f_k$。\r\n\r\n$$ans=\\sum_{i=0}^{n-1} A_n^i \\sum_{j=0}^{n^2}dp_{n-i-1,j}\\times(g_{j-2}\\times(n-i-1)-\\sum_{x=1}^{n-i-1}g_{j+x-n+i-2})$$\r\n\r\n记 $h_j=\\sum g_k$。\r\n\r\n$$ans=\\sum_{i=0}^{n-1} A_n^i \\sum_{j=0}^{n^2}dp_{n-i-1,j}\\times(g_{j-2}\\times(n-i-1)-h_{j-2}+h_{j-n+i-2})$$\r\n\r\n### [abc349g](https://www.luogu.com.cn/problem/AT_abc349_g)\r\n\r\n最直接的就是并查集倍增将两段区间并起来。\r\n\r\n可以用类似马拉车的思路得到一个贪心算法。枚举 $i$，用 $ban_{i,j}$ 记录 $i$ 不能是 $j$，维护 $r$ 表示当前已知 $b_1\\dotsb b_r$。如果 $i+a_i\\ge r$ 就把 $r$ 更新到 $i+a_i$，否则什么也不做。最后在 hash 判断所有 $a_i$ 是不是都满足条件。\r\n\r\n## 4.19\r\n\r\n### [P3380](https://www.luogu.com.cn/problem/P3380)\r\n\r\n线段树套 FHQ，查询排名为 $k$ 时二分再查询 $mid$ 的排名，复杂度 $O(n\\log^3 n)$。\r\n\r\n权值线段树套 FHQ，FHQ 维护位置，查询排名为 $k$ 时线段树上二分，复杂度 $O(n\\log^2 n)$。\r\n\r\n### [P7831](https://www.luogu.com.cn/problem/P7831)\r\n\r\n拓扑排序转移。当当前是环是拆开 $c$ 最大的边。\r\n\r\n### [CF1778E](https://www.luogu.com.cn/problem/CF1778E)\r\n\r\n按 dfn 序，前缀线性基或合并前后缀线性基。\r\n\r\n### [arc173e](https://www.luogu.com.cn/problem/AT_arc173_e)\r\n\r\n观察到：只能选偶数个，且当 $n=4k+2,k>0$ 时不能全选。\r\n\r\n线性基选偶数个数：插入 $a_i\\oplus a_1$。\r\n\r\n## 4.23\r\n\r\n### [P4839](https://www.luogu.com.cn/problem/P4839)\r\n\r\n猫树分治，维护 $[l,mid]$ 的前缀线性基和 $(mid+1,r]$ 的后缀线性基。在 $[ql,qr]$ 跨越 $mid$ 时合并。复杂度 $O(nlog^2n)$。\r\n\r\n### [P5607](https://www.luogu.com.cn/problem/P5607)\r\n\r\n维护差分数组。区间 $a_{l,\\dotsb,r}$ 的线性基等价于 $a_l$ 和 $b_{l+1,\\dotsb,r}$ 的线性基。\r\n\r\n### [P10282](https://www.luogu.com.cn/problem/P10282)\r\n\r\n$dp_{i,j}\\to dp_{k,l}$。对 $i,j$ 往后的转移按平均值从小到大，一边前缀和一边双指针。\r\n\r\n## 4.25\r\n\r\n### [P6134](https://www.luogu.com.cn/problem/P6134)\r\n\r\n如果删去边 $(u,v)$ 后 $u$ 到 $v$ 的路径依然存在，那就删去。bitset 维护可达性。\r\n\r\n### [P3733](https://www.luogu.com.cn/problem/3733)\r\n\r\n先找出最小生成树，线段树分治其他的边，套上线性基维护每个环的最大异或值，见 [[WC2011] 最大XOR和路径](https://www.luogu.com.cn/problem/P4151)。\r\n\r\n### [CF938G](https://www.luogu.com.cn/problem/CF938G)\r\n\r\n[P3733](https://www.luogu.com.cn/problem/P3733) 加强。不一定存在一直存在的生成树。线段树分治。记录每个点的父亲和到父亲的边权。对边 $(u,v)$，如果 $u,v$ 在同一个联通块，加入线性基；否则 $fd(u)$ 和 $fd(v)$ 连 $w\\oplus dis(u,fd(u))\\oplus dis(v,fd(v))$。\r\n\r\n## 4.26\r\n\r\n### [CF875F](https://www.luogu.com.cn/problem/CF875F)\r\n\r\n连二选一的两个点，最多允许存在基环树，求最大生成基环树。\r\n\r\n### [CF1666K](https://www.luogu.com.cn/problem/CF1666K)\r\n\r\n每个点拆为 $a_i,b_i$ ，最小割，$s\\to a_i$ 表示 $i\\in A$，否则 $i\\notin A$；$s\\to b_i$ 表示 $i\\in B$，否则 $i\\notin B$。00 或 11 表示 $i\\inC$。\r\n\r\n### [P10371](https://www.luogu.com.cn/problem/P10371)\r\n\r\n每个数维护 $l_{i,0/1} ,r_{i,0/1}$ 表示左右第一个、第二个大于 $a_i$ 的位置。分类讨论 $p=l,r$ 或 $l<p<r$。\r\n\r\n## 4.28\r\n\r\n### [P7497](https://www.luogu.com.cn/problem/P7497)\r\n\r\n线段树维护区间未封个数，未封之和，封了的和，封的次数。封过的区间不参与上传下放，解封时从下面上传。\r\n\r\n## 4.30\r\n\r\n### [agc033d](https://www.luogu.com.cn/problem/AT_agc033_d)\r\n\r\n$dp_{i,j,k,l} 的答案，复杂度 $O(n^5)$。\r\n\r\n注意到答案小于 $\\log nm$。交换维度。$dp_{ans,i,j,l}$ 表示答案为 $ans$，$(i,j)$ 到 $(dp_{ans,i,j,l},l)$ 最大。\r\n\r\n$$dp_{ans,i,j,l}=\\max(dp_{ans−1,i,j,l} ,dp_{ans−1,dp_{ans−1,i,j,l} +1,j,l},\\max(\\min(dp_{ans−1,i,j,k} ,dp_{ans−1,i,k+1,l})))$$\r\n\r\n$k$ 维有单调性，双指针。\r\n\r\n### [P7864](https://www.luogu.com.cn/problem/P7864)\r\n\r\n结论：一个点存在两个叶子则必胜。\r\n\r\n### [CF1091H](https://www.luogu.com.cn/problem/CF1091H)\r\n\r\n只与和中间点的距离有关，$2n$ 个 sg 值亦或起来。\r\n\r\n发现 sg 值不大，记 $nxt_{j,i}$ 为 $i$ 的后继有 sg 值为 $j$ 的。预处理素数，bitset 转移。",
      "data": {
        "title": "2024.4 做题记录",
        "date": "2024-05-01 22:21:35",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20244-zuo-ti-ji-lu"
    },
    {
      "content": "二月没写\r\n\r\n## 3.05\r\n\r\n###  [CF671D](https://www.luogu.com.cn/problem/CF671D)\r\n\r\n设 $dp_{u,i}$ 表示覆盖完 $u$ 子树，向上覆盖到深度 $i$ 的最小代价。要求区间取 min，区间加，线段树合并。\r\n\r\n### [CF1175G](https://www.luogu.com.cn/problem/CF1175G)\r\n\r\n$$dp_i=\\min(f_j+(i-j)\\times \\max a_k)$$\r\n\r\ncdq 分治。记 $mx_i$ 表示 $(i,mid]$ 或 $[mid+1,i]$ 的 $a_k$ 最大值。\r\n\r\n$$dp_i=\\min(f_j+(i-j)\\times \\max(mx_i,mx_j))$$\r\n\r\n分类讨论 $mx_j\\le mx_i$：$dp_i=\\min(j\\times (-mx_i)+f_j)+i\\times mx_i$。枚举 $i$，不断加入 $j$，单调栈维护一次函数 $y=jx+f_j$，斜率递减，查询的横坐标不增。反之同理。\r\n\r\n## 3.06\r\n\r\n### [CF1530H](https://www.luogu.com.cn/problem/CF1530H)\r\n\r\n时间倒流，第一次到达一个点写下数字。每次会往当前形成的段前后加数，需要花费时间跨越整个段。所以除了 $a_n$ 可能不是 lis 以外，所有向左右拓展的数都是 lis 的一部分。设 $f_{l,i}$ 表示当前有长为 $l$ 的连续段，从后往前遍历到 $i$ 且 $a_i$ 填入最左时最右的最小值。$g_{l,i}$ 相反。\r\n\r\n$$f_{l,i}=\\max(\\max_{j>i\\lor a_j>a_i} f_{l-1,j},\\max_{j>i\\lor g_{l-1,j}>a_i} a_j)$$\r\n\r\n分类讨论 $a_n$，树状数组维护前缀 max 和后缀 min。\r\n\r\n随机排列的 lis 期望长度为 $O(\\sqrt n)$，复杂度 $O(n\\sqrt n\\log n)$。\r\n\r\n## 3.07\r\n\r\n### [P5044](https://www.luogu.com.cn/problem/P5044)\r\n\r\n设 $dp_{l,r}$ 表示 $[l,r]$ 的答案。取 $mid$ 为 $[l,r]$ 中最大 $a_i$ 的位置。\r\n\r\n$$dp_{l,r}=\\min (dp_{l,mid}+(r-mid)\\times a_{mid}+dp_{mid+1,r}+(mid-l+1)\\times a_{mid})$$\r\n\r\n区间最大值有关的 dp，建出笛卡尔树。递归左右子树得到 $dp_{l,i},l\\le i\\le mid$ 和 $dp_{mid+1,i},mid+1\\le i\\le r$，只考虑以树上节点对应的区间的 $l$ 为左端点的 dp 值。将询问拆成 $[l,mid-1]$ 和 $[mid+1,r]$，挂在 $l=ql,r=mid$ 的节点，另一半反过来再做。\r\n\r\n对于左端点在 $l$ 且跨过 $mid$ 的答案，min 左边增幅为 $a_{mid}$，右边小于等于 $a_{mid}$，单调。线段树维护，支持区间加一次函数，线段树上二分。\r\n\r\n## 3.08\r\n\r\n### [P3246](https://www.luogu.com.cn/problem/P3246)\r\n\r\n莫队。当向右拓展时，加上 $[l, r+1],\\dotsb ,[r+1,r+1]$ 的贡献。设区间最小值位置为 $p$，$p$ 以左加上 $a_p$。设 $f_{l,r}$ 为以 $r$ 为右端点，左端点在 $[l,r]$ 的贡献。$pre_i$ 为 $i$ 左边第一个比 $a_i$ 小的位置。\r\n\r\n$f_{l,r}=f_{l,pre_r}+a_r\\times (r-pre_r)$。与 $l$ 无关，变成前缀和。\r\n\r\n### [P5283](https://www.luogu.com.cn/problem/P5283)\r\n\r\n做前缀和。转换为选 $2*k$ 个有序对的和最大值除以 $2$。将 $a_0\\dotsb a_n$ 插入 trie，对每个 $i$ 求出第 $num$ 大的 $a_i xor a_j$，扔进优先队列，取出时加入 $num+1$ 大。\r\n\r\n### [CF1253F](https://www.luogu.com.cn/problem/CF1253F)\r\n\r\n求出每个点到最近的关键的的距离 $dis_u$。能从 $u$ 走到 $v$ 则有 $dis_u+dis_v+e_{u,v}\\le c$。建最小生成树，倍增求路径最大值。\r\n\r\n## 3.09\r\n\r\n### [CF1286E](https://www.luogu.com.cn/problem/CF1286E)\r\n\r\n维护当前 border 集合。从 $i-1$ 的合法集合过来，如果 $s_{x+1}\\ne s_i$ 则删去，如果 $s_i=s_1$ 则加入 $[i,i]$。一共只有 $O(n)$ 个 border。\r\n\r\n考虑删除那些。对于每个节点每种颜色找出在 nxt 上，$s_{x+1}=s_{i+1}$ 的最近祖先，把除了颜色 $s_i$ 的一路跳上去删掉。末尾添数维护 st 表最小值计算删除的代价。每个删一次，复杂度 $O(n\\log n)$。\r\n\r\n对于合法的那些，权值对 $a_i$ 取 min。用 map 维护每个权值的个数，将大于 $a_i$ 的数量加进 $a_i$，每个权值操作一次，复杂度 $O(n\\log n)$。\r\n\r\n### [CF1202E](https://www.luogu.com.cn/problem/CF1202E)\r\n\r\n枚举分界点 $p$，以 $p$ 结尾匹配 $s_i$，以 $p+1$ 开始匹配 $s_j$ 的方案数之积。建 ACAM，当前节点 fail 树到根的路径上的终止状态数为比配数，反转再做另一边。\r\n\r\n### [CF1854D](https://www.luogu.com.cn/problem/CF1854D)\r\n\r\n可以 $\\log n=9$ 次二分出一个点走 $k$ 步到哪里。有两种用法：求出走 $n+1$ 步得到环上的某个点和走 $1$ 步得到该点下一个点。\r\n\r\n先找出一个点在 $1$ 联通块的环上，在向下走 $124$ 步找到环上连续的 $125$ 个点。对剩下 $375$ 个点找出 $125$ 步到这 $125$ 个点之一的点。这时至少已知环上连续的 $250$ 个点，有一半的环已知，其他的点走 $n+1$ 步或 $n+1+250$ 步如果在联通块内则一定能到这一半的环。总步数 $9\\times 125+375+2\\times 250=2000$。\r\n\r\n这么做的关键是环上连续点长度可以倍增，如果将 $125$ 调小步数更少。\r\n\r\n## 3.11\r\n\r\n### [CF1916F](https://www.luogu.com.cn/problem/CF1916F)\r\n\r\n加强构造条件，改为：构造一个逐步染黑序列，使得每一时刻黑白导出子图都连通。每次选一个与黑色点有连边且不是白导出子图的割点的白点染黑。\r\n\r\n证明一定有这样的点。找到白导出子图中只与一个割点相邻的块，如果黑导出子图与这个块没有连边，改割点是全图割点，但是原图是点双，矛盾。所有一定存在可以染的点。每次求割点，复杂度 $O(nm)$。\r\n\r\n### [CF1218G](https://www.luogu.com.cn/problem/CF1218G)\r\n\r\n先猜测最后每个点权值 $mod 3$为集合编号。边权为 $3$ 相当于删掉这条边。找出一颗生成树，从下往上定边权可以满足除根以外的所有点。再调整根。\r\n\r\n如果存在一个奇环，将每条边权交替加 $1$ 或 $2$，可以只改一个点，将根设在环上。否则二分图，左部为 $1$，右部 为 $2$，左部点为根，选出与根相连的两条边加一，$w_{rt}=1,w_u=w_v=0$。\r\n\r\n## 3.12\r\n\r\n### [[省选联考 2024] D1T2 魔法手杖](https://www.luogu.com.cn/problem/P10218)\r\n\r\n将 $a_i$ 插入 01 trie，从高位到低位考虑。在第 $dep$ 位，以前选的数 $x$，当前 $S$ 集合中最小值 $y$，当前答案 $z$。记录 trie 节点 $a$ 最小值和 $b$ 的和。\r\n\r\n如果填 $x=0$，左边小于右边。如果左边可以全部进入 $S$：如果左边进入后的 $y$ 无论如何都没右边大，更新答案；否则更新 $y$ 进入左边。否则：如果 $y$ 无论如何都没有右边大，更新答案；否则右边最小，进入右边。\r\n\r\n### [[省选联考 2024] D2T1 迷宫守卫](https://www.luogu.com.cn/problem/P10220)\r\n\r\n设 $dp_{u,i}$ 表示节点 $u$ 且第一个是 $i$ 的最小代价，记录从什么转移而来。\r\n\r\n$$dp_{u,\\min(i,j)}=dp_{ls,i}+\\min(a_u,dp_{rs,j})$$\r\n\r\n再 dfs 一边，可以花费代价调整一些选择升级答案。特别注意可以选择将选择 $a_u$ 改为选择 $dp_{rs,j}$。\r\n\r\n注意到合法状态 $O(n2^n)$ 个，前后缀优化，复杂度 $O(n2^n)$。\r\n\r\n## 3.13\r\n\r\n### [CF1852E](https://www.luogu.com.cn/problem/CF1852E)\r\n\r\n把每个数记录为 $(l,r,x)$，如果有包含更小的把更小的扔掉，BIT 维护。先考虑 $ans_l=ans_r=x$，再把每个点改为包含他的数的最大值。但是可能有不在原数组中的数，有且只有一个。从高到低枚举 $x$，取 $nw$ 为小于 $x$ 且不存在于原数组的最大数，如果 $nw$ 的 $(l,r,nw)$ 被 $x$ 的 $(L,R,x)$ 包含，就可以将 $[L,R]$ 中非端点的数改为 $nw$，算一下答案取 $sum$ 最大的 $nw$。\r\n\r\n### [CTT2021 D3T1 小明的树](https://www.luogu.com.cn/problem/P8990)\r\n\r\n每一个白点子树内的节点都是白点，等价于黑点形成联通块。树上联通块数等于点数减边数。白连通块数等于异色边数。\r\n\r\n维护 $(x,v)$ 表示连通块数 $x$，权值为 $v$，求 $x=1$ 时 $\\sum v$。$x_i$ 初始值取 $n-i-(n-1)$，对于一条边 $(u,v)$，设 $u$ 比 $v$ 先遍历到，$x_{t_u}\\dotsb x_{n-1}$ 加 $1$，$v_{t_u}\\dotsb v_{t_v-1}$ 加 $1$。维护区间最小值大小、数量、权值和，区间加。\r\n\r\n## 3.15\r\n\r\n### [CF1930F](https://www.luogu.com.cn/problem/CF1930F)\r\n\r\n$$\\max(\\max(a_i \\mathrm{or} x)-\\min( a_i \\mathrm{or} x))=\\max(a_i \\mathrm{or} a_j-a_j)=\\max(a_i-a_i \\mathrm{and} a_j)$$\r\n\r\n从高往低贪心 $\\min x \\mathrm{and} a_i$ 和 $\\max x \\mathrm{or} a_i$。维护当前 $a_i$ 的超集和子集。\r\n\r\n### [CF1236F](https://www.luogu.com.cn/problem/CF1236F)\r\n\r\n拆方差的期望：$E((x-E(x))^2)=E(x^2-2xE(x)+E(x)^2)=E(x^2)-E(x)^2$。\r\n\r\n连通块数等于点数 $v$ 减边数 $e$ 加环数 $c$。\r\n\r\n$$E(x^2)=E(a)^2+E(b)^2+E(c)^2-2E(ab)+2E(ac)-2E(bc)$$\r\n\r\n### [CF1025G](https://www.luogu.com.cn/problem/CF1025G)\r\n\r\n鞅与停时。对于有 $x$ 个儿子的点，设计函数 $f_x$。\r\n\r\n$$f_x+f_y-1=\\frac{1}{2}(x\\times f_0+f_{y+1}+y\\times f_0+f_{x+1})$$\r\n\r\n可以 $O(n^3)$ 高斯消元。找规律令 $x=y$，\r\n\r\n$$2\\times f_x-1=x\\times f_0+f_{x+1}$$\r\n\r\n$f_x=(x+1)\\times f_0-2^x+1$，且 $f_{n-1}=0$。\r\n\r\n带回去发现符合条件。所以 $f_A=\\sum f_x$。复杂度 $O(n)$。\r\n\r\n### [CF1801E](https://www.luogu.com.cn/problem/CF1801E)\r\n\r\n并查集将相同的连在一起。总共有 $n-1$ 个有效状态，只要没有重复做就可以。倍增 $u$ 向上 $2_i$ 个祖先的状态，分别考虑从下往上和从上往下。将两条路径拆为 $3$ 段，每段倍增 $O(\\log n)$ 次合并。每次合并向下一层递归合并，如果已经是一个连通块的及时退出。复杂度 $O(n\\log^2 n)$。\r\n\r\n## 3.17\r\n\r\n### [CF983D](https://www.luogu.com.cn/problem/CF983D)\r\n\r\n离散化。对 X 轴扫描线，线段树维护 Y 轴区间。记录区间已选最小和未选最大，set 维护区间里所有的值。每次如果有未选最大大于已选最小，打标记，再做一次。复杂度 $O(n\\log^2 n)$。\r\n\r\n## 3.18\r\n\r\n### [CF850F](https://www.luogu.com.cn/problem/CF850F)\r\n\r\n设 $f_i$ 为已有 $i$ 个球为钦定颜色。\r\n\r\n$$f_i=f_{i-1}\\times \\frac{i\\times (sum-i)}{sum\\times(sum-1)}+f_{i+1}\\times \\frac{(sum-i)\\times i}{sum\\times(sum-1)}+f_i\\times(1-\\frac{i\\times (sum-i)}{sum\\times(sum-1)})+v$$\r\n\r\n其中 $v$ 为当前局面钦定颜色成为最后颜色的概率，见 [P5155](https://www.luogu.com.cn/problem/P5155)。移项得 $O(n)$ 递推式。答案为 $\\sum f_{a_i}$。\r\n\r\n### [CF1037G](https://www.luogu.com.cn/problem/CF1037G)\r\n\r\n对于每个区间算 SG 值，枚举删 $c$，转换为若干个子区间的 SG 异或，前缀和维护，复杂度 $O(\\mid \\sum\\mid)$。考虑有用的区间，是两个相同字符间的一段以及前后缀。共 $O(n\\sum)$ 个区间，从小到大计算，复杂度 $O(n\\mid\\sum\\mid^2)$。\r\n\r\n## 3.19\r\n\r\n### [CF319E](https://www.luogu.com.cn/problem/CF319E)\r\n\r\n并查集维护强连通分量以及最左和最右。线段树 vector 维护节点对应的线段，每次加入一条线段，把之前线段经过当前左右端点的并入连通块，再把当前线段拆成 $\\log n$ 段扔进线段树节点。\r\n\r\n### [CF547E](https://www.luogu.com.cn/problem/CF547E)\r\n\r\n拆为对 $s_{1\\dotsb i}$ 询问 $s_k$。建 AC 自动机，把 $s_i$ 每个前缀对应的状态加 $1$，求 fail 树上的子树和，dfn 序加树状数组。\r\n\r\n### [CF587F](https://www.luogu.com.cn/problem/CF587F)\r\n\r\n反过来，答案为将 $s_k$ 每个前缀加 $1$ 求 $s_{l\\dotsb r}$ 终止节点的 fail 子树和。\r\n\r\n根号分治。对于大于 $B$ 的串，先将 $s_k$ 每个前缀对应位置加 $1$，此时每个 $s_i$ 终止节点的子树和就是 $s_i$ 的贡献，前缀和。复杂度 $O(\\frac{\\mid S\\mid^2}{B})$。否则从 $1$ 到 $n$，区间加单点查，dfn 序加树状数组，复杂度 $O(qB\\log {\\mid S\\mid})$。\r\n\r\n### [CF618F](https://www.luogu.com.cn/problem/CF618F)\r\n\r\n加强构造条件，任意排序 A 和 B 一定有两个子段相等。即两对 $a_i=b_j$。\r\n\r\n令 $a_n<b_n$。对于每个 $i$ 找到最小的 $b_j\\ge a_i$，有 $b_j-a_i\\in [0,n)$。$n+1$ 个数，值域为 $n$，一定存在相等。\r\n\r\n## 3.20\r\n\r\n### [CF924F](https://www.luogu.com.cn/problem/CF924F)\r\n\r\n对于一个数字做背包，$f_i$ 表示当前位能不能凑出 $i$。$f_i->f_{\\mid i-v\\mid}$，$f_i->f_{i+v}$。答案一定在 $[0,9]$ 中，发现大于 $72$ 的背包不优。\r\n\r\n当做 $18$ 位时，这个背包状态有 $12880$ 种，$12880$ 也是全部状态数。可以用数位 dp 套这个背包。宽搜所有转移。\r\n\r\n设 $f_{dep,u,k}$ 为当前剩下后 $dep$ 位随便选，当前在内层自动机的位置为 $u$，最最小值小于 $k$ 的答案。$T$ 组询问，差分询问 $x$，按 $x$ 从高位到低位在自动机上走，如果没有限制就加上对应的 f 值。\r\n\r\n记录状态一个 $73$ 位 01 串方面，卡哈希，可以考虑用一个 ```pair``` 记两个 ```long long``` 表示前一半后一半的值。\r\n\r\n## 3.21\r\n\r\n### [CF1685C](https://www.luogu.com.cn/problem/CF1685C)\r\n\r\n前缀和。反转 $[l,r]$ 后 $b_i=a_{l-1}+a_r-a_{i'}$。取最大的 $a_x$，操作 $[1,x]$ 和 $(x,2\\times n]$。$b_i=a_x-a_{i'}\\ge 0$。\r\n\r\n特判不用做，考虑做一次。找到第一个小于 $0$ 和最后一个大于 $0$ 的区间 $[l,r]$，翻转 $[ll,rr]$ 且 $ll\\le l,rr>r$。$\\max_{i=l}^{r} a_i\\ne a_{ll-1}+a_{rr}$，找到最大的 $a_{ll-1}$ 和 $a_{rr}$ 判断。\r\n\r\n### [P8376](https://www.luogu.com.cn/problem/P8376)\r\n\r\n递增子序列以 $2^x$ 增加，将 $k$ 二进制拆分。设 $tp$ 是 $k$ 二进制最高位，先造长为 $tp$ 的连续单调上升。加入 $2^i$ 时，不断下降放在最开始的单调上升的后 $i$ 个之前。共 $60\\times 2>90$。考虑将后面部分两步改为一步。如果有连续的 $i$ 和 $i-1$ 需要操作，直接在 $i-1$ 前放大于后面放的最小值和次小值的数。\r\n\r\n### [P9520](https://www.luogu.com.cn/problem/P9520)\r\n\r\n因为是一棵树，最短路径唯一，所以每次都让一个人走到底。当走 $s->t$，$s->t$ 中此时没有点，意味着起点这条路径上的人一定先于这个人走，终点在这条路径上的人一定后于这个人走。连边跑拓扑排序看有没有环。复杂度 $O(n^2)$。倍增优化 $O(n\\log n)$。\r\n\r\n## 3.22\r\n\r\n### [P7561](https://www.luogu.com.cn/problem/P7561)\r\n\r\n曼哈顿转切比雪夫，二分答案，扫描 X 轴，set 维护 Y 轴，二分 $y_i-mid$，枚举到 $y_i+mid$，找到大于 $k$ 个就返回。复杂度 $O(n\\log^2n)$。\r\n\r\n### [P9734](https://www.luogu.com.cn/problem/P9734)\r\n\r\n如果多天走完。第一天，时间倒流，$n$ 次最短路以 $s$ 为终点，从 $i$ 出发的最晚时间。最后一天，$n$ 次最短路以 $s$ 为起点，到 $i$ 的最早时间。中间部分，把最后一天算出来的一天能走到的 $u,v$ 连边权为 $S$ 的边做弗洛伊德。复杂度 $O(n^3)$。对于每个询问，枚举第一天去哪里，最后一天开始时在那里，复杂度 $O(qn^2)$。对于已知的第一天终点和全程终点，$O(n^3)$ 预处理最后一天终点，复杂度 $O(n^3+qn)$。\r\n\r\n如果一天走完，答案只可能有 $m$ 次变大。算出每条边断开前 $u->v$ 的最晚出发时间和答案，去掉被包含的部分，二分查询的时间属于那一段。复杂度 $O(n^4\\log n+q\\log n)$。\r\n\r\n## 3.25\r\n\r\n### [CF396C](https://www.luogu.com.cn/problem/CF396C)\r\n\r\n对于一个点维护 $b_i=a_i-a_{fa_i}$。对于操作一，等价于 $b_u$ 加 $x$，$u$ 的子树不含 $u$ 减 $k$。对于操作二，等价于从根到 $u$ 路径上的 $b_x$ 的和。子树加，路径查，树剖加线段树。\r\n\r\n## 3.26\r\n\r\n### [P10272](https://www.luogu.com.cn/problem/P10272)\r\n\r\n分类讨论。如果 $S$ 存在一个周期，设最小周期长为 $len$。那么第 $i$ 次操作是在 $i-1$长度上加 $(n-len)\\times 2^i$。用字符串哈希判断是否存在长为 $i$ 的周期，只需要判断 $s[1,n-i]=s[i+1,n]$ 。\r\n\r\n如果 $S$ 不存在一个周期，找到真 border $T$，再找到 $T$ 的最小周期 $TT$，发现此时答案只取决于 $S$ 开头存在 $num$ 个连续的 $TT$。记 $cnt=\\frac{\\mid T\\mid}{\\mid TT\\mid}$，发现每次操作答案增加 $\\min(cnt\\times 2^i,num)$ 个 $TT$。模拟前 $\\log n$ 次操作后每次操作答案增加为定值，计算等差数列。\r\n\r\n### [NOI模拟3.26 T1 礼物(gift)](http://www.gdfzoj.com:23380/contest/941/problem/8789)\r\n\r\n求最大的 $\\sum[v_i\\times t+a_i\\equiv 0(\\mod 2^l)]\\times w_i$。\r\n\r\n$tv\\equiv a(\\mod 2^l)$。不一定有逆元。设 $t=\\frac{q}{2^p}$，得到 $t\\equiv (\\frac{v}{2^p2^c})^{-1}\\frac{a}{2^c}(\\mod 2^{l-c})$。当 $v$ 中恰好有 $p+c$ 个 $2$ 且 $a$ 中至少有 $c$ 个 $2$ 是有解。每次枚举 $p$，从低到高建 trie 树，把贡献加在 $q$ 对应的位置上，相当于整个子树都有加 $w$ 的贡献。答案为最大的链和。\r\n\r\n### [NOI模拟3.26 T2 逆序对(inv)](http://www.gdfzoj.com:23380/contest/941/problem/8790)\r\n\r\n[P5853](https://www.luogu.com.cn/problem/P5853)。求所有长为 $n$ 的逆序对数为 $k$ 的排列中 $i$ 在小根笛卡尔树上的深度之和。\r\n\r\n先 dp 满足逆序对数的排列个数。加入第 $i$ 个数产生 $[0,i-1]$ 对逆序对。将深度转为祖先个数。$v>u$ 是 $u$ 的祖先，即 $v$ 处逆序对数贡献为 $0$，撤销背包即可。翻过来再做一遍。\r\n\r\n## 3.27\r\n\r\n### [NOI模拟3.26 T3 字符串(word)](http://www.gdfzoj.com:23380/contest/941/problem/8791)\r\n\r\n[Q6842](https://qoj.ac/problem/6842)。$w(l,r)=s_l\\dotsb s_r$，其中 $s_i=popcount(i)\\mod 2$。$S$ 为 $n$ 个 $w(l_i,r_i)$ 顺次拼接，$q$ 次询问 $p$在 $S$ 中出现次数。\r\n\r\n对 $p_i$ 建 AC 自动机，答案为在自动机上走 $S$，走到的每个节点加 $1$，$p_i$ 终止节点的 fail 树子树和。\r\n\r\n倍增拆开 $S$。记 $a(n,i=0/1)$ 为 $w(0+i2^n,i2^n+2^n-1)$，有 $a(n,i)=a(n-1,i)+a(n-1,i\\oplus 1)$。对于 $i=k2^n$，也有 $w(i,i+2^m-1)=a(n,popcount(i)\\mod 2)$。所以可以将 $[l,r]$ 拆为 $O(\\log n)$ 个区间。\r\n\r\n记 $to_{i,u,0/1}$ 表示自动机上 $u$ 节点走 $a(i,0/1)$ 到的点，$cnt_{i,u,0/1}$ 为自动机上 $u$ 节点走 $a(i,0/1)$ 的次数。分别从下一层和上一层得到。\r\n\r\n## 3.28\r\n\r\n### [P3502](https://www.luogu.com.cn/problem/P3502)\r\n\r\n设 $dp_{i,j}$ 表示选了 $i$ 个，以第 $j$ 个串结尾的长度。$O(n^3)$ 哈希处理转移，矩阵快速幂。\r\n\r\n### [P6190](https://www.luogu.com.cn/problem/P6190)\r\n\r\n弗洛伊德算一次魔法从 $i$ 到 $j$ 的代价。矩阵快速幂。\r\n\r\n### [P7215](https://www.luogu.com.cn/problem/P7215)\r\n\r\n对于颜色 $i$ 的两个点 $u,v$，选颜色 $i$ 就路径 $u\\to v$ 上的所有颜色都要选。倍增优化建图，每个节点连向对应颜色，$i$ 连向所有颜色为 $i$ 的节点的 lca 到颜色为 $i$ 的节点的链连边。缩点，入度为 $0$ 的 scc 中有效的点的数量。\r\n\r\n### [CF549F](https://www.luogu.com.cn/problem/CF549F)\r\n\r\n以区间最大值区间为中点，枚举短的一边，二分另一半。复杂度 $O(n\\log^2 n)$。\r\n\r\n## 3.29\r\n\r\n### [P4948](https://www.luogu.com.cn/problem/P4948)\r\n\r\n- $a\\neq 1$：\r\n\r\n$$s_k=\\sum i^ka^i=\\sum (i+1)^ka^(i+1)-(n+1)^ka^{n+1}+a$$\r\n\r\n$$s_k=\\sum_{i=1}^n\\sum_{j=0}^k\\binom{k}{j} i^ja^{i+1}-(n+1)^ka^{n+1}+a$$\r\n\r\n$$s_k=a\\sum_{j=0}^k\\binom{k}{j}s_j-(n+1)^ka^{n+1}+a$$\r\n\r\n- $a=1$\r\n\r\n$$s_k=\\sum i^k=\\sum (i+1)^k-(n+1)^k+1$$\r\n\r\n$$s_k=\\sum_{i=1}^n\\sum_{j=0}^k\\binom{k}{j} i^j-(n+1)^k+1$$\r\n\r\n$$0=\\sum_{j=0}^{k-1}\\binom{k}{j}s_j-(n+1)^k+1$$\r\n\r\n$$\\binom{k+1}{k}s_k=(n+1)^{k+1}-\\sum_{j=0}^{k-1}\\binom{k+1}{j}s_j-1$$\r\n\r\n### [AT_yahoo_procon2019_qual_e](https://www.luogu.com.cn/problem/AT_yahoo_procon2019_qual_e)\r\n\r\n选一些行异或，如果不是全零的话答案为 $2^{m-1}$。只需要求若干行异或后全零的方案数，将一行看作大小为 $m$ 的数，bitset 维护做线性基。\r\n\r\n### [CF1368G](https://www.luogu.com.cn/problem/CF1368G)\r\n\r\n移动骨牌相当于移动空格，按黑白分开，可以移动的连有向边，可以证明这是两组森林。去掉一个骨牌两个空格可以移动到两个子树任意位置，但有重复。用 dfn 序记录一段区间，扫描线算矩阵面积并。\r\n\r\n### [abc291g](https://www.luogu.com.cn/problem/AT_abc291_g)\r\n\r\n$a+b-a and b=a or b$。转换为最小 and 和。每一位单独贡献。01 序列的 and 相当于乘法。对每个循环位移长度 $i$ 记 $ans_i$。\r\n\r\n把 b 复制一遍。$ans_j=\\sum_k \\sum_i a_{i,k}\\times b_{i+j,k}$。差卷积。\r\n\r\n## 3.30\r\n\r\n### [noip模拟3.31 T2 柳绿更带朝烟(farmland)](http://www.gdfzoj.com:23380/contest/944/problem/8793)\r\n\r\n [P3006](https://www.luogu.com.cn/problem/P3006)。以 $1$ 为根的有根树，每个节点有一定数量的奶牛，每单位时间每条边限制流量，奶牛单位时间内可以移动多步，多组询问一定时间内能到达根的最多的奶牛个数。\r\n\r\n计算每个点人数减少速度。当一个点送完人后，再有人从下方送来直接往上转，所以可以在并查集上将 $u$ 与 $fa_u$ 合并。从小到大处理，知道询问属于哪个段即可。\r\n\r\n### [noip模拟3.31 T3 花落家童未扫(petal)](http://www.gdfzoj.com:23380/contest/944/problem/8794)\r\n\r\n若 $\\min_{i=l}^r a_i\\leq r-l+1\\leq \\max_{i=l}^r a_r$，则 $[l,r]$ 符合条件。求有多少种合法划分方案数。\r\n\r\n$f_{i+1}=\\sum f_j\\times [[j,i] 合法]$。容斥，等于所有减不满足 min 减不满足 max 加两个都不满足。考虑合法区间的矩形面积并，对于每个 $i$，满足 min 的区间形如一个矩形减一个平行于 $y=x$ 的三角形。三角形无法扫面线，但是可以看成以区间最小值分治然后枚举短的一边。所以把 $O(n)$ 个矩形减三角形拆成 $O(n\\log n)$ 个矩形。维护区间最小值和最小值对应的 f 值，扫描线更新 f。",
      "data": {
        "title": "2024.3 做题记录",
        "date": "2024-04-01 22:20:01",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20243-zuo-ti-ji-lu"
    },
    {
      "content": "###  完全二叉树求 lca\r\n\r\n学习自 [https://blog.csdn.net/kksleric/article/details/7836649](https://blog.csdn.net/kksleric/article/details/7836649)\r\n\r\n先考虑完全二叉树的 lca 求法。中序遍历分配编号。\r\n\r\n![](https://yhddd123.github.io/post-images/1729329324560.jpg)\r\n\r\n设第 $k$ 位是 $u\\oplus v$ 最左边的 $1$，则 $lca(u,v)$ 是 $u,v$ 的 $k$  位以左、第 $k$ 位是 $1$，$k$ 位以右是 $0$。\r\n\r\n将树上 lca 转到完全二叉树上。\r\n\r\n先序遍历，设 $h_u$ 表示 $dfn_u$ 的末尾连续 $0$ 数，$l_u$ 表示 $u$ 子树内最大 $h_u$ 的值，$mx_u$ 表示 $l_u$ 对应的 $dfn_u$ 。相等的 $mx_u$ 形成若干条链。有若 $tp$ 是 $u$ 的祖先，$mx_{tp}$ 是 $mx_u$ 完全二叉树中的祖先。\r\n\r\n![](https://yhddd123.github.io/post-images/1729329338382.jpg)\r\n\r\n设 $tp=lca(u,v)$。则 $mx_{tp}$ 是 $mx_u,mx_v$ 的公共祖先。树上根到节点路径上 $l_u$ 单调不降，但在树上的 $mx_u$ 值不连续。设 $a_u$ 表示从根到 $u$ 哪些 $l_u$ 值存在。可以求出 $mx_u$ 和 $mx_v$ 在完全二叉树上的 lca 的末尾零数 $d$，在 $a_u$ 和 $a_v$ 中都出现的最小的 $s\\ge d$ 就是 $mx_{tp}$ 的末尾零数。\r\n\r\n每种 $mx_u$ 值都会形成一条链。找到 $u,v$ 到链 $mx_{tp}$ 上的最近祖先深度较小的一个即为 lca。可以找到 $a_u,a_v$ 中小于 $s$ 的最大的 $du,dv$，这条链的链顶的父亲在链 $mx_{tp}$ 上。\r\n\r\n预处理 $O(n)$，查询 $O(1)$，空间 $O(n)$。理论上完全偏序所有 lca 算法。\r\n\r\n```cpp\r\nint idx,dfn[maxn],rnk[maxn],l[maxn],fa[maxn],dep[maxn];\r\nvoid dfs(int u){\r\n\tdep[u]=dep[fa[u]]+1;\r\n\trnk[dfn[u]=++idx]=u;l[u]=__builtin_ctz(idx);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa[u])continue;\r\n\t\tfa[v]=u;dfs(v);\r\n\t\tl[u]=max(l[u],l[v]);\r\n\t}\r\n}\r\nint tp[maxn];unsigned int a[maxn];\r\nvoid dfs1(int u,int lst){\r\n\ta[u]=a[fa[u]]|(1<<l[u]);tp[u]=lst;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa[u])continue;\r\n\t\tif(l[u]==l[v])dfs1(v,lst);\r\n\t\telse dfs1(v,v);\r\n\t}\r\n}\r\nint lca(int u,int v){\r\n\tif(u==v)return u;\r\n\tint d=31^__builtin_clz(dfn[u]^dfn[v]);\r\n\tint s=__builtin_ctz(((a[u]&a[v])>>d)<<d);\r\n\tint du=31^__builtin_clz(a[u]<<(32-s)>>(32-s)),uu=(l[u]!=s?fa[tp[rnk[((dfn[u]>>du)|1)<<du]]]:u);\r\n\tint dv=31^__builtin_clz(a[v]<<(32-s)>>(32-s)),vv=(l[v]!=s?fa[tp[rnk[((dfn[v]>>dv)|1)<<dv]]]:v);\r\n\tif(dep[uu]<dep[vv])return uu;\r\n\treturn vv;\r\n}\r\n```\r\n\r\n### dfn 序 ST 表\r\n\r\n$u$ 的 dfn 序到 $v$ 的 dfn 序之间必然不存在存在 $lca(u,v)$ 和 $lca(u,v)$ 的祖先，必然存在 $lca(u,v)$ 的儿子。$u$ 的 dfn 序到 $v$ 的 dfn 序之间深度最小的点的父亲为 $lca(u,v)$。\r\n\r\n预处理 $O(n\\log n)$，查询 $O(1)$，空间 $O(n\\log n)$。\r\n\r\n```cpp\r\nint dfn[maxn],idx;\r\nint st[20][maxn];\r\nvoid dfs(int u,int fa){\r\n\tst[0][dfn[u]=++idx]=fa;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v!=fa)dfs(v,u);\r\n\t}\r\n}\r\nint lca(int u,int v){\r\n\tif(u==v)return u;\r\n\tu=dfn[u],v=dfn[v];\r\n\tif(u>v)swap(u,v);u++;\r\n\tint k=log2(v-u+1);\r\n\tif(dfn[st[k][u]]<dfn[st[k][v-(1<<k)+1]])return st[k][u];\r\n\treturn st[k][v-(1<<k)+1];\r\n}\r\nvoid init(){\r\n\tfor(int j=1;j<20;j++){\r\n\t\tfor(int i=1;i+(1<<j)-1<=n;i++){\r\n\t\t\tif(dfn[st[j-1][i]]<dfn[st[j-1][i+(1<<j-1)]])st[j][i]=st[j-1][i];\r\n\t\t\telse st[j][i]=st[j-1][i+(1<<j-1)];\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### 倍增\r\n\r\n预处理 $O(n\\log n)$，查询 $O(\\log n)$，空间 $O(n\\log n)$，常数大。\r\n\r\n```cpp\r\nint dep[maxn],f[maxn][21];\r\nvoid dfs(int u,int fa){\r\n\tdep[u]=dep[fa]+1;f[u][0]=fa;\r\n\tfor(int i=1;i<=20;i++)f[u][i]=f[f[u][i-1]][i-1];\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);\r\n\t}\r\n}\r\nint lca(int x,int y){\r\n\tif(dep[x]>dep[y])swap(x,y);\r\n\tfor(int i=20;i>=0;i--)if(dep[f[y][i]]>=dep[x])y=f[y][i];\r\n\tif(x==y)return x;\r\n\tfor(int i=20;i>=0;i--)if(f[y][i]!=f[x][i])x=f[x][i],y=f[y][i];\r\n\treturn f[x][0];\r\n}\r\n```\r\n\r\n### 树剖\r\n\r\n预处理 $O(n)$，查询 $O(\\log n)$，极难卡满，空间 $O(n)$。\r\n\r\n```cpp\r\nint dep[maxn],fa[maxn],siz[maxn],son[maxn];\r\nvoid dfs(int u){\r\n\tdep[u]=dep[fa[u]]+1;siz[u]=1;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v!=fa[u]){\r\n\t\t\tfa[v]=u;\r\n\t\t\tdfs(v);\r\n\t\t\tsiz[u]+=siz[v];\r\n\t\t\tif(siz[v]>siz[son[u]])son[u]=v;\r\n\t\t}\r\n\t}\r\n}\r\nint dfn[maxn],idx,rnk[maxn],tp[maxn];\r\nvoid dfs2(int u,int lst){\r\n\trnk[dfn[u]=++idx;]=u;tp[u]=lst;\r\n\tif(!son[u])return ;\r\n\tdfs2(son[u],lst);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v!=fa[u]&&v!=son[u])dfs2(v,v);\r\n\t}\r\n}\r\nint lca(int u,int v){\r\n\twhile(tp[u]!=tp[v]){\r\n\t\tif(dep[tp[u]]<dep[tp[v]])swap(u,v);\r\n\t\tu=fa[tp[u]];\r\n\t}\r\n\tif(dep[u]>dep[v])swap(u,v);\r\n\treturn u;\r\n}\r\n```",
      "data": {
        "title": "lca 科技",
        "date": "2024-03-01 17:13:00",
        "tags": [
          "笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "lca-ke-ji"
    },
    {
      "content": "PKUWC2024，NOIWC2024\r\n\r\n240125-240204\r\n\r\n### 0125\r\n\r\n晚上到酒店，太豪华了，感觉分到普通双床的好亏。\r\n\r\n### 0126 PKUWC-Day1\r\n\r\n早上发生了什么好像都忘了。居然是 linux，弄半天不会一点。试机那道题之前做过，但搞了半天。最后只会用 codeblock 写，还好大师教了一下。\r\n\r\n下午进场打 Day1，居然不用安检？电脑不重置？进去就可以敲板子？\r\n\r\nT1 先写 $O(n^3)$ 的 dp，玩了一会发现括号串相关，1h 搞完。T2 就很神秘， $11$ 分走人。T3 题目好长，读半天慢慢写暴力，弄着弄着搞出来 $40$ 分。至少最后显示 $151$，祈祷不要挂。\r\n\r\n回去后想半天 T3 复杂度有点假，写得不太仔细。$[131,151]$ 感觉还行。\r\n\r\n### 0127 PKUWC-Day2\r\n\r\n睡到很晚，醒来赖床，压线吃到早餐。还是习惯在学校压线作息。\r\n\r\n下午进场，等的时候默多项式，也不知道对不对就开始了，最后一点用也没有。\r\n\r\nT1 写了 $O(n^4)$ 的 dp，想到一些贪心策略，先跳过。T2 一点不懂，写 $28$ 暴力。回去把 T1 随便糊过去了，不知道对不对。T3 数据结构，感觉部分分还行,一个 sub 一个数据结构，但非常不熟练。最后好像假了一个 sub，但表面上的分还挺好看的。\r\n\r\n两天大概 $300$ 上下，和 yinhee 差不多。\r\n\r\n真得查询 pretest 强度。\r\n\r\n晚上 ABC，电脑键位难受，被锤爆了。\r\n\r\n### 0128-0129\r\n\r\n在酒店集训。学长讲课。转场育才宿舍。没有插头，排插套排插套电脑套手机，有点难绷。\r\n\r\n### 0201 NOIWC-Day1\r\n\r\n进场有 $5$ 块牌子。\r\n\r\nT1 看到 $998244353$，看了一会发现只是普通 dp，半小时搞完了，感觉很赢，赶紧用 GDKOI-Day2 的悲惨经历提醒自己。T2 看了半天不会，T3 看了半天不会，写了两个指数级暴力。觉得 T2 更有机会，于是玩了 $2h$。写了一个线段树发现合并假了，推掉重来。然后来回瞪直到最后 $0.5h$ 大概会合并。然后找不回之前的线段树了，大失败，狂写到最后一分钟，搞错相邻相等和一些细节。寄。\r\n\r\n$100+32+10=142$，难铜。\r\n\r\nhla Ag 了，以后光荣的被金钩爷机惨。\r\n\r\n### upd:0223\r\n\r\nPKUWC 出成绩了。当时听说初三有个 $308$ 二等，老师说我们学校除了初一的 lbw 全寄了。结果查分发现我 $311$，但老师没有收到我的信息，老师以为我打太差被毙掉了。最后问了那边的老师，压线一等。感觉是 IOI 赛制。",
      "data": {
        "title": "WC2024 游记",
        "date": "2024-02-06 22:03:19",
        "tags": [
          "游记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wc2024-you-ji"
    },
    {
      "content": "## 1.08\r\n\r\n### [CF235C](https://www.luogu.com.cn/problem/CF235C)\r\n\r\n求每个询问串的所有循环同构在主串中出现的次数总和。\r\n\r\n向后遍历可做，现在需要删掉开头。删除开头 $l$ 减 $1$，如果 $l=len_{lnk_p}$，那 $p$ 就不能再在这个节点，$p=lnk_p$。\r\n\r\n## 1.09\r\n\r\n### [P4094](https://www.luogu.com.cn/problem/P4094)\r\n\r\n子串 $s[a...b]$ 的所有子串和 $s[c...d]$ 的最长公共前缀的长度的最大值。\r\n\r\n二分答案 $mid$，询问 $s[c...c+mid-1]$ 是否在 $s[a...b]$ 中出现。设节点 $p$ 表示 $s[c,c+mid-1]$，问 $p$ 的 endpos 是否在 $[a+mid-1,b]$ 中有元素。\r\n\r\n记录 $p$ 表示 $s[1...i]$，倍增 parent tree 跳到 $len_p\\leq mid$。动态开点线段树合并 endpos 集合。\r\n\r\n## 1.10\r\n\r\n\r\n### [CF1237H](https://www.luogu.com.cn/problem/CF1237H)\r\n\r\n因为是对偶数位操作，将每两位和为一位。令 $00$ 为 $0$， $01$ 为 $1$， $10$ 为 $2$， $11$ 为 $3$。如果有解，则 $suma0=sumb0,suma3=sumb3,suma1+suma2=sumb1+sumb2$。\r\n\r\n考虑从一个大问题转换为小问题。要找到一种方法使得在不改变其他结构的同时移动 $a_i$。操作 $2\\times i-2$ 和 $2\\times i$ 可以实现两步将 $a_i$ 换到 $a_1$，$a_{1...{i-1}}$ 不改变结构的移到 $a_{2...i}$。\r\n\r\n所以从后向前，设当前维护到 $a_i$，此时 $a_{1...{i-1}}$ 分别等于 $b_{{n-i+2}...n}$。找到 $a_j=b_{n-i+1}$ 且 $i\\leq j$，执行上面操作即可。共 $N$ 次操作。\r\n\r\n现在问题是，$suma1\\neq sumb1$ ，我们要反转一次使 $suma1=sumb1$。\r\n\r\n我们可以找到 $a$ 中某个前缀，使得 $suma1-suma1_i+suma2_i=sumb1$，翻转这个前缀。否则一定有 $b$ 的某个前缀，使得 $sumb1-sumb1_i+sumb2_i=suma1$。这时翻转 $b$ 的这个前缀得到 $b'$，把 $a$ 做成 $b'$ 再翻转这个前缀。\r\n\r\n### [CF1329D](https://www.luogu.com.cn/problem/CF1329D)\r\n\r\n转换题意。对于 $s_i=s_{i+1}$ 的 $i$，加入 $a$，$a$ 长为 $m$。\r\n\r\n发现可行的 $s$ 上操作对应 $a$ 上：\r\n\r\n- $a$ 上删 $a_i,a_{i+1}$，其中 $a_i\\neq a_{i+1}$，$s$ 上删 $s[a_i+1,a_{i+1}]$，形如 b...[bca]...a。\r\n\r\n- $a$ 上删 $a_i$，其中 $a_i\\neq a_{i+1}$，$s$ 上删 $a[1,a_i]$，形如 [bca]...a。\r\n\r\n显然优先操作一，答案与 $a$ 中出现次数最大的 $p$ 有关，设为 $t_p$。\r\n\r\n- $t_p\\times2>m$。所有非 $p$ 都与 $p$ 操作一，用栈模拟，知道无法操作为止。\r\n\r\n- 其他情况。能配就配，直到成为上面的情况。用栈模拟，动态维护 $t$ 和 $p$。\r\n\r\n从左到右操作，可以不用线段树，记录已删除量 $del$。处理细节。\r\n\r\n结束后栈不空，用操作二一个一个做。可能忽略 $s[a_m+1,n]$，再用一次操作全部做完。\r\n\r\n### [CF1396E](https://www.luogu.com.cn/problem/CF1396E)\r\n\r\n先求出可行的最大最小答案。\r\n\r\n一条边将树分为 $sizA$ 和 $sizB$，能贡献最大为 $min(sizA,sizB)$，最小为 $sizA\\bmod 2$。最大时，$A,B$间两两连边，最小时，$A,B$ 内部互相连，多出 $sizA \\bmod 2$。\r\n\r\n拆开 $min(sizA,sizB)$，可以取重心为根，最大贡献为向下的 $siz$。最大时所有路径跨过根。因为重心子树大小最大小于 $\\frac{n}{2}$，构造取 dfn 序，$dfn_i$ 与 $dfn_{i+\\frac{n}{2}}$ 连边即可。\r\n\r\n最大时点的贡献是到根的距离。取点 $u,v$ ，lca 为 $tp$。本来 $u,v$ 各自的贡献是 $dep_u+dep_v$，连 $u,v$ 后，贡献为 $dep_u+dep_v-2\\times dep_{tp}$，变化量模 $2$ 为 $0$。\r\n\r\n从 $mxans$ 变化为 $m$。每次取出最大的 $dep_{tp}$ 的 $u,v$ 改为互相连，然后删掉。要保持重心结构，所以从最大 $siz$ 中选。最后当 $dep_{tp}>mxans-m$，因为 $dep_{tp}$ 从最大往小，沿树向上一定找得到符合条件的。最后对没删掉的节点跑最大的构造。\r\n\r\n## 1.11\r\n\r\n### [P6240](https://www.luogu.com.cn/problem/P6240)\r\n\r\n$q$ 次查询区间 01 背包，值域 $t$。$n\\leq 4\\times 10^4,q\\leq 2\\times 10^5,t\\leq 200$。\r\n\r\n可以 $O(t)$ 合并背包 $f$ 和 $g$ 求出单个 $dp$ 值。$dp_s=max_{i=0}^{s}f_i+g_{s-i}$。\r\n\r\n猫树分治：选取所有询问都包含的某个位置，分别向左右预处理。对于询问的回答,只需要在左端点取信息,在右端点取信息,再合并即可。\r\n\r\n分治 $S(l,r,ql,qr)$ 表示处理 $[l,r]$ 的物品和 $[ql,qr]$ 的询问。取 $mid=\\frac{l+r}{2}$，向左右背包。遍历 $[ql,qr]$ 的询问，如果在左右就下放，否则合并算出答案。\r\n\r\n复杂度 $O(nt\\log n+qt)$。\r\n\r\n### [P5576](https://www.luogu.com.cn/problem/P5576)\r\n\r\n[P5546](https://www.luogu.com.cn/problem/P5546) 做区间询问。\r\n\r\n选 $s$ 作为文本串对其他所以 $t$ 建的 SAM 匹配。复杂度 $O(|s|n)$，$\\sum |s|$ 为定值，$|s|$ 越小越好。\r\n\r\n猫树分治 $S(l,r,ql,qr)$，选最小的 $s_k$ 处理跨过 $k$ 的询问。$s_k$ 过长复杂度退化，不能取中点分治。\r\n\r\n取阈值 $lim$，长度小于 $lim$ 的为短串，在短串中取中心。如果没有短串，$lim=lim\\times 2$。对于 $lim$，最多分治 $\\log n$ 次，区间大小 $\\frac{\\sum len}{lim}$，匹配串 $s$ 长 $lim$。共 $\\log {\\sum len}$ 种 $lim$，复杂度 $O(\\sum len+m)\\log n\\log len$。\r\n\r\n开一个大数组，然后用指针标记位置。\r\n\r\n### [P4001](https://www.luogu.com.cn/problem/P5576)\r\n\r\n平面图最小割与对偶图最短路等价。\r\n\r\n### [UVA10735](https://www.luogu.com.cn/problem/UVA10735)\r\n\r\n有向图欧拉回路当且仅当每个点入度等于出度。给无向边定向。先随便定向，记 $d_u=\\frac{out_u-in_u}{2}$。改变方向时 $d_u-1,d_v+1$，看作流量变化，连 $(u,v,1)$。$d_u>0$ 的连 $S$，$d_u<0$ 的连 $T$。跑网络流看是否满流。\r\n\r\n### [CF1383F](https://www.luogu.com.cn/problem/CF1383F)\r\n\r\n最大流等于最小割。$k$ 条特殊边割或不割 $2^k$ 个状态。对于一个状态，先不管特殊边边权，割掉要割的特殊边，跑最小割，在加上要割的特殊边边权，对所有状态取 min 即为答案。\r\n\r\n当特殊边边权为 $0$，一定被割；边权为 $maxw=25$，一定不割。\r\n\r\n从全不割到全割的转移。在旧状态的残余网络上改边权再跑即可，$dp_s=dp_{t}+flow$。记录 $2^k$ 个网络和当前状态的答案。\r\n\r\ndinic 常数大，残余网络上用 FF，不过跟复杂度无关。\r\n\r\n## 1.12\r\n\r\n### [CF280D](https://www.luogu.com.cn/problem/CF280D)\r\n\r\n长度为 $n$ 的数列，支持：单点修改，区间询问至多选 $k$ 个的不交子段和的最大值。\r\n\r\n连 $(s,i,1,0),(i,i+1,1,a_i),(i,t,1,0)$，$s->i->j->t$ 表示选 $[i,j)$。要求至多 $k$ 流的最大费用。\r\n\r\n参考网络流反边，相当于每次取最大子段，再反转，重复 $k$ 次。线段树维护从左、右开始最大值和位置，区间最大值和位置，以及反过来最小值。用栈记录翻过的位置，最后翻回来。\r\n\r\n### [P5996](https://www.luogu.com.cn/problem/P5996)\r\n\r\n网络流。同 [P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762) 建图方式，将物品与 $s$ 连 $(s,i,v_i)$，警察与 $t$ 连 $(j+n,t,v_j)$，警察与对应的物品连 $(i,j+n,inf)$，答案为所有物品的收益和减最小割。$n,m\\leq 10^5$，显然跑不了网络流。考虑模拟最大流。\r\n\r\n首先要描述警察 $j$ 与物品 $i$ 的关系。要满足：\r\n\r\n$$\\mid \\frac{x_i-x_j}{y_i-y_j} \\mid \\leq \\frac{w}{h}$$\r\n\r\n$$x_j\\times h-y_j\\times w\\leq x_i\\times h-y_i\\times w$$\r\n\r\n$$x_j\\times h+y_j\\times w\\geq x_i\\times h+y_i\\times w$$\r\n\r\n令 $x=x\\times h+y\\times w,y=x\\times h-y\\times w$。得到 $x_i\\leq x_j,y_i\\geq y_j$ ，能很好描述。\r\n\r\n将物品和警察放在一起从左到右，从上到下考虑，自然满足 $x_i\\leq x_j$。贪心，一个警察 $j$ 的流优先从 $y_i\\geq y_j$ 且 $y_i$ 最小处流过来，因为更大的 $y_i$ 能满足更多人限制。用 set 储存物品，警察处 lower_bound 查找。\r\n\r\n### [gym102904B](https://codeforces.com/gym/102904/problem/B)\r\n\r\n划分序列，代价为 $x$ 加区间逆序对数，求最小代价。\r\n\r\n$dp_i=\\max dp_j+calc(j+1,i)$，满足决策单调性，单层转移。问题在求区间逆序对数。考虑类似莫队，要求左右两端移动次数不能过大。分治 $sovle(l,r,ql,qr)$ 中 $l,r$ 移动 $O(n\\log n)$ 次，可以接受。cdq 分治分层做 sovle，维护树状数组。复杂度 $O(n\\log^3 n)$。\r\n\r\n## 1.13\r\n\r\n### [CF1158F](https://www.luogu.com.cn/problem/CF1158F)\r\n\r\n一个序列的 $p$ 即每次删除一个包含 $[1,c]$ 的前缀能删的次数。\r\n\r\n设 $g_{l,r}$ 表示 $[l,r]$ 中强制选 $a_r$ 并正好选出 $[1,c]$ 的子序列数。$g_{l,r}=\\prod_{i\\neq a_r}t_i-1$。设 $f_{i,j}$ 表示以 $j$ 结尾并强制选 $j$ 的答案为 $i$ 的数量。$f_{i,j}=\\sum f_{i-1,k}+g_{k+1,j}$。因为答案小于 $\\frac{n}{m}$，复杂度 $O(\\frac{n^3}{m})$。答案为 $i$ 后乱选，设 $ans_i$ 表示答案至少为 $i$ 的数量。$ans_i=f_{i,j}\\times 2^{n-j}$，差分得答案。\r\n\r\n### [CF666E](https://www.luogu.com.cn/problem/CF666E)\r\n\r\n求 $s[pl,pr]$ 在 $T[l,r]$ 中哪个串出现次数最多。\r\n\r\n对 $t$ 建广义 SAM，$s$ 在上面跑匹配。如果 $s[pl,pr]$ 在 $t$ 中出现，倍增找到 $s[pl,pr]$ 对应的节点。每个节点动态开点线段树，下标为 $t$ 的编号，记录出现次数最大值和下标，线段树合并。\r\n\r\n## 1.14\r\n\r\n### [省选模拟1.14 T2 lis](http://www.gdfzoj.com:23380/contest/902/problem/8713)\r\n\r\n求子序列最长长度使 lis 比原序列 lis 小。\r\n\r\n连边 $(i,i',1)$，$(S,i,inf),f_i=1$，$(i',T,inf),f_i=mx$，$(i',j,inf),f_i+1=f_j,i<j,a_i<a_j$ 跑最小割。模拟最大流。分层，对于点 $u,v,f_u=f_v=i,u<v,a_u>a_v$。$u$ 去到 $i+1$ 层的区间 $[l_u,r_u]$ 满足 $l_u\\leq l_v,r_u\\leq r_v$。对于一个流，优先向 $l_u$ 去，因此不需要退流。记录 $vis_u$ 表示是否走过，$to_u$ 指向下一个 $vis_u=0$ 的点。$O(n)$ 模拟。\r\n\r\n## 1.15\r\n\r\n### [CF1498F](https://www.luogu.com.cn/problem/CF1498F)\r\n\r\n树上节点 $i$ 有 $a_i$ 个石子，每次选任意个移到 $k$ 级祖先，不能动输，问以每个点为根先手胜负。\r\n\r\n$dep_u$ 模 $k$ 相等的分别考虑 SG 值。当 $\\lfloor \\frac{dep_u}{k} \\rfloor$ 为偶数时，$u$ 没意义。因为先手移偶数位后手可以移回奇数位。设 $dp_{u,j,0/1}$ 表示 $dep_u \\bmod k=j,\\lfloor \\frac{dep_u}{k} \\rfloor \\bmod 2=0/1$ 时的 SG 值。换根 dp。\r\n\r\n### [CF1852C](https://www.luogu.com.cn/problem/CF1852C)\r\n\r\n初始全为 $0$，模 $k$ 意义下最少多少次区间加 $1$ 得到 $a$ 数组。\r\n\r\n如果不模 $k$，差分得 $b$，$ans=\\sum [b_i>0]b_i$。预先对 $a$ 区间加 $k$ 代替取模，$b_u+k,b_{v+1}-k$，最小化 $ans$。反悔贪心，取出最小的 $b_j<0$ 和当前 $b_i>0$ 做区间加后 $b_j>0,b_i<0$，把 $b_i$ 入队。 \r\n\r\n### [CF1539F](https://www.luogu.com.cn/problem/CF1539F)\r\n\r\n中位数相关，考虑 $a_j>a_i$ 的 $j$ 设为 $1$，$a_j<a_i$ 的 $j$ 设为 $-1$，做前缀和。$a_j=a_i$ 时可以任意排列。\r\n\r\n- $a_i>a_{mid}$，$a_j=a_i$ 的 $j$ 放在 $i$ 前，设为 $-1$。$ans=\\max \\sum [a_j\\leq a_i] -\\lceil \\frac{l+r}{2} \\rceil=\\frac{-\\min (sum_r-sum_{l-1})-1}{2}$。\r\n\r\n- 否则，$a_j=a_i$ 的 $j$ 放在 $i$ 后，设为 $1$。$ans=\\max \\sum [a_j\\geq a_i] -\\lceil \\frac{l+r}{2} \\rceil=\\frac{\\max (sum_r-sum_{l-1})}{2}$。\r\n\r\n要动态维护 $\\max (sum_r-sum_{l-1})$。可以按 $a_i$ 从小往大加入。初始时 $sum_i=i$，当 $a_i$ 改为 $-1$ 时，线段树维护区间 $[i,n]$ 减 $2$。$\\max (sum_r-sum_{l-1})=\\max_{j=i}^{n}sum_j-\\min_{j=1}^{i}sum_{j-1}$。\r\n\r\n### [CF1797F](https://www.luogu.com.cn/problem/CF1797F])\r\n\r\n求恰好满足一个条件中的 $(u,v)$ 个数：$u$ 是 $u->v$ 编号最小的点；$v$ 是 $u->v$ 编号最大的点。\r\n\r\n容斥，$ans=\\mid A\\mid+\\mid B\\mid-2\\mid C\\mid$。建大根、小根重构树，$\\mid A\\mid=\\sum sizmx_u$。$C$ 为在两棵树都有祖先关系的点对。枚举一边，树状数组维护从根到当前节点在另一颗树上的 dfn 序，区间查询，单点修改。\r\n\r\n### [P4248](https://www.luogu.com.cn/problem/P4248)\r\n\r\n$t_i=s[i,n]$。求 $\\sum_{i<j}len_{t_i}+len_{t_j}-2\\times lcp(t_i,t_j)$。\r\n\r\n$ans=\\frac{n\\times (n-1)\\times (n+1)}{2}-2\\times \\sum_{i<j} lcp(t_i,t_j)$。lcp 看作公共前缀数量。记 $siz_u$ 表示节点 endpos 集合大小，对每个节点计算贡献，有 $num_u=len_u-len_{fa_u}$ 个串，每个串出现在 $siz_u$ 个后缀的前缀中，贡献 $num_u\\times \\frac{siz_u\\times (siz_u-1)}{2}$。\r\n\r\n\r\n### [P2178](https://www.luogu.com.cn/problem/P2178)\r\n\r\n翻转建 SAM，lcp 转换为最长公共后缀，即 parent tree 上的 lca 的 len。记录子树内最大、次大、最小、次小。\r\n\r\n### [P9970](https://www.luogu.com.cn/problem/P9970)\r\n\r\n极小的 mex 区间有 $O(n)$ 个。枚举 $i$ 维护所有极小 $[l,r],mex_{l,r}=i$，不断向左右一边拓展至最近的 $a_i$，得到 $mex_{l',r'}=calc(l',r')>i$ 的一个区间，所有这些区间包含所有极小区间，每次转移前删去非极小区间。计算区间 mex：可持久化线段树，$[1,n]$ 为版本，维护每个值最后出现的位置，二分。已知有极小区间 $[l,r],mex_{l,r}=x$，找到左右的 $L,R,a_{L-1}=a_{R+1}=x$，则 $mex_{l',r'}=x,L\\leq l'\\leq l,r\\leq r'\\leq R$。所有 $r-l+1,R-L+1$ 中的 $len$ 存在 $mex=x$，记录加入和删除位置，用 set 扫一遍。\r\n\r\n## 1.16\r\n\r\n### [arc162f](https://www.luogu.com.cn/problem/AT_arc162_f)\r\n\r\n观察发现，第 $i$ 行 $a_{i,j_1}=\\ldots =a_{i,j_{num}}=1,(j_1<\\ldots <j_{num})$，则第 $ii,(ii>i)$ 行能取 $1$ 的位置是 $[1,j_1-1]$ 和 $j$ 的一个前缀。\r\n\r\n但可以空一些行和列，考虑将所有有 $1$ 的行和列压起来。设 $dp_{i,j,k}$ 表示前 $i$ 行，有 $j$ 个列有过 $1$，上一行有 $k$ 个 $1$，强制连续选。首先可以取一个前缀，$dp'_{i,j,k}=\\sum_{l=k}^j dp_{i-1,j,l}$，后缀和维护。其次可以向前任意取，但强制连续选，枚举选 $l$ 个，$dp_{i,j,k}=\\sum_{l=0}^k dp'_{i,j-l,k-l}$，维护一个斜线的前缀和。$ans=\\sum \\binom{n}{i}\\times \\binom{m}{j}\\times dp_{i,j,k}$。再加上全取 $0$ 的情况。\r\n\r\n注意取模优化和枚举时 $\\frac{1}{2}$ 的常数！\r\n\r\n## 1.18\r\n\r\n### [CF814E](https://www.luogu.com.cn/problem/CF814E)\r\n\r\n分层，只有层间和向下层的边。设当前层 $m$ 个点，$x$ 个二度，$y$ 个三度，层间连 $z$ 条。\r\n\r\n- 向下层：$(x+2y-z)!$\r\n\r\n- 层间：$\\frac{(x+2y)!}{(x+2y-2z)!\\times 2^z\\times z!}$，将二度点当两个点，再出去对的相对顺序。\r\n\r\n- 容斥掉 $p$ 个重边、$q$ 个自环，设 $s=2p+q$：$\\frac{(-1)^{p+q}\\times y!}{(y-s)!\\times p!\\times q!}\\times\\frac{(x+2y-2s)!}{(x+2y-2z)!\\times 2^{x-s}\\times (z-s)!}$ \r\n\r\n### [CF1142E](https://www.luogu.com.cn/problem/CF1142E)\r\n\r\n维护一个可行答案集合，取出两个询问，将不可行的扔掉。要保证每次询问不能问到粉边，要求每个粉连通块只有一个点在集合中。强行当成 DAG，如果不行再将联通块其他点加入。\r\n\r\n### [CF1240F](https://www.luogu.com.cn/problem/CF1240F)\r\n\r\n构造。将边拆为 $u$ 和 $v+n$，二分图，如果能使每个点极差不超过 $1$，合并后不超过 $2$。设点 $u$ 度数为 $ak+b$，拆为 $a+1$ 个点。边染色使所有出边颜色不同。同 [CF600F](https://www.luogu.com.cn/problem/CF600F)。\r\n\r\n## 1.19\r\n\r\n### [arc134e](https://www.luogu.com.cn/problem/AT_arc134_e)\r\n\r\n- $\\emptyset$ 必胜。$\\{1\\},\\{2\\}$ 必败。\r\n\r\n- 否则 $\\exists x\\bmod 2=1$ 模 $2$ 必胜。\r\n\r\n- 否则 $\\exists x\\bmod 4=2$ 模 $4$ 必胜。\r\n\r\n- 否则模 $3$ 后如果 $S=\\{1\\}$ 或 $\\{2\\}$ 必胜。\r\n\r\n- 否则 $S=\\{4,8\\}$ 必败，否则模 $12$ 得 $\\{4,8\\}$ 必胜。\r\n\r\n如果 $\\forall 12\\mid x$，难以分类讨论。有 $\\lfloor \\frac{200}{12} \\rfloor=16$，状压计算出现次数和胜负。\r\n\r\n### [CF487E](https://www.luogu.com.cn/problem/CF487E)\r\n\r\n圆方树。求出点双，对每个点双建方点，原图点是圆点，方点与对应的圆点连边。\r\n\r\n当进入一个点双，一定能到点双中权值最小的点。方点权值为最小的圆点权值，multiset 维护删除，树剖维护路径最小值。\r\n\r\n## 1.20\r\n\r\n### [agc010e](https://www.luogu.com.cn/problem/AT_agc010_e)\r\n\r\n对于不互质的数，后手操作后先后顺序不变。对所有不互质的连边。要求定向后最大拓扑序最小。按权值从小到大 dfs 儿子连边，拓扑时用优先队列。\r\n\r\n## 1.21\r\n\r\n### [P5292](https://www.luogu.com.cn/problem/P5292)\r\n\r\n从长为 $1$ 和 $2$ 的回文串开始枚举左右出边 bfs，复杂度 $O(m^2)$。减少无用的边。将 $00,11$ 和 $01,10$ 分开，形成若干连通块。如果连通块为二分图，两点间奇偶性相同，可以反复横跳，取生成树即可。不是二分图，连自环即可。边数将为 $O(n)$。\r\n\r\n## 1.22\r\n\r\n### [CF1609F](https://www.luogu.com.cn/problem/CF1609F)\r\n\r\n枚举每个颜色 $c$，枚举右端，线段树区间维护左端 min 和 max 是否符合条件。\r\n\r\n### [CF1280D](https://www.luogu.com.cn/problem/CF1280D)\r\n\r\n树形 dp。设 $dp_{u,i}$ 表示 $u$ 子树内分 $j$ 段的最大数量。难以记录 $u$ 所在连通块状态。设 $f_{u,i}$ 表示最大数量下 $w_i-b_i$ 的值。背包 $O(n^2)$。\r\n\r\n## 1.23\r\n\r\n### [CF1218A](https://www.luogu.com.cn/problem/CF1218A)\r\n\r\n是基环树。先考虑树。如果从一个点开始，定为根，$ans=\\sum siz_u$。换根 dp 即可。\r\n\r\n把环找出来，考虑在环上点 $u$ 的子树中开始染色的答案。染色的方式是大致是从子树的叶子开始向上。对 $u$ 的每个非环上儿子做树的 dp。记 $g_u$ 表示从环上进入子树向下染色的答案，$dp_u$ 表示换根的、从子树内任意节点开始染色的方案。从环上 $u$ 的非环上儿子 $v$ 的子树开始的答案是 $dp_v+\\sum_{v'\\neq v} g_{v'}$，$ans_u=\\sum g_v+\\max (dp_v-g_v)$。染完环上 $u$ 的子树后，绕环染环上点。再从除 $u$ 外的环上点向下染其他环上点的子树，答案为 $\\sum g_v$。\r\n\r\n发现前后贡献固定，变动的是染环的顺序。染环是染一个区间，每次向左右拓展。每次染一个点，答案加上当前连通块大小，当前连通块大小减 $siz_u$。贪心向小的染是错的，因为有后效性。记录 $siz$ 的前缀和，区间 dp，$O(1)$ 向左右转移，滚动即可。\r\n\r\n## 1.24\r\n\r\n### [CF288E](https://www.luogu.com.cn/problem/CF288E)\r\n\r\n$$ans=\\sum(X\\times 10^i+47\\dots7)(X\\times10^i+74\\dots4)$$\r\n\r\n维护 $X$ 的数量、和、平方和。\r\n\r\n### [省选模拟1.24 T2 lottop](http://www.gdfzoj.com:23380/contest/910/problem/8737)\r\n\r\n对于平面图，$V-E+F=2$，顶点数、边数、平面数。每个面至少围 $3$ 条边，每条边对应两个面，$2E\\geq3F$，$E\\leq3V-6$。平面图存在点度数小于等于 $5$，对偶图也是平面图存在点度数小于等于 $5$，平面图存在环小于等于 $5$。判三、四元环。\r\n\r\n根号分治，按度数、大小定向为 DAG。复杂度 $O(m\\sqrt m)$。\r\n\r\n### [P7372](https://www.luogu.com.cn/problem/P7372)\r\n\r\n连成若干个环，$k=lcm a_i$。要 $\\sum a_i\\leq n\\times m$，取 $a_i=p_i^{c_i}$。构造交换相邻的方案。\r\n\r\n## 1.28\r\n\r\n### [P7482](https://www.luogu.com.cn/problem/P7482)\r\n\r\ncdq 分治拆成 $[l,mid]$ 到 $(mid,r]$ 的贡献。\r\n\r\n对于一个区间计算答案可以用 dp 完成。以 $mid$ 为交界合并左右的 dp 值。设 $f_{i,0/1}$ 表示区间 $[i,mid]$ 或区间 $(mid,i]$，是否选 $mid$ 或 $mid+1$ 的答案。记跨过 $mid$ 的贡献为 $w$。\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} ans(i,j)$$\r\n\r\n记 $g_i=f_{i,1}-f_{i,0}$。\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} \\max(g_i+f_{i,0}+f_{j,0},g_j+f_{i,0}+f_{j,0})$$\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} \\max(g_i,g_j)+\\sum_{i=l}^{mid}f_{i,0}\\times (r-mid)+\\sum_{j=mid+1}^r f_{j,0}\\times (mid-l+1)$$\r\n\r\n后面两个直接做，前面的对于每个 $i$ 拆开 max 计算。\r\n\r\n$$\\sum_{j=mid+1}^{r} \\max(g_i,g_j)=\\sum_{j=mid+1}^{r}[g_i\\geq g_j]\\times g_i+[g_i<g_j]\\times g_j$$\r\n\r\n\r\n对 $(mid,r]$ 的 $g_j$ 排序，二分 $g_i$ 的位置，记录 $g_j$ 的后缀和即可。递归 $[l,mid]$ 和 $(mid,r]$ 解决。",
      "data": {
        "title": "2024.1 做题记录",
        "date": "2024-02-01 22:20:51",
        "tags": [
          "做题记录"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "20241-zuo-ti-ji-lu"
    },
    {
      "content": "GDKOI2024\r\n\r\n240105-240107\r\n\r\n签到暴力挂分稳重向好，抽象骗分高质量发展。\r\n\r\n### Day0\r\n\r\n考试。寄。\r\n\r\n社会主义的曲折发展；绿水青山就是金山银山。\r\n\r\n2h 大巴，2h 酒店看电视，猫和老鼠。\r\n\r\n### Day1\r\n\r\n开题，好，只有 T1 有一个\"大\"样例。\r\n\r\nT1 图论，二分图相关，先写 $40$ 状压，想到网络流，跳过。\r\n\r\nT2 数据结构，不会，看到 $60$ 暴力，先不写，跳过。\r\n\r\nT3 完全不会，放弃思考，$10$ 分搜索。并没有找到规律。\r\n\r\n上厕所，思路打开。\r\n\r\n回来写 T1。发现不会匈牙利，也想不到什么结论。$n=500,m=n^2$，以为网络流复杂度 $O(n\\sqrt m)$，直接随机 $500$ 次边的顺序跑网络流判断。发现过不了 $n=18$ 的第一个大样例，疯狂调试随机方式，还是过不了。\r\n\r\n突然发现只有 1h，赶快去写 T2 线段树。半小时冲完。可是没有大样例，于是非常自信的回 T1，不过还是没骗过大样例。\r\n\r\n出来发现：网络流是 $O(m\\sqrt n)$ 的，寄。估分 $40+?+60+10=?$。\r\n\r\n下午，听 4h 讲座，高校教授自嗨，昏昏欲睡，难受。\r\n\r\n发成绩。T1 把随机数据骗到了，$60$ 分；T2 后三十分暴力 CE+RE+WA，寄。$60+30+10=100$，估计没几个人是这个分的。\r\n\r\n晚上猫和老鼠。两天看 $20+$ 集。\r\n\r\n### Day2\r\n\r\n进考场前和 K 猜测会不会没有大样例。\r\n\r\n结果真的没有，解压后一脸懵逼。\r\n\r\nT1 签到题。不写部分分直接冲正解，$1.5h$ “写完”。没大样例，不想写暴力对拍，跳过。\r\n\r\nT2 数学。打表发现 $gcd(m^a-1,m^b-1)+1=m^{gcd(a,b)}$，感觉很对。转换为：从 $n$ 个 $0,1,...,m-1$ 中选任意个使得和为 $m$ 的倍数。感觉非常有戏，于是冲了 $1h$ 发现想错了。又冲了 $1h$，发现生成函数 $((x+1)(x^2+1)...(x^{m-1}+1))^n$。想到倍增 NTT，但里面一坨不会，直接退化为 $O(m^2)$，不管了，发现自己居然能默出 NTT。$65$ 分。\r\n\r\nT3 想都没想，输出 $-1$。\r\n\r\n最后 $5min$ 发现 T1 边界有点问题，但改了过不了样例。寄。\r\n\r\n估分 $?+65+? \\approx 0+65+5$。\r\n\r\n下午讲题，发现 T1 想的和题解完全一样，估计是写成屎了。\r\n\r\n颁奖，无聊。杜子德主席亲临现场，我们备受鼓舞。\r\n\r\n二中 IOI 金牌教练奖，奖金 $200000$，杜子德从第一个人手里接过奖状，对拿着奖金的第二个人挥手，让那个人下台。颁奖发奖状就是了，发钱干嘛。\r\n\r\n~~难铜了。~~\r\n\r\n$60+30+10+0+65+0=165$，铜牌并列第一。\r\n\r\n~~守银失败。~~\r\n\r\n正常能拿的分：$40+60+10+100+35+20=265$。\r\n\r\n我的分是真的抽象。不过骗到 D1T1 和 D2T2 还是很自豪的。",
      "data": {
        "title": "GDKOI2024 游记",
        "date": "2024-01-07 22:03:52",
        "tags": [
          "游记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gdkoi2024-you-ji"
    },
    {
      "content": "## 1.基本\r\n\r\nSAM 能表示某个字符串的所有子串，且正好是所有子串。\r\n\r\n```cpp\r\nint len[maxn],lnk[maxn];\r\nint a[maxn][26];\r\nint p=1,cur=1;\r\nint ed[maxn];\r\nvoid insert(int c){\r\n\tint nd=++cur;\r\n\tlen[nd]=len[p]+1;\r\n\twhile(p&&!a[p][c])a[p][c]=nd,p=lnk[p];\r\n\tif(!p){lnk[p=nd]=1;return ;}\r\n\tint q=a[p][c];\r\n\tif(len[p]+1==len[q])lnk[nd]=q;\r\n\telse{\r\n\t\tint cl=++cur;\r\n\t\tlen[cl]=len[p]+1;lnk[cl]=lnk[q];\r\n\t\tmemcpy(a[cl],a[q],sizeof(a[q]));\r\n\t\tlnk[nd]=lnk[q]=cl;\r\n\t\twhile(p&&a[p][c]==q)a[p][c]=cl,p=lnk[p];\r\n\t}\r\n\tp=nd;\r\n}\r\n```\r\n\r\n## 2.应用\r\n\r\n### [P3804](https://www.luogu.com.cn/problem/P3804)\r\n\r\n求子串出现次数乘上子串长度的最大值。\r\n\r\n每个节点对应多个子串，最长的长为 $len_u$。节点的 endpos 大小为出现次数。\r\n\r\n先把每个前缀所属的点的 siz 设为 $1$，这些点是前缀对应 edp 在 parent tree 上出现的最深的点，因为无法在这些前缀前面加东西。parent tree 上求和即可。\r\n\r\n```cpp\r\n\tint siz[maxn];\r\n\tvoid insert(int c){\r\n\t\tint nd=++cur;\r\n\t\ta[nd].len=a[p].len+1;\r\n\t\tsiz[nd]=1;\r\n\t\t...\r\n\t}\r\n\tvoid dfs(int u){\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tdfs(v);\r\n\t\t\tsiz[u]+=siz[v];\r\n\t\t}\r\n\t}\r\n\tint calc(){\r\n\t\tint res=0;\r\n\t\tfor(int i=2;i<=cur;i++)add(a[i].lnk,i);\r\n\t\tdfs(1);\r\n\t\tfor(int i=2;i<=cur;i++)if(siz[i]>1)res=max(res,siz[i]*a[i].len);\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n### [P2408](https://www.luogu.com.cn/problem/P2408)\r\n\r\n不同子串个数。\r\n\r\n#### 1.dp\r\n\r\n在后缀自动机上从根节点开始的每一条路径都是一个子串，求出路径数量，便可以求出子串数。建 SAM dp。\r\n\r\n```cpp\r\nvoid dfs(int u){\r\n\tif(dp[u])return ;\r\n\tdp[u]=1;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;dfs(v);\r\n\t\tdp[u]+=dp[v];\r\n\t}\r\n}\r\n```\r\n\r\n#### 2.定义\r\n\r\nSAM 一个节点对应的长度分别算贡献。parent tree 上，$minlen_u=maxlen_{lnk_u}+1$。对于每个 $i$，$ans=ans+len_u-len_{lnk_u}$。\r\n\r\n```cpp\r\n\tfor(int i=1;i<=n;i++)insert(c[i]-'a'),ans+=len[p]-len[lnk[p]];\r\n```\r\n\r\n对于每个 $i$ 输出答案：[P4070](https://www.luogu.com.cn/problem/P4070)\r\n\r\n### [P3975](https://www.luogu.com.cn/problem/P3975)\r\n\r\n字典序第 $k$ 小子串。\r\n\r\n$siz_i$ 表示 $i$ 所对应字符串集合的出现次数。$t=0$ 时 $siz_i=1$；$t=1$ 时 dfs 沿 parent tree 累加。dp 方案数。沿 SAM 走，走的边为答案。\r\n\r\n### [SP1811](https://www.luogu.com.cn/problem/SP1811)\r\n\r\n两个字符串的最长公共子串长度。\r\n\r\n对 $s$ 建 SAM，在上面匹配 $t$。当前节点为 $p$，已匹配长度为 $l$。对于当前字符 $c$。\r\n\r\n- 如果 $p$ 有出边 $c$，$p=a_{p,c}$，$l$ 加 $1$。\r\n\r\n- 否则向上跳 $p=lnk_p$，$l$ 减 $1$，当 $l=0$ 结束。\r\n\r\n```cpp\r\nvoid go(int &p,int c,int &l){\r\n\twhile(1){\r\n\t\tif(a[p][c]){\r\n\t\t\tp=a[p][c],l++;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif(!l)break;\r\n\t\tl--;\r\n\t\tif(l==len[lnk[p]])p=lnk[p];\r\n\t}\r\n}\r\n```\r\n\r\n### [P5546](https://www.luogu.com.cn/problem/P5546)\r\n\r\n$n$ 个字符串的最长公共子串长度。\r\n\r\n以 $s_1$ 为匹配串，$s_i$ 建 SAM。令 $sl_j$ 表示 $s_1[1...j]$ 能匹配的最长长度，每个 $s_i$ 取 min。最后对所有 $j$ 取 max。\r\n\r\n### [CF235C](https://www.luogu.com.cn/problem/CF235C)\r\n\r\n求每个询问串的所有循环同构在主串中出现的次数总和。\r\n\r\n向后遍历同上题，现在需要删掉开头。\r\n\r\n删除开头 $l$ 减 $1$，如果 $l=len_{lnk_p}$，那 $p$ 就不能再在这个节点，$p=lnk_p$。\r\n\r\n```cpp\r\nvoid del(int &pos,int &l,int n){\r\n\tif(l>n&&--l==len[lnk[pos]])pos=lnk[pos];\r\n}\r\n```\r\n\r\n### [P6640](https://www.luogu.com.cn/problem/P6640)\r\n\r\n询问 $s[l...r]$ 和 $t$ 的最长公共子串长度。\r\n\r\n对 $t$ 建 SAM，$s$ 跑匹配，$sl_i$ 为 $s[1...i]$ 的最长匹配长度。\r\n\r\n$$ans=max_{i=l}^r min(sl_i,i-l+1)$$\r\n\r\n拆开 min。找出 $sl_i\\leq i-l+1$，$i-sl_i+1$ 单调。二分 $mid$ 使 $[l,mid-1]$ 中取 $i-l+1$，$ans=mid-l$；$[mid,r]$ 中取 $sl_i$ ，维护静态区间最大。\r\n\r\n### [P4094](https://www.luogu.com.cn/problem/P4094)\r\n\r\n子串 $s[a...b]$ 的所有子串和 $s[c...d]$ 的最长公共前缀的长度的最大值。\r\n\r\n二分答案 $mid$，询问 $s[c...c+mid-1]$ 是否在 $s[a...b]$ 中出现。设节点 $p$ 表示 $s[c,c+mid-1]$，问 $p$ 的 endpos 是否在 $[a+mid-1,b]$ 中有元素。\r\n\r\n记录 $p$ 表示 $s[1...i]$，倍增 parent tree 跳到 $len_p\\leq mid$。动态开点线段树合并 endpos 集合。\r\n\r\n注意，是在 DAG 上线段树合并，不能破坏原有结构，新建点。\r\n\r\n```cpp\r\nint n,m;\r\nchar c[maxn];\r\nnamespace sgt{\r\n#define mid (l+r>>1)\r\n#define ls lc[nd]\r\n#define rs rc[nd]\r\n    bool tree[maxn<<5];\r\n    int lc[maxn<<5],rc[maxn<<5];\r\n    int rt[maxn],idx;\r\n    void updata(int &nd,int l,int r,int p,int w){\r\n        if(!nd)nd=++idx;\r\n        if(l==r){tree[nd]=w;return ;}\r\n        if(p<=mid)updata(ls,l,mid,p,w);\r\n        else updata(rs,mid+1,r,p,w);\r\n        tree[nd]=tree[ls]|tree[rs];\r\n    }\r\n    int merge(int u,int v,int l,int r){\r\n        if(!u||!v)return u|v;\r\n        int nd=++idx;\r\n        if(l==r){tree[nd]=tree[u]|tree[v];return nd;}\r\n        ls=merge(lc[u],lc[v],l,mid);\r\n        rs=merge(rc[u],rc[v],mid+1,r);\r\n        tree[nd]=tree[ls]|tree[rs];\r\n        return nd;\r\n    }\r\n    bool query(int nd,int l,int r,int ql,int qr){\r\n        if(l>=ql&&r<=qr)return tree[nd];\r\n        if(qr<=mid)return query(ls,l,mid,ql,qr);\r\n        if(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n        return query(ls,l,mid,ql,qr)|query(rs,mid+1,r,ql,qr);\r\n    }\r\n#undef mid\r\n}\r\nstruct sam{\r\n    int head[maxn],tot;\r\n    struct edgend{\r\n        int nxt,to;\r\n    }e[maxn<<1];\r\n    void add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\n    int f[maxn][19];\r\n    void dfs(int u){\r\n        for(int i=1;i<19;i++)f[u][i]=f[f[u][i-1]][i-1];\r\n        for(int i=head[u];i;i=e[i].nxt){\r\n            int v=e[i].to;\r\n            f[v][0]=u;dfs(v);\r\n            sgt::rt[u]=sgt::merge(sgt::rt[u],sgt::rt[v],1,n);\r\n        }\r\n    }\r\n    void build(char *c,int n){\r\n        for(int i=1;i<=n;i++)insert(c[i]-'a');\r\n        for(int i=1,nd=1;i<=n;i++){\r\n            nd=a[nd][c[i]-'a'];\r\n            ed[i]=nd;\r\n        }\r\n        for(int i=2;i<=cur;i++)add(lnk[i],i);\r\n        dfs(1);\r\n    }\r\n    int find(int l,int r){\r\n        int res=ed[r];\r\n        for(int i=18;~i;i--)if(f[res][i]&&len[f[res][i]]>=r-l+1)res=f[res][i];\r\n        return res;\r\n    }\r\n}s;\r\nbool check(int a,int b,int l,int r){\r\n    int pos=s.find(l,r);\r\n    return sgt::query(sgt::rt[pos],1,n,a+r-l,b);\r\n}\r\n```\r\n\r\n\r\n\r\n### [P5576](https://www.luogu.com.cn/problem/P5576)\r\n\r\n[P5546](https://www.luogu.com.cn/problem/P5546) 做区间询问。\r\n\r\n选 $s$ 作为文本串对其他所以 $t$ 建的 SAM 匹配。复杂度 $O(|s|n)$，$\\sum |s|$ 为定值，$|s|$ 越小越好。\r\n\r\n猫树分治 $S(l,r,ql,qr)$，选最小的 $s_k$ 处理跨过 $k$ 的询问。$s_k$ 过长复杂度退化，不能取中点分治。\r\n\r\n取阈值 $lim$，长度小于 $lim$ 的为短串，在短串中取中心。如果没有短串，$lim=lim\\times 2$。对于 $lim$，最多分治 $\\log n$ 次，区间大小 $\\frac{\\sum len}{lim}$，匹配串 $s$ 长 $lim$。共 $\\log {\\sum len}$ 种 $lim$，复杂度 $O(\\sum len+m)\\log n\\log len$。\r\n\r\n开一个大数组，然后用指针标记位置。\r\n\r\n```cpp\r\nint _sl[maxn],*sl[maxn],*sum;\r\nvoid sovle(int l,int r,int ql,int qr,int lim){\r\n\tif(ql>qr)return ;\r\n\tint tot=0;\r\n\twhile(1){\r\n\t\tfor(int i=l;i<=r;i++)if(siz[i]<=lim)tmp[++tot]=i;\r\n\t\tif(tot)break;lim<<=1;\r\n\t}\r\n\tint mid=tmp[1+tot>>1],qmid=ql-1;\r\n\tsum=_sl;\r\n\tfor(int i=l;i<=r;i++){\r\n\t\tsl[i]=sum;\r\n\t\tsum+=siz[mid]+1;\r\n\t}\r\n\tfor(int j=0;j<siz[mid];j++)sl[mid][j]=j+1;\r\n\tfor(int i=mid+1;i<=r;i++){\r\n\t\tint p=rt[i],d=0;\r\n\t\tfor(int j=0;j<siz[mid];j++){\r\n\t\t\tint c=s[mid][j]-'0';\r\n\t\t\tgo(p,c,d);\r\n\t\t\tsl[i][j]=min(sl[i-1][j],d);\r\n\t\t}\r\n\t}\r\n\tfor(int i=mid-1;i>=l;i--){\r\n\t\tint p=rt[i],d=0;\r\n\t\tfor(int j=0;j<siz[mid];j++){\r\n\t\t\tint c=s[mid][j]-'0';\r\n\t\t\tgo(p,c,d);\r\n\t\t\tsl[i][j]=min(sl[i+1][j],d);\r\n\t\t}\r\n\t}\r\n\tint tr=0;\r\n\tfor(int i=ql;i<=qr;i++){\r\n\t\tint u=id[i];\r\n\t\tif(qq[u].r<mid)id[++qmid]=u;\r\n\t\telse if(qq[u].l>mid)tmp[++tr]=u;\r\n\t\telse{\r\n\t\t\tfor(int j=0;j<siz[mid];j++)ans[u]=max(ans[u],min(sl[qq[u].l][j],sl[qq[u].r][j]));\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=tr;i++)id[qmid+i]=tmp[i];\r\n\tqr=qmid+tr;\r\n\tsovle(l,mid-1,ql,qmid,lim);sovle(mid+1,r,qmid+1,qr,lim);\r\n}\r\n```\r\n\r\n### [CF666E](https://www.luogu.com.cn/problem/CF666E)\r\n\r\n求 $s[pl,pr]$ 在 $T[l,r]$ 中哪个串出现次数最多。\r\n\r\n对 $t$ 建广义 SAM，$s$ 在上面跑匹配。如果 $s[pl,pr]$ 在 $t$ 中出现，倍增找到 $s[pl,pr]$ 对应的节点。每个节点动态开点线段树，下标为 $t$ 的编号，记录出现次数最大值和下标，线段树合并。\r\n\r\n### [P4248](https://www.luogu.com.cn/problem/P4248)\r\n\r\n$t_i=s[i,n]$。求 $\\sum_{i<j}len_{t_i}+len_{t_j}-2\\times lcp(t_i,t_j)$。\r\n\r\n$ans=\\frac{n\\times (n-1)\\times (n+1)}{2}-2\\times \\sum_{i<j} lcp(t_i,t_j)$。lcp 看作公共前缀数量。记 $siz_u$ 表示节点 endpos 集合大小，对每个节点计算贡献，有 $num_u=len_u-len_{fa_u}$ 个串，每个串出现在 $siz_u$ 个后缀的前缀中，贡献 $num_u\\times \\frac{siz_u\\times (siz_u-1)}{2}$。\r\n\r\n### [P2178](https://www.luogu.com.cn/problem/P2178)\r\n\r\n翻转建 SAM，lcp 转换为最长公共后缀，即 parent tree 上的 lca 的 len。\r\n\r\n### [P7361](https://www.luogu.com.cn/problem/P7361)\r\n\r\n求 $[l,r]$ 中出现至少两次的子串的最长长度。\r\n\r\n用 set 启发式合并 edp 集合，一个长度的贡献为相邻的 edp 点。贡献为 $min(pl-l+1,len)$。离线，扫描线。",
      "data": {
        "title": "SAM 做题记录",
        "date": "2024-01-01 22:00:40",
        "tags": [
          "做题记录",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sam-zuo-ti-ji-lu"
    },
    {
      "content": "「2020-2021 集训队作业」A story of The Small P\r\n\r\n### 题意\r\n\r\n给定 $N, m, k$ ,求有多少个正整数序列 h 满足：\r\n\r\n- h 的长度 $n$ 满足 $1\\leq n\\leq N$。\r\n- $1\\leq h_i\\leq m$。\r\n- 正好存在 $k$ 个 $i$ 满足 $h_i<h_{i+1}$。\r\n\r\n答案模 $998244353$。\r\n\r\n$2\\leq N, m, k\\leq 2^{19},(N-k+1)\\times m\\leq 2^{20}$。\r\n\r\n### 思路\r\n\r\n先想 dp 。求的可以看成有 $n−1−k$ 个位置不满足的序列个数。\r\n\r\n因为 $(N − k + 1)\\times m\\leq 2^{20}$，设 $dp_{i,j,k}$ 表示前 $i$ 个值，有 $j$ 个不满足,结尾为 $k$。\r\n\r\n$dp_{i,j,k}$ 的值转移到 $dp_{i+1,j,l},k\\leq l$ 和 $dp_{i+1,j+1,l},j<m$。\r\n\r\n令 $s=j\\times m+k$，则 $dp_{i,s}$ 可以转移到 $dp_{i+1,s1},s+1\\leq s1\\leq s+m$。\r\n\r\n---\r\n\r\n写成生成函数。$dp_i=(x+...+x\r\n^m)^i$。$dp_{i,s}$ 即为 $dp_i$ 在 $x^s$ 处的系数。\r\n\r\n对于一个长度小于 $N$ 的序列，在后面补上 $N−n$ 个不满足。\r\n\r\n可以写成：\r\n\r\n$$\\sum_{i=1}^N{((x+...+x^m)^i\\times (x^m)^{N-i})}$$\r\n\r\n$$=\\frac{(x+...+x^m-x^m)\\times \\sum_{i=1}^N{((x+...+x^m)^i\\times (x^m)^{N-i}})}{x+...+x^{m-1}}$$\r\n\r\n$$=\\frac{\\sum_{i=1}^N{((x+...+x^m)^{i+1}\\times (x^m)^{N-i}}-(x+...+x^m)^i\\times (x^m)^{N-i+1})}{x+...+x^{m-1}}$$\r\n\r\n$$=\\frac{(x+...+x^m)^{N+1}-(x+...+x^m)\\times (x^m)^{N+1}}{x+...+x^{m-1}}$$\r\n\r\n$$=\\frac{(x+...+x^m)^{N+1}-(x^m)^{N+1}}{x+...+x^{m-1}}-(x^m)^N$$\r\n\r\n$$=x^N\\times \\frac{(1+...+x^{m-1})^{N+1}-(x^{m-1})^{N+1}}{1+...+x^{m-2}}-(x^m)^N$$\r\n\r\n而答案即为 $x^{(N−1−k)∗m+1}...x^{(N−k)∗m}$ 项的系数之和。\r\n\r\n---\r\n\r\n设 $G(x)=1+...+x^{m-1},F(x)=G(x)^{N+1}=\\sum{(f_i\\times x^i)}$。\r\n\r\n$$F'(x)=(N+1)G'(x)G(x)^N$$\r\n\r\n$$F'(x)G(x)=(N+1)G'(x)F(x)$$\r\n\r\n$$F'(x)=\\sum i\\times f_i\\times x^{i-1}$$\r\n\r\n$$G'(x)=\\sum_{i=0}^{m-2}{(i+1)\\times x^i}$$\r\n\r\n对于 $x^n$ 对比系数：\r\n\r\n$$\\sum_{i=0}^{m-1}{(n-i+1)\\times f_{n-i+1}}=\\sum_{i=0}^{m-2}{(i+1)\\times f_{n-i}}$$\r\n\r\n$$(n+1)f_{n+1}=\\sum_{i=1}^{m-1}{((N+2)\\times i-n-1)f_{n-i+1}}$$\r\n\r\n$$f_i=((n+2)\\times ((i\\times \\sum_{j=1}^{m-1}{f_{i-j})}-\\sum_{j=1}^{m-1}{((n-j+1)\\times f_{n-j+1}}))-i\\times \\sum_{j=1}^{m-1}{f_{n-j+1}})\\times inv_i$$\r\n\r\n前缀和转移。\r\n\r\n到这里可以算出 $(1+...+x^{m-1})^{N+1}-(x^{m-1})^{N+1}$ 的系数。\r\n\r\n---\r\n\r\n处理除法。\r\n\r\n设 $g(x)=\\frac{1}{1+...+x^{m-1}}=\\sum (g_i\\times x^i)$。\r\n\r\n$$g_0=1$$\r\n\r\n对于 $x^n$ 对比系数：\r\n\r\n$$\\sum_{i=0}^{m-1}{g_{n-i}}=0$$\r\n\r\n$$g_i=\\sum_{i=1}^{m-2}{g_{i-j}}$$\r\n\r\n\r\n答案即为 $F(x)\\times g(x)$ 的 $x^{(N−1−k)∗m+1-N}...x^{(N−k)∗m-N}$ 项系数和。\r\n\r\n对于每个 $f_i$ 计算贡献：\r\n\r\n$$ans=\\sum_i {((\\sum_{j=(N-k)\\times m+1-i-N}^{(N-k)\\times m+m-i-N}{g_j})\\times f_i)}$$\r\n\r\nend.",
      "data": {
        "title": "A story of The Small P 题解",
        "date": "2023-12-31 22:25:54",
        "tags": [
          "题解",
          "生成函数"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "a-story-of-the-small-p-ti-jie"
    },
    {
      "content": "[[JOISC2022] 监狱](https://www.luogu.com.cn/problem/P9520)\r\n\r\n### 思路\r\n\r\n因为是一棵树，最短路径唯一，所以每次都让一个人走到底。当走 $s->t$，$s->t$ 中此时没有点，意味着起点这条路径上的人一定先于这个人走，终点在这条路径导航的人一定后于这个人走。对于他们的相对顺序的限制，先走向后走连边，连边跑拓扑排序看有没有环。复杂度 $O(n^2)$。\r\n\r\n优化建图，形如一个点向一条路径连边，一条路径向一个点连边。把一个点拆成两个，一个记录进入，一个出去。\r\n\r\n线段树 $O(n\\log^2 n)$，但可以倍增优化 $O(n\\log n)$。记 $in_{u,i}$ 和 $out_{u,i}$ 表示 $u$ 到 $u$ 的 $2^i$ 级祖先这段区间。然后跟线段树优化一样向下一级区间连边。点向路径连边则在跳路径的 lca 是连边。\r\n\r\n显然倍增常数过大甚至有时不如线段树。\r\n\r\n```cpp\r\nint n,m;\r\nint head[maxn<<6],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<7];\r\nint d[maxn<<6];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;d[v]++;}\r\nint to[maxn][17],dep[maxn];\r\nint in[maxn][17],out[maxn][17],idx;\r\nvoid dfs(int u,int fa){\r\n\tto[u][0]=fa;dep[u]=dep[fa]+1;\r\n\tfor(int i=1;i<=16;i++)to[u][i]=to[to[u][i-1]][i-1];\r\n\tfor(int i=0;i<=16;i++)if(to[u][i])in[u][i]=++idx,out[u][i]=++idx,d[idx-1]=d[idx]=0;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);\r\n\t}\r\n}\r\nint lca(int u,int v){\r\n\tif(dep[u]<dep[v])swap(u,v);\r\n\tfor(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v])u=to[u][i];\r\n\tif(u==v)return u;\r\n\tfor(int i=16;~i;i--)if(to[u][i]!=to[v][i])u=to[u][i],v=to[v][i];\r\n\treturn to[u][0];\r\n}\r\nint kth(int u,int k){\r\n\tfor(int i=16;~i;i--)if((k>>i)&1)u=to[u][i];\r\n\treturn u;\r\n}\r\nvoid updin(int u,int v,int w){\r\n\tif(u==v){\r\n\t\tadd(w,u);\r\n\t\treturn ;\r\n\t}\r\n\tif(dep[u]<dep[v])swap(u,v);\r\n\tfor(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v]){\r\n\t\tadd(w,in[u][i]);\r\n\t\tu=to[u][i];\r\n\t}\r\n\tif(u==v)return ;\r\n\tfor(int i=16;~i;i--)if(to[u][i]!=to[v][i]){\r\n\t\tadd(w,in[u][i]),add(w,in[v][i]);\r\n\t\tu=to[u][i],v=to[v][i];\r\n\t}\r\n\tadd(w,to[u][0]);\r\n\tadd(w,u),add(w,v);\r\n}\r\nvoid updout(int u,int v,int w){\r\n\tif(u==v){\r\n\t\tadd(u+n,w);\r\n\t\treturn ;\r\n\t}\r\n\tif(dep[u]<dep[v])swap(u,v);\r\n\tfor(int i=16;~i;i--)if(dep[to[u][i]]>=dep[v]){\r\n\t\tadd(out[u][i],w);\r\n\t\tu=to[u][i];\r\n\t}\r\n\t// cout<<u<<\" \"<<v<<\" \"<<w<<\" out\\n\";\r\n\tif(u==v)return ;\r\n\tfor(int i=16;~i;i--)if(to[u][i]!=to[v][i]){\r\n\t\tadd(out[u][i],w),add(out[v][i],w);\r\n\t\tu=to[u][i],v=to[v][i];\r\n\t}\r\n\tadd(to[u][0]+n,w);\r\n\tadd(u+n,w),add(v+n,w);\r\n}\r\nqueue<int> q;\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t}\r\n\tm=read();idx=2*n+m;\r\n\tdfs(1,0);\r\n\tfor(int i=1;i<=n;i++)head[i]=0;tot=0;\r\n\tfor(int i=1;i<=idx;i++)d[i]=0;\r\n\tfor(int u=1;u<=n;u++){\r\n\t\tfor(int i=1;i<=16;i++)if(to[u][i]){\r\n\t\t\tadd(in[u][i],in[u][i-1]),add(in[u][i],in[to[u][i-1]][i-1]);\r\n\t\t\tadd(out[u][i-1],out[u][i]),add(out[to[u][i-1]][i-1],out[u][i]);\r\n\t\t}\r\n\t\tif(to[u][0]){\r\n\t\t\tadd(in[u][0],u),add(in[u][0],to[u][0]);\r\n\t\t\tadd(u+n,out[u][0]),add(to[u][0]+n,out[u][0]);\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(i+2*n,u+n),add(v,i+2*n);\r\n\t\t// cout<<i+2*n<<\" \"<<u+n<<\" \"<<v<<\"\\n\";\r\n\t\tint tp=lca(u,v),uu,vv;\r\n\t\tif(tp==u)uu=kth(v,dep[v]-dep[tp]-1);\r\n\t\telse uu=to[u][0];\r\n\t\tif(tp==v)vv=kth(u,dep[u]-dep[tp]-1);\r\n\t\telse vv=to[v][0];\r\n\t\t// cout<<uu<<\" \"<<vv<<\" q\\n\";\r\n\t\tupdin(u,vv,i+2*n);updout(uu,v,i+2*n);\r\n\t}\r\n\t// for(int u=1;u<=idx;u++){\r\n\t\t// for(int i=head[u];i;i=e[i].nxt){\r\n\t\t\t// int v=e[i].to;\r\n\t\t\t// cout<<u<<\" \"<<v<<\"\\n\";\r\n\t\t// }\r\n\t// }\r\n\tfor(int i=1;i<=idx;i++)if(!d[i])q.push(i);\r\n\twhile(!q.empty()){\r\n\t\tint u=q.front();q.pop();\r\n\t\t// if(u>2*n&&u<=2*n+m)cout<<u-2*n<<\" t\\n\";\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(d[v]){\r\n\t\t\t\td[v]--;\r\n\t\t\t\tif(!d[v])q.push(v);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=idx;i++)head[i]=0;tot=0;\r\n\t// for(int i=1;i<=idx;i++)if(d[i])cout<<i<<\" \"<<d[i]<<\" d\\n\";\r\n\tfor(int i=2*n+1;i<=2*n+m;i++)if(d[i]){printf(\"No\\n\");return ;}\r\n\tprintf(\"Yes\\n\");\r\n}\r\n```",
      "data": {
        "title": "P9520 题解",
        "date": "2023-12-31 22:19:23",
        "tags": [
          "题解",
          "图论",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p9520-ti-jie"
    },
    {
      "content": "[P10272](https://www.luogu.com.cn/problem/P10272)\r\n\r\n[P7525](https://www.luogu.com.cn/problem/P7525) 加强版。\r\n\r\n### 思路\r\n\r\n分类讨论。如果 $S$ 存在一个周期，设最小周期长为 $len$。那么第 $i$ 次操作是在 $i-1$长度上加 $(n-len)\\times 2^i$。用字符串哈希判断是否存在长为 $i$ 的周期，只需要判断 $s[1,n-i]=s[i+1,n]$ 即可。$\\sum_{i=l}^r 2^i=2^{r+1}-2^l$。快速幂处理。\r\n\r\n如果 $S$ 不存在一个周期，找到真 border $T$，再找到 $T$ 的最小周期 $TT$，发现此时答案只取决于 $S$ 开头存在 $num$ 个连续的 $TT$。记 $cnt=\\frac{\\mid T\\mid}{\\mid TT\\mid}$，发现每次操作答案增加 $\\min(cnt\\times 2^i,num)$ 个 $TT$。模拟前 $\\log n$ 次操作后每次操作答案增加为定值，计算等差数列即可。\r\n\r\n只需要字符串哈希，复杂度 $O(n)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,l,r;\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;b%=(mod-1);\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%mod;\r\n\t\ta=a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nchar c[maxn];\r\nint a[maxn],val[26],bas,pw[maxn];\r\nint calc(int l,int r){\r\n\treturn (a[r]-a[l-1]*pw[r-l+1]%mod+mod)%mod;\r\n}\r\nvoid work(){\r\n\tscanf(\"%s\",c+1);n=strlen(c+1);l=read(),r=read();\r\n\tsrand(time(0));bas=rand()*rand()%mod;\r\n\tfor(int i=0;i<26;i++)val[i]=rand()*rand()%bas;\r\n\tfor(int i=1;i<=n;i++)a[i]=(a[i-1]*bas+val[c[i]-'a'])%mod;\r\n\tpw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*bas%mod;\r\n\tint pos=0;\r\n\tfor(int i=1;i<=n/2;i++)if(n%i==0&&calc(1,n-i)==calc(i+1,n)){pos=i;break;}\r\n//\tcout<<pos<<\"\\n\";\r\n\tif(pos){printf(\"%lld\\n\",(pos*(r-l+1)%mod+(n-pos)*(ksm(2,r+1)-ksm(2,l)+mod)%mod)%mod);return ;}\r\n\tfor(int i=1;i<n;i++)if(calc(1,i)==calc(n-i+1,n))pos=i;\r\n\tif(!pos){printf(\"%lld\\n\",n*(r-l+1)%mod);return ;}\r\n\tint num=0,cnt=1;\r\n\tfor(int i=1;i<=pos/2;i++)if(pos%i==0&&calc(1,pos-i)==calc(i+1,pos)){cnt=pos/i;pos=i;break;}\r\n\tfor(int i=pos;i<=n;i+=pos){\r\n\t\tif(calc(1,pos)==calc(i-pos+1,i))num++;\r\n\t\telse break;\r\n\t}\r\n\twhile(l&&cnt<=num){\r\n\t\tn+=cnt*pos%mod;n%=mod;\r\n\t\tl--,r--;cnt<<=1;\r\n\t}\r\n\tif(l){\r\n\t\tprintf(\"%lld\\n\",(n*(r-l+1)%mod+(r+l)*(r-l+1)/2%mod*num%mod*pos%mod)%mod);\r\n\t\treturn ;\r\n\t}\r\n\tint ans=n;\r\n\twhile(r&&cnt<=num){\r\n\t\tn+=cnt*pos%mod;n%=mod;\r\n\t\tans+=n;ans%=mod;r--;cnt<<=1;\r\n\t}\r\n\tprintf(\"%lld\\n\",(ans+r*n%mod+r*(r+1)/2%mod*num%mod*pos%mod)%mod);\r\n}\r\n```",
      "data": {
        "title": "P10272 题解",
        "date": "2023-12-31 21:58:17",
        "tags": [
          "题解",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p10272-ti-jie"
    },
    {
      "content": "[P10144](https://www.luogu.com.cn/problem/P10144)\r\n\r\n考场上瞪了两个小时什么没想到，最后半小时想到一个不太一样的做法，写出来了但挂了。寄。\r\n\r\n### 思路\r\n\r\n记 $l=2\\times L$。令 $i$ 取 $a_i$ 记为 $0$，取 $l-a_i$ 记为 $1$，写为 01 序列。\r\n\r\n考虑取 $0/1$ 对 $l$ 的上下界的影响。分类讨论转移，以 $a_i<a_{i+1}$ 为例。\r\n\r\n- $i$ 取 $0$，$i+1$ 取 $0$：没影响；\r\n\r\n- $i$ 取 $0$，$i+1$ 取 $1$：$l>a_i+a_{i+1}$；\r\n\r\n- $i$ 取 $1$，$i+1$ 取 $0$：$l<a_i+a_{i+1}$；\r\n\r\n- $i$ 取 $1$，$i+1$ 取 $1$：不合法；\r\n\r\n这样可能存在一个状态有两个转移，不知道哪边更优。\r\n\r\n瞪了两个小时观察发现在一段连续上升或下降的区间，肯定会连着取 $a_i$ 或 $l-a_i$，即连续的 $00$ 或 $11$。而转角处向前向后其中一个间隔才可能存在 01 或 10。\r\n\r\n然后发现并不存在一个状态得到两个交集非空且互不包含的转移，直接取两个的并即可。然后就可以用线段树维护区间左右两边的状态分别是什么。\r\n\r\n考试的时候发现来不急了，写了二分右端点再线段树查询判断 $O(n\\log^2 n)$，但 $a_i=a_{i+1}$ 注意到了但特判错了，寄。\r\n\r\n考虑到右端点有单调性，从上一个答案向后判断即可，复杂度 $O(n\\log n)$。\r\n\r\n### code\r\n\r\n```cpp\r\n#define pii pair<int,int>\r\n\r\nint n,a[maxn],ans;\r\nstruct nd{\r\n\tpii f[2][2];\r\n}tree[maxn<<2];\r\nvoid init(pii &u){\r\n\tif(u.first>=u.second)u=make_pair(inf,0);\r\n}\r\nvoid clr(nd &u){\r\n\tfor(int i=0;i<2;i++){\r\n\t\tfor(int j=0;j<2;j++)init(u.f[i][j]);\r\n\t}\r\n}\r\npii mymin(pii u,pii v){\r\n\tinit(u),init(v);\r\n\treturn {max(u.first,v.first),min(u.second,v.second)};\r\n}\r\npii mymax(pii u,pii v){\r\n\tinit(u),init(v);\r\n\treturn {min(u.first,v.first),max(u.second,v.second)};\r\n}\r\nnd merge(nd u,nd v){\r\n\tnd res;\r\n\tfor(int i=0;i<2;i++){\r\n\t\tfor(int j=0;j<2;j++){\r\n\t\t\tres.f[i][j]=mymax(mymin(u.f[i][0],v.f[0][j]),mymin(u.f[i][1],v.f[1][j]));\r\n\t\t\tinit(res.f[i][j]);\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\n#define mid (l+r>>1)\r\n#define ls o<<1\r\n#define rs o<<1|1\r\nvoid build(int o,int l,int r){\r\n\tif(l==r){\r\n\t\ttree[o].f[0][0]=tree[o].f[1][1]={inf,0};\r\n\t\ttree[o].f[0][1]={a[l]+a[l+1],inf};\r\n\t\ttree[o].f[1][0]={0,a[l]+a[l+1]};\r\n\t\tif(a[l]<a[l+1])tree[o].f[0][0]={0,inf};\r\n\t\tif(a[l]>a[l+1])tree[o].f[1][1]={0,inf};\r\n\t\treturn ;\r\n\t}\r\n\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n\ttree[o]=merge(tree[ls],tree[rs]);\r\n\tclr(tree[o]);\r\n}\r\nnd query(int o,int l,int r,int ql,int qr){\r\n\tif(l>=ql&&r<=qr)return tree[o];\r\n\tif(qr<=mid)return query(ls,l,mid,ql,qr);\r\n\tif(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n\tnd res=merge(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));\r\n\tclr(res);\r\n\treturn res;\r\n}\r\nbool check(int l,int r){\r\n\tnd res=query(1,1,n-1,l,r-1);\r\n\tfor(int i=0;i<2;i++){\r\n\t\tfor(int j=0;j<2;j++){\r\n\t\t\tif(res.f[i][j].first<res.f[i][j].second)return true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n#undef mid\r\n\r\nsigned main(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tbuild(1,1,n-1);\r\n\tfor(int i=1,r=0;i<=n;i++){\r\n\t\tif(r<i)r=i;\r\n\t\twhile(r<n&&check(i,r+1))r++;\r\n\t\tans+=r-i;\r\n\t\t// cout<<i<<\" \"<<r<<\"\\n\";\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "P10144 题解",
        "date": "2023-12-31 21:57:21",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p10144-ti-jie"
    },
    {
      "content": "[P9351](https://www.luogu.com.cn/problem/P9351)\r\n\r\n### 思路\r\n\r\n观察到一次覆盖操作相当于 $(u,v)$ 向 $(u,v)$ 为中心的一个矩形挖去四个角中每个点连代价为 $1$ 的边。\r\n\r\n因为 $r\\le c$，$r\\le \\sqrt {rc}$。暴力是 01bfs，到每个点处理覆盖操作时枚举行一边，用 $n$ 个并查集维护每行没有被删去的后继。对于每个点需要枚举 $\\min(2\\times n,r)$ 行，每个点只被入队一次。复杂度 $O(rc\\sqrt {rc})$。\r\n\r\n瓶颈在于枚举一行时有可能整行都没有要入队的点。\r\n\r\n观察发现，除了最后一次覆盖操作以外，每一次覆盖操作都只让矩形边界上的点入队一定不劣。如果通过覆盖操作到达矩形边界内一个点有意义，那一定有一个原来的白连通块从这个点跨到矩形外面去，那这样之前通过覆盖操作到达矩形和连通块相交的位置即可。\r\n\r\n这样每次一个点向 $4$ 条边中的点连边，维护每行每列的未操作后缀的并查集。复杂度 $O(rc)$\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,d;\r\nint sx,sy,ex,ey;\r\nchar s[maxn];\r\nvector<vector<int>> a,dis;\r\nint fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\r\nvector<vector<int>> f;\r\nint fd(int id,int x){\r\n\tif(x==f[id][x])return x;\r\n\treturn f[id][x]=fd(id,f[id][x]);\r\n}\r\npii q[maxn];int h=1,t=0;\r\npii st[maxn];int tp;\r\nint ans;\r\nvoid work(){\r\n\tn=read(),m=read(),d=read();\r\n\ta.resize(n+1),dis.resize(n+1);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\ta[i].resize(m+1),dis[i].resize(m+1);\r\n\t\tfor(int j=1;j<=m;j++)dis[i][j]=inf;\r\n\t}\r\n\tf.resize(n+m+1);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tf[i].resize(m+2);f[i][m+1]=m+1;\r\n\t\tfor(int j=1;j<=m;j++)f[i][j]=j;\r\n\t}\r\n\tfor(int i=n+1;i<=n+m;i++){\r\n\t\tf[i].resize(n+2);f[i][n+1]=n+1;\r\n\t\tfor(int j=1;j<=n;j++)f[i][j]=j;\r\n\t}\r\n\tsx=read(),sy=read(),ex=read(),ey=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tscanf(\"%s\",s+1);\r\n\t\tfor(int j=1;j<=m;j++)a[i][j]=(s[j]=='.');\r\n\t}\r\n\tdis[sx][sy]=0,q[++t]={sx,sy};\r\n\tint cnt=0;ans=inf;\r\n\twhile(h<=t){\r\n\t\ttp=0;\r\n\t\twhile(h<=t){\r\n\t\t\tint u=q[h].fi,v=q[h].se;h++;\r\n\t\t\tif(abs(u-ex)<=d+1&&abs(v-ey)<=d+1&&abs(u-ex)+abs(v-ey)<=2*d)ans=min(ans,dis[u][v]+1);\r\n\t\t\tf[u][v]=fd(u,v+1);f[v+n][u]=fd(v+n,u+1);\r\n\t\t\tif(1){\t\r\n\t\t\t\tint i=max(1,u-d);\r\n\t\t\t\tint l=max(1,(i==u-d||i==u+d)?v-d+1:v-d);\r\n\t\t\t\tint r=min(m,(i==u-d||i==u+d)?v+d-1:v+d);\r\n\t\t\t\tfor(int j=fd(i,l);j<=r;j=fd(i,j)){\r\n\t\t\t\t\tif(dis[i][j]>dis[u][v]+1){\r\n\t\t\t\t\t\tdis[i][j]=dis[u][v]+1;\r\n\t\t\t\t\t\tst[++tp]={i,j};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf[i][j]=fd(i,j+1);f[j+n][i]=fd(j+n,i+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(1){\t\r\n\t\t\t\tint i=min(n,u+d);\r\n\t\t\t\tint l=max(1,(i==u-d||i==u+d)?v-d+1:v-d);\r\n\t\t\t\tint r=min(m,(i==u-d||i==u+d)?v+d-1:v+d);\r\n\t\t\t\tfor(int j=fd(i,l);j<=r;j=fd(i,j)){\r\n\t\t\t\t\tif(dis[i][j]>dis[u][v]+1){\r\n\t\t\t\t\t\tdis[i][j]=dis[u][v]+1;\r\n\t\t\t\t\t\tst[++tp]={i,j};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf[i][j]=fd(i,j+1);f[j+n][i]=fd(j+n,i+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(1){\t\r\n\t\t\t\tint i=max(1,v-d);\r\n\t\t\t\tint l=max(1,(i==v-d||i==v+d)?u-d+1:u-d);\r\n\t\t\t\tint r=min(n,(i==v-d||i==v+d)?u+d-1:u+d);\r\n\t\t\t\tfor(int j=fd(i+n,l);j<=r;j=fd(i+n,j)){\r\n\t\t\t\t\tif(dis[j][i]>dis[u][v]+1){\r\n\t\t\t\t\t\tdis[j][i]=dis[u][v]+1;\r\n\t\t\t\t\t\tst[++tp]={j,i};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf[i+n][j]=fd(i+n,j+1);f[j][i]=fd(j,i+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(1){\t\r\n\t\t\t\tint i=min(m,v+d);\r\n\t\t\t\tint l=max(1,(i==v-d||i==v+d)?u-d+1:u-d);\r\n\t\t\t\tint r=min(n,(i==v-d||i==v+d)?u+d-1:u+d);\r\n\t\t\t\tfor(int j=fd(i+n,l);j<=r;j=fd(i+n,j)){\r\n\t\t\t\t\tif(dis[j][i]>dis[u][v]+1){\r\n\t\t\t\t\t\tdis[j][i]=dis[u][v]+1;\r\n\t\t\t\t\t\tst[++tp]={j,i};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf[i+n][j]=fd(i+n,j+1);f[j][i]=fd(j,i+1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(int i=0;i<4;i++){\r\n\t\t\t\tint nx=u+fx[i][0],ny=v+fx[i][1];\r\n\t\t\t\tif(nx<=0||nx>n||ny<=0||ny>m)continue;\r\n\t\t\t\tif(!a[nx][ny])continue;\r\n\t\t\t\tif(dis[nx][ny]>dis[u][v]){\r\n\t\t\t\t\tdis[nx][ny]=dis[u][v],q[++t]={nx,ny};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\th=1,t=0;\r\n\t\tcnt++;\r\n\t\tif(dis[ex][ey]!=inf||ans==cnt)break;\r\n\t\tfor(int i=1;i<=tp;i++){\r\n\t\t\tpii p=st[i];\r\n\t\t\tif(dis[p.fi][p.se]!=cnt)continue;\r\n\t\t\tq[++t]=p;\r\n\t\t}\r\n\t}\r\n\tprintf(\"%d\\n\",min(ans,dis[ex][ey]));\r\n}\r\n```",
      "data": {
        "title": "P9351 题解",
        "date": "2023-12-31 21:57:00",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p9351-ti-jie"
    },
    {
      "content": "[P7482](https://www.luogu.com.cn/problem/P7482)\r\n\r\n### 思路\r\n\r\n分治 $[l,mid]$ 到 $(mid,r]$ 的贡献。\r\n\r\n对于一个区间计算答案可以用 dp 完成。以 $mid$ 为交界合并左右的 dp 值。设 $f_{i,0/1}$ 表示区间 $[i,mid]$ 或区间 $(mid,i]$，是否选 $mid$ 或 $mid+1$ 的答案。\r\n\r\n$$f_{i,0}=\\max (f_{i+1,0},f_{i+2,0}+a_i)$$\r\n\r\n$$ans(i,j)=\\max (f_{i,0}+f_{j,1},f_{i,1}+f_{j,0})$$\r\n\r\n记跨过 $mid$ 的贡献为 $w$。\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} ans(i,j)$$\r\n\r\n记 $g_i=f_{i,1}-f_{i,0}$。\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} \\max(g_i+f_{i,0}+f_{j,0},g_j+f_{i,0}+f_{j,0})$$\r\n\r\n$$w=\\sum_{i=l}^{mid}\\sum_{j=mid+1}^{r} \\max(g_i,g_j)+\\sum_{i=l}^{mid}f_{i,0}\\times (r-mid)+\\sum_{j=mid+1}^r f_{j,0}\\times (mid-l+1)$$\r\n\r\n后面两个直接做，前面的对于每个 $i$ 拆开 max 计算。\r\n\r\n$$\\sum_{j=mid+1}^{r} \\max(g_i,g_j)=\\sum_{j=mid+1}^{r}[g_i\\geq g_j]\\times g_i+[g_i<g_j]\\times g_j$$\r\n\r\n\r\n对 $(mid,r]$ 的 $g_j$ 排序，二分 $g_i$ 的位置，记录 $g_j$ 的后缀和即可。\r\n\r\n其余的递归 $[l,mid]$ 和 $(mid,r]$ 解决。\r\n\r\n然后发现一个 sub 都没过。原因是不一定一定要选 $mid$ 和 $mid+1$，将 $f_{i,1}$ 的定义改为区间不考虑任何限制的最大值，强行当作选 $mid$ 位置即可。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn],ans;\r\nint f[maxn][2],g[maxn];\r\nint b[maxn],len,sum[maxn];\r\nvoid sovle(int l,int r){\r\n\tif(l==r){\r\n\t\t(ans+=a[l])%=mod;\r\n\t\treturn ;\r\n\t}\r\n\tint mid=l+r>>1;\r\n\tf[mid][0]=0,f[mid][1]=a[mid];\r\n\tif(mid-1>=l)f[mid-1][0]=a[mid-1],f[mid-1][1]=max(a[mid-1],a[mid]);\r\n\tfor(int i=mid-2;i>=l;i--){\r\n\t\tf[i][0]=max(f[i+1][0],f[i+2][0]+a[i]);\r\n\t\tf[i][1]=max(f[i+1][1],f[i+2][1]+a[i]);\r\n\t}\r\n\tf[mid+1][0]=0,f[mid+1][1]=a[mid+1];\r\n\tif(mid+2<=r)f[mid+2][0]=a[mid+2],f[mid+2][1]=max(a[mid+2],a[mid+1]);\r\n\tfor(int i=mid+3;i<=r;i++){\r\n\t\tf[i][0]=max(f[i-1][0],f[i-2][0]+a[i]);\r\n\t\tf[i][1]=max(f[i-1][1],f[i-2][1]+a[i]);\r\n\t}\r\n\tint sl=0,sr=0;\r\n\tfor(int i=l;i<=mid;i++)(sl+=f[i][0])%=mod;\r\n\tfor(int i=mid+1;i<=r;i++)(sr+=f[i][0])%=mod;\r\n\t(ans+=sl*(r-mid)+sr*(mid-l+1))%=mod;\r\n//\tcout<<l<<\" \"<<r<<\" \"<<ans<<\"\\n\"; \r\n\tfor(int i=l;i<=r;i++)g[i]=f[i][1]-f[i][0];\r\n\tlen=0; \r\n\tfor(int i=mid+1;i<=r;i++)b[++len]=g[i];\r\n\tsort(b+1,b+len+1);sum[len+1]=0;\r\n\tfor(int i=len;i>=1;i--)sum[i]=(sum[i+1]+b[i]%mod+mod)%mod;\r\n\tfor(int i=l;i<=mid;i++){\r\n\t\tint p=upper_bound(b+1,b+len+1,g[i])-b;\r\n\t\t(ans+=(g[i]%mod+mod)*(p-1)+sum[p])%=mod;\r\n//\t\tcout<<i<<\" \"<<g[i]<<\" \"<<p<<\" \"<<sum[p]<<\"\\n\";\r\n\t}\r\n\tsovle(l,mid),sovle(mid+1,r);\r\n}\r\n```",
      "data": {
        "title": "P7482 题解",
        "date": "2023-12-31 17:25:39",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p7482-ti-jie"
    },
    {
      "content": "[P7247](https://www.luogu.com.cn/problem/P7247)\r\n\r\n参考 EI 题解。\r\n\r\n### 思路\r\n\r\n因为随机移动，所以可以不管当前在具体哪个点，发现本质不同的只有根节点和非根节点。设 $dp_{i,0/1}$ 表示还剩 $i$ 个未标记点，当前在或不在根节点。可以通过根到随机非根节点的期望 $x$，随机非根节点到根的期望 $y$，随机非根节点到另一个随机非根节点的期望 $z$ 来转移。\r\n\r\n可以 dfs 预处理三个值。期望转为总和除以方案数。记 $dis_u$ 表示 $1$ 到 $u$ 的距离。\r\n\r\n$$x=\\frac{\\sum dis_u\\times a_u}{n-1}$$\r\n\r\n$$y=\\frac{\\sum dis_u\\times a_1}{n-1}$$\r\n\r\n$$z=\\frac{\\sum_{u\\neq 1}\\sum_{v\\neq 1}(dis_u+dis_v-2\\times dis_{lca(u,v)}\\times a_u}{(n-1)\\times(n-2)}$$\r\n\r\n对于 $z$ 当递归到 $u$ ，计算 $lca(uu,vv)=u$ 的有序对 $(uu,vv)$ 的答案。分别计算从每个子树出去和进入每个子树的贡献和。然后就可以 dp。\r\n\r\n$$dp_{i,0}=\\frac{i}{n-1}\\times (dp_{i-1,1}+x)+\\frac{n-i-1}{n-1}\\times(dp_{i,1}+y)$$\r\n\r\n$$dp_{i,1}=\\frac{i}{n-1}\\times (dp_{i-1,1}+z)+\\frac{1}{n-1}\\times(dp_{i,0}+y)+\\frac{n-i-2}{n-1}\\times(dp_{i,1}+z)$$\r\n\r\n移项解得：\r\n\r\n$$dp_{i,0}=dp_{i-1,1}+\\frac{(n-1)(i-1)x+(n-i-1)y+(n-i-1)(n-2)z}{n\\times i}$$\r\n\r\n$$dp_{i,1}=dp_{i-1,1}+\\frac{(n-1)x+(n-1)y+(n-1)(n-2)z}{n\\times i}$$\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn];\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to,w;\r\n}e[maxn<<1];\r\nvoid add(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}\r\nint x,y,z;\r\nint dis[maxn],sum[maxn],siz[maxn],sa[maxn],mul[maxn];\r\nint inc(int u,int v){\r\n\t((u+=v)>=mod)&&(u-=mod);\r\n\treturn u;\r\n}\r\nvoid dfs(int u,int fa){\r\n\tif(u!=1)(x+=dis[u]*a[u])%=mod,(y+=dis[u]*a[1])%=mod;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdis[v]=inc(dis[u],e[i].w);dfs(v,u);\r\n\t\tsiz[u]+=siz[v],sum[u]=inc(sum[u],sum[v]),sa[u]=inc(sa[u],sa[v]),mul[u]=inc(mul[u],mul[v]);\r\n\t}\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\t(z+=(siz[u]-siz[v])*(mul[v]-dis[u]*sa[v]%mod+mod))%=mod;\r\n\t\t(z+=(sa[u]-sa[v]+mod)*(sum[v]-siz[v]*dis[u]%mod+mod))%=mod;\r\n\t}\r\n\tif(u!=1){\r\n\t\t(z+=a[u]*(sum[u]-siz[u]*dis[u]%mod+mod))%=mod;\r\n\t\t(z+=mul[u]-dis[u]*sa[u]%mod+mod)%=mod;\r\n\t}\r\n\tsiz[u]++,sum[u]=inc(sum[u],dis[u]),sa[u]=inc(sa[u],a[u]),(mul[u]+=a[u]*dis[u])%=mod;\r\n}\r\nint dp[maxn][2];\r\nint inv[maxn];\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read(),w=read();\r\n\t\tadd(u,v,w),add(v,u,w);\r\n\t}\r\n\tdfs(1,0);\r\n\tinv[0]=inv[1]=1;for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;\r\n\tx=x*inv[n-1]%mod,y=y*inv[n-1]%mod,z=z*inv[n-1]%mod*inv[n-2]%mod;\r\n\tfor(int i=1;i<n;i++){\r\n\t\tdp[i][0]=(dp[i-1][1]+((n-1)*(i+1)%mod*x+(n-i-1)*y+(n-i-1)*(n-2)%mod*z)%mod*inv[i]%mod*inv[n])%mod;\r\n\t\tdp[i][1]=(dp[i-1][1]+((n-1)*x+(n-1)*y+(n-1)*(n-2)%mod*z)%mod*inv[i]%mod*inv[n])%mod;\r\n\t}\r\n\tprintf(\"%lld\\n\",dp[n-1][0]);\r\n}\r\n```",
      "data": {
        "title": "P7247 题解",
        "date": "2023-12-31 17:25:11",
        "tags": [
          "题解",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p7247-ti-jie"
    },
    {
      "content": "[P7230](https://www.luogu.com.cn/problem/P7230)\r\n\r\n### 思路\r\n\r\n对每个左端点维护右端点 $res_i$。操作形如删去一个数再加入一个数。如果删掉 $p$ 上的 $a_p$，找到左右最近的 $l,r$ 使得 $a_l=a_r=a_p$。那么 $res_{l+1},\\dotsb,res_p$ 对 $r$ 取 max。实际上要维护 $\\max res_i-i+1$，因为 $res_i$ 单调，所以相当于线段树上二分找到最左的小于 $r$ 的位置然后区间覆盖。\r\n\r\n删除好做，加入难做，考虑线段树分治。先把所有的时刻的 $a_i$ 都当作存在，右移右端点维护出所有 $res_i$。multiset 维护每个值出现的位置来求 $l,r$。进入一个区间后进行删除操作。撤销操作可以用主席树，也可以记录下所有修改和下传的位置和值。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,q,a[maxn];\r\nmultiset<int> s[maxn];\r\nint que[maxn],res[maxn],cnt[maxn];\r\nvector<int> val[maxn];\r\nint st[maxn<<6][4],tp;\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nnamespace sgt{\r\n\tint mx[maxn<<2],tag[maxn<<2],ans[maxn<<2];\r\n\tvoid build(int nd,int l,int r){\r\n\t\tif(l==r){\r\n\t\t\tmx[nd]=res[l];ans[nd]=mx[nd]-l+1;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n\t\tmx[nd]=max(mx[ls],mx[rs]),ans[nd]=min(ans[ls],ans[rs]);\r\n\t}\r\n\tvoid down(int nd,int l,int r){\r\n\t\t\tst[++tp][0]=nd,st[tp][1]=mx[nd],st[tp][2]=tag[nd],st[tp][3]=ans[nd];\r\n\t\tst[++tp][0]=ls,st[tp][1]=mx[ls],st[tp][2]=tag[ls],st[tp][3]=ans[ls];\r\n\t\tmx[ls]=tag[nd],tag[ls]=tag[nd],ans[ls]=mx[ls]-mid+1;\r\n\t\tst[++tp][0]=rs,st[tp][1]=mx[rs],st[tp][2]=tag[rs],st[tp][3]=ans[rs];\r\n\t\tmx[rs]=tag[nd],tag[rs]=tag[nd],ans[rs]=mx[rs]-r+1;\r\n\t\ttag[nd]=0;\r\n\t}\r\n\tvoid updata(int nd,int l,int r,int ql,int qr,int w){\r\n\t\tif(ql>qr)return ;\r\n\t\tif(l>=ql&&r<=qr){\r\n\t\t\tst[++tp][0]=nd,st[tp][1]=mx[nd],st[tp][2]=tag[nd],st[tp][3]=ans[nd];\r\n\t\t\tmx[nd]=w,tag[nd]=w,ans[nd]=mx[nd]-r+1;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tif(tag[nd])down(nd,l,r);\r\n\t\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\t\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n\t\tst[++tp][0]=nd,st[tp][1]=mx[nd],st[tp][2]=tag[nd],st[tp][3]=ans[nd];\r\n\t\tmx[nd]=max(mx[ls],mx[rs]),ans[nd]=min(ans[ls],ans[rs]);\r\n\t}\r\n\tint fd(int nd,int l,int r,int w){\r\n\t\tif(mx[nd]<w)return -1;\r\n\t\tif(l==r)return l;\r\n\t\tif(tag[nd])down(nd,l,r);\r\n\t\tint val=fd(ls,l,mid,w);\r\n\t\tif(val==-1)return fd(rs,mid+1,r,w);\r\n\t\treturn val;\r\n\t}\r\n}\r\nvector<pii> tree[maxn<<2];\r\nvoid updata(int nd,int l,int r,int ql,int qr,pii w){\r\n\tif(ql>qr)return ;\r\n\tif(l>=ql&&r<=qr){\r\n\t\ttree[nd].pb(w);\r\n\t\treturn ;\r\n\t}\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n}\r\nvoid add(pii p){\r\n\tint l=*--s[p.se].find(p.fi);\r\n\tauto it=s[p.se].erase(s[p.se].find(p.fi));\r\n\tif(it==s[p.se].end()){\r\n\t\tsgt::updata(1,1,n,l+1,n,inf);\r\n\t\treturn ;\r\n\t}\r\n\tint r=*it;\r\n\tint pos=sgt::fd(1,1,n,r);\r\n\tif(pos>l+1)sgt::updata(1,1,n,l+1,pos-1,r);\r\n}\r\nvoid del(){\r\n\tint nd=st[tp][0];\r\n\tsgt::mx[nd]=st[tp][1],sgt::tag[nd]=st[tp][2],sgt::ans[nd]=st[tp][3];\r\n\ttp--;\r\n}\r\nvoid dfs(int nd,int l,int r){\r\n\tint tmp=tp;\r\n\tfor(pii p:tree[nd])add(p);\r\n\tif(l==r){\r\n\t\tif(que[l])printf(\"%lld\\n\",sgt::ans[1]>n?-1:sgt::ans[1]);\r\n\t}\r\n\telse{\r\n\t\tdfs(ls,l,mid),dfs(rs,mid+1,r);\r\n\t}\r\n\twhile(tp>tmp)del();\r\n\tfor(pii p:tree[nd])s[p.se].insert(p.fi);\r\n}\r\nvoid work(){\r\n\tn=read();m=read();q=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read(),s[a[i]].insert(i),val[i].pb(a[i]);\r\n\tfor(int i=1;i<=m;i++)s[i].insert(0);\r\n\tfor(int i=1;i<=q;i++){\r\n\t\tint op=read();\r\n\t\tif(op==1){\r\n\t\t\tint p=read(),v=read();\r\n\t\t\tupdata(1,1,q,i,q,{p,a[p]});\r\n\t\t\ta[p]=v;s[a[p]].insert(p);val[p].pb(a[p]);\r\n\t\t\tupdata(1,1,q,1,i-1,{p,a[p]});\r\n\t\t}\r\n\t\telse que[i]=1;\r\n\t}\r\n\tfor(int i=1,j=1,num=0;i<=n;i++){\r\n\t\twhile(j<=n&&num<m){\r\n\t\t\tfor(int k:val[j]){\r\n\t\t\t\tif(!cnt[k])++num;\r\n\t\t\t\tcnt[k]++;\r\n\t\t\t}\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tif(num<m)res[i]=inf;\r\n\t\telse res[i]=j-1;\r\n\t\tfor(int k:val[i]){\r\n\t\t\tcnt[k]--;\r\n\t\t\tif(!cnt[k])--num;\r\n\t\t}\r\n\t}\r\n\tsgt::build(1,1,n);\r\n\tdfs(1,1,q);\r\n}\r\n```\r\n\r\n### upd\r\n\r\n当线段树分治到叶子是也最多只有 $O(n)$ 个操作，所以栈的大小是 $O(n\\log n)$ 的。如果用主席树，整个线段树分治下来有 $O(n\\log n)$ 个操作，主席树空间 $O(n\\log^2 n)$ 寄了。可以回收节点，线段树分治撤销操作时不只跳到父亲版本，而是直接把当前版本新的点都删了，这样一来直接等价于对每层维护一个线段树了。",
      "data": {
        "title": "P7230 题解",
        "date": "2023-12-31 17:23:57",
        "tags": [
          "题解",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p7230-ti-jie"
    },
    {
      "content": "[CF1386C](https://www.luogu.com.cn/problem/CF1386C)\r\n\r\n[P6684](https://www.luogu.com.cn/problem/P6684)\r\n\r\ncf 上时限 $1$ 秒，洛谷 $2$ 秒。\r\n\r\n### 思路\r\n\r\n维护是否有奇环可用拓展域并查集。暴力复杂度 $O(mq)$。发现插入容易删除困难，用不删除的莫队，可撤销并查集，复杂度 $O((n+q)\\sqrt m\\log n)$。大概要 $5$ 秒左右，只能过洛谷上的前 $5$ 个子任务。\r\n\r\n等价对于每个 $r$ 求最小的 $l$ 使得 $[1,l]$ 和 $[r,m]$ 的边能组成奇环。将边复制一遍接在后面，即对于每个 $i$ 求最小的 $p$ 使得 $[i,p]$ 间的边组成奇环。这里 $p$ 有单调性。依次求每个 $i$，每次右移 $p$，加入的这条边 $p$ 会在求 $[i,p]$ 时都有贡献。插入容易删除困难，用线段树分治。初始没有边，分治到 $i$ 时会对之后一个区间加入若干条边，一共加边 $m$ 次。总复杂度 $O(m\\log^2 m)$。\r\n\r\n不开 long long 就能过 cf。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,q;\r\npii g[maxn];\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nvector<int> tree[maxn<<2];\r\nvoid updata(int nd,int l,int r,int ql,int qr,int id){\r\n\tif(ql>qr)return ;\r\n\tif(l>=ql&&r<=qr){\r\n\t\ttree[nd].pb(id);\r\n\t\treturn ;\r\n\t}\r\n\tif(ql<=mid)updata(ls,l,mid,ql,qr,id);\r\n\tif(qr>mid)updata(rs,mid+1,r,ql,qr,id);\r\n}\r\nint f[maxn],siz[maxn];\r\nint fd(int x){\r\n\tif(f[x]==x)return x;\r\n\treturn fd(f[x]);\r\n}\r\nint st[maxn<<5],tp,fl;\r\nvoid merge(int x,int y){\r\n\tint u=fd(x),v=fd(y),uu=fd(x+n),vv=fd(y+n);\r\n\tif(u==v){\r\n\t\tfl=1;\r\n\t\treturn ;\r\n\t}\r\n\tif(u!=vv){\r\n\t\tif(siz[u]<siz[vv])swap(u,vv);\r\n\t\tst[++tp]=vv;f[vv]=u,siz[u]+=siz[vv];\r\n\t\tif(siz[v]<siz[uu])swap(v,uu);\r\n\t\tst[++tp]=uu;f[uu]=v,siz[v]+=siz[uu];\r\n\t}\r\n}\r\nvoid del(){\r\n\tint u=st[tp];siz[f[u]]-=siz[u],f[u]=u;\r\n\ttp--;\r\n}\r\nint ans[maxn];\r\nint p=1;\r\nvoid dfs(int nd,int l,int r){\r\n\tint lst=tp,flag=fl;\r\n\tfor(int i:tree[nd])merge(g[i].fi,g[i].se);\r\n\tif(l==r){\r\n\t\twhile(p<=2*m&&!fl){\r\n\t\t\tmerge(g[p].fi,g[p].se);\r\n\t\t\tupdata(1,1,m+1,l+1,min(p,m+1),p);\r\n\t\t\tp++;\r\n\t\t}\r\n\t\tif(!fl)ans[l]=p;\r\n\t\telse ans[l]=p-1;\r\n\t}\r\n\telse dfs(ls,l,mid),dfs(rs,mid+1,r);\r\n\twhile(tp>lst)del();\r\n\tfl=flag;\r\n}\r\nvoid work(){\r\n\tn=read();m=read();q=read();\r\n\tfor(int i=1;i<=m;i++)g[i]={read(),read()},g[i+m]=g[i];\r\n\tfor(int i=1;i<=2*n;i++)f[i]=i,siz[i]=1;\r\n\tdfs(1,1,m+1);\r\n\twhile(q--){\r\n\t\tint l=read(),r=read();\r\n\t\tif(ans[r+1]<=m+l-1)puts(\"YES\");\r\n\t\telse puts(\"NO\");\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "CF1386C 题解",
        "date": "2023-12-31 17:22:47",
        "tags": [
          "题解",
          "数据结构",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1386c-ti-jie"
    },
    {
      "content": "[P6681](https://www.luogu.com.cn/problem/P6681)\r\n\r\n加强版 [qoj1193](https://qoj.ac/problem/1193)，$n\\leq 1000,m=16$。\r\n\r\n### 思路\r\n\r\n考虑选串的过程，是给短的后面加串直到长短互换。设状态 $id_{i,j}$ 表示当前长的一串末尾是 $s_i$，比短串长 $j$。枚举加入的串，状态的转移分两种：\r\n\r\n- 加入后短串还是比长串短。$id_{i,j}$ 到 $id_{i,j+siz_k}$，答案不变。\r\n\r\n- 加入后长短互换。$id_{i,j}$ 到 $id_{k,siz_k-(siz_i-j)}$，答案加 $siz_k-(siz_i-j)$。\r\n\r\n当加入串 $k$，相当于建图连边如上，边权为答案变化量，跑最短路。终点为 $id(i,0)$ 的最短路长度取 min。$nm$ 个点，$n^2m$ 条边，最短路复杂度 $O(E\\log V)=O(n^2m\\log nm)$。看上去不可过，实际过了。其实最短路复杂度中的 $E$ 是松弛次数，正常情况下是边数，但在这个图中最大边权为 $m$，所以每个点最多松弛 $m$ 次，复杂度 $O(nm\\log nm)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nstring s[maxn];\r\nint head[maxn*maxn],tot;\r\nstruct nd{\r\n\tint nxt,to,w;\r\n}e[maxn*maxn*maxn];\r\nvoid add(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}\r\nint dis[maxn*maxn];\r\nstruct Dis{\r\n\tint dis,id;\r\n\tbool operator<(const Dis&tmp)const{return dis>tmp.dis;}\r\n};\r\nbool vis[maxn*maxn];\r\npriority_queue<Dis> q;\r\nint id(int u,int v){return (u-1)*(m+1)+v+1;}\r\nconst int inf=1e9;\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=n;i++)cin>>s[i];\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=0;j<s[i].size();j++){\r\n\t\t\tfor(int k=1;k<=n;k++){\r\n\t\t\t\tif(i==k&&!j)continue;\r\n\t\t\t\tif(s[k].size()>=s[i].size()-j){\r\n\t\t\t\t\tif(s[i].substr(j,s[i].size()-j)==s[k].substr(0,s[i].size()-j)){\r\n\t\t\t\t\t\tint res=s[k].size()-(s[i].size()-j);\r\n\t\t\t\t\t\tadd(id(i,s[i].size()-j),id(k,res),res);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(s[i].substr(j,s[k].size())==s[k]){\r\n\t\t\t\t\t\tint res=s[i].size()-j-s[k].size();\r\n\t\t\t\t\t\tadd(id(i,s[i].size()-j),id(i,res),0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmems(dis,0x3f);\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tdis[id(i,s[i].size())]=s[i].size();\r\n\t\tq.push({s[i].size(),id(i,s[i].size())});\r\n\t}\r\n\twhile(!q.empty()){\r\n\t\tint u=q.top().id;q.pop();\r\n\t\tif(vis[u])continue;vis[u]=1;\r\n\t\t// cout<<u<<\" \"<<dis[u]<<\"\\n\";\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(dis[v]>dis[u]+e[i].w){\r\n\t\t\t\tdis[v]=dis[u]+e[i].w;\r\n\t\t\t\tq.push({dis[v],v});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tint ans=inf;\r\n\tfor(int i=1;i<=n;i++)ans=min(ans,dis[id(i,0)]);\r\n\tif(ans==inf)ans=-1;\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "P6681 题解",
        "date": "2023-12-31 17:22:08",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p6681-ti-jie"
    },
    {
      "content": "### [P5996](https://www.luogu.com.cn/problem/P5996)\r\n\r\n网络流。同 [P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762) 建图方式，将物品与 $s$ 连 $(s,i,v_i)$，警察与 $t$ 连 $(j+n,t,v_j)$，警察与对应的物品连 $(i,j+n,inf)$，答案为所有物品的收益和减最小割。割 $s,i,v_i$ 表示不选物品，收益减 $v_i$；割 $j+n,t,v_j$ 表示贿赂警察，收益减 $v_j$；警察与对应的物品的连边永远不被割，表示要么放弃物品要么贿赂警察。\r\n\r\n$n,m\\leq 10^5$，显然跑不了网络流。考虑模拟最大流。\r\n\r\n首先要描述警察 $j$ 与物品 $i$ 的关系。要满足：\r\n\r\n$$\\mid \\frac{x_i-x_j}{y_i-y_j} \\mid \\leq \\frac{w}{h}$$\r\n\r\n$$x_j\\times h-y_j\\times w\\leq x_i\\times h-y_i\\times w$$\r\n\r\n$$x_j\\times h+y_j\\times w\\geq x_i\\times h+y_i\\times w$$\r\n\r\n令 $x=x\\times h+y\\times w,y=x\\times h-y\\times w$。得到 $x_i\\leq x_j,y_i\\geq y_j$ ，能很好描述。\r\n\r\n将物品和警察放在一起从左到右，从上到下考虑，自然满足 $x_i\\leq x_j$。贪心，一个警察 $j$ 的流优先从 $y_i\\geq y_j$ 且 $y_i$ 最小处流过来，因为更大的 $y_i$ 能满足更多人限制。用 set 储存物品，警察处 lower_bound 查找。set 的 erase 函数会返回删去的值的下一个的迭代器。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,w,h,ans;\r\nstruct nd{\r\n\tint x,y,v,op;\r\n}a[maxn];\r\nbool cmp(nd u,nd v){\r\n\tif(u.x!=v.x)return u.x<v.x;\r\n\treturn u.y>v.y;\r\n}\r\nset<pii> s;\r\nvoid work(){\r\n\tn=read();m=read();w=read();h=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint u=read(),v=read(),val=read();\r\n\t\ta[i]={u*h+v*w,u*h-v*w,val,1};ans+=a[i].v;\r\n\t}\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read(),val=read();\r\n\t\ta[i+n]={u*h+v*w,u*h-v*w,val,0};\r\n\t}\r\n\tsort(a+1,a+n+m+1,cmp);\r\n\tfor(int i=1;i<=n+m;i++){\r\n\t\tif(a[i].op)s.insert({a[i].y,a[i].v});\r\n\t\telse{\r\n\t\t\tauto it=s.lower_bound({a[i].y,0});\r\n\t\t\twhile(a[i].v){\r\n\t\t\t\tif(it==s.end())break;\r\n\t\t\t\tpii p=*it;it=s.erase(it);\r\n\t\t\t\tint d=min(a[i].v,p.second);\r\n\t\t\t\ta[i].v-=d;p.second-=d;ans-=d;\r\n\t\t\t\tif(p.second)s.insert(p);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "P5996 题解",
        "date": "2023-12-31 17:21:37",
        "tags": [
          "题解",
          "网络流"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p5996-ti-jie"
    },
    {
      "content": "[P5344](https://www.luogu.com.cn/problem/P5344)\r\n\r\n### 思路\r\n\r\n把图建出来跑 dij 即可。\r\n\r\n对于建图，可以想到对每个操作 $1$ 建一个虚点，从 $u1$ 到 $v1$ 向虚点连代价为 $w$ 的边，从虚点向 $u2$ 到 $v2$ 连代价为 $0$ 的边。此时图中有 $n\\times m$ 条边，无法接受，考虑优化建图。\r\n\r\n按照线段树优化建图的思路，可以想到先树剖建线段树，$in$ 表示从上往下，$out$ 表示从下往上。把每条边变为多条链在线段树上分别建边。每条边有 $\\log n$ 条链，每条链建 $\\log n$ 条边，最短路 $O(m\\log n)$，总复杂度 $O(m\\log^3 n)$。\r\n\r\n可以发现，通过树剖把树结构变为数组再优化并非最好，因为放弃了树形结构多了两个 $\\log n$。可以树上倍增优化。\r\n\r\n对于每个点 $u$ 建 $\\log n$ 个虚点，记为 $in_{u,i}$ 和 $out_{u,i}$，表示从 $u$ 到往上 $2^i$ 级祖先的链， $in$ 和 $out$ 同理线段树优化建图，表示从上往下或从下往上。\r\n\r\n和 st 表的查询一样，$u$ 到 $u$ 的祖先 $v$ 的路径可以表示为 $u$ 的第 $k$ 个虚点和使 $2^k$ 级祖先为 $v$ 的某个 $u$ 的祖先的第 $k$ 个虚点。把 $u1$ 到 $v1$ 的路径向虚点连边，等同于把 $u1$ 到 lca 和 $v1$ 到 lca 分别向虚点连边。\r\n\r\n每个点 $u$ 有 $\\log n$ 个虚点，倍增时每个虚点向上一级连 $2$ 条边。每个操作有 $1$ 个虚点，分为 $4$ 部分，每部分向虚点连 $2$ 条边。这样一共有 $n\\log n+m$ 个点和 $n\\log n+m$ 条边。总复杂度 $O(m\\log n)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,s,num;\r\nint f[maxn];\r\nint fd(int x){\r\n\tif(x==f[x])return x;\r\n\treturn f[x]=fd(f[x]);\r\n}\r\nstruct ask{\r\n\tint u,v,uu,vv,w;\r\n}a[maxm];\r\nint cnt;\r\nint head[maxm*3],tot;\r\nstruct nd{\r\n\tint nxt,to,w;\r\n}e[maxm*12];\r\nvoid add(int u,int v,int w){\r\n\te[++tot]={head[u],v,w};\r\n\thead[u]=tot;\r\n}\r\nint dep[maxn],to[maxn][20];\r\nint in[maxn][20],out[maxn][20];\r\nvoid dfs(int u,int fa){\r\n\tto[u][0]=fa;in[u][0]=out[u][0]=u;\r\n\tfor(int i=1;(1<<i)<dep[u];i++){\r\n\t\tto[u][i]=to[to[u][i-1]][i-1];\r\n\t}\r\n\tfor(int i=1;(1<<i)<=dep[u];i++){\r\n\t\tin[u][i]=++num;out[u][i]=++num;\r\n\t\tadd(out[u][i-1],out[u][i],0);\r\n\t\tadd(in[u][i],in[u][i-1],0);\r\n\t\tadd(out[to[u][i-1]][i-1],out[u][i],0);\r\n\t\tadd(in[u][i],in[to[u][i-1]][i-1],0);\r\n\t}\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v!=fa&&v<=n){\r\n\t\t\tdep[v]=dep[u]+1;\r\n\t\t\tdfs(v,u);\r\n\t\t}\r\n\t}\r\n}\r\nint lg[maxn];\r\nint lca(int u,int v){\r\n\tif(u==v)return u;\r\n\tif(dep[u]<dep[v])swap(u,v);\r\n\tfor(int i=lg[dep[u]];i>=0;i--)if(dep[to[u][i]]>=dep[v])u=to[u][i];\r\n\tif(u==v)return u;\r\n\tfor(int i=lg[dep[u]];i>=0;i--)if(to[u][i]!=to[v][i])u=to[u][i],v=to[v][i];\r\n\treturn to[u][0];\r\n}\r\nint kfa(int u,int k){\r\n\tint j=0;\r\n\twhile(k){\r\n\t\tif(k&1)u=to[u][j];    \r\n\t\tk>>=1;\r\n\t\t++j;\r\n\t}\r\n\treturn u;\r\n}\r\nvoid build(int u,int v,int w,int t){\r\n\tint k=lg[dep[u]-dep[v]+1];\r\n\tif(!t)add(out[u][k],num,w);\r\n\telse add(num,in[u][k],w);\r\n\tu=kfa(u,dep[u]-dep[v]+1-(1<<k));\r\n\tif(!t)add(out[u][k],num,w);\r\n\telse add(num,in[u][k],w);\r\n}\r\nint dis[maxm*3];\r\nbool vis[maxm*3];\r\nstruct Dis{\r\n\tint dis,id;\r\n\tbool operator <(const Dis&tmp)const{return dis>tmp.dis;}\r\n};\r\npriority_queue<Dis> q;\r\n\r\nint T;\r\nsigned main(){\r\n\t//\tfreopen(\".in\",\"r\",stdin);\r\n\t//\tfreopen(\".out\",\"w\",stdout);\r\n\t\r\n\tn=read();m=read();s=read();\r\n\tlg[1]=0;for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;\r\n\tfor(int i=1;i<=n;i++)f[i]=i;\r\n\twhile(m--){\r\n\t\tint opt,u,v,w,uu,vv;opt=read();\r\n\t\tif(opt==1){\r\n\t\t\tu=read();v=read();uu=read();vv=read();w=read();\r\n\t\t\tif(fd(u)!=fd(v)||fd(uu)!=fd(vv))continue;\r\n\t\t\ta[++cnt]={u,v,uu,vv,w};\r\n\t\t}\r\n\t\telse{\r\n\t\t\tu=read();v=read();w=read();\r\n\t\t\tif(fd(u)==fd(v))continue;\r\n\t\t\tadd(u,v,w);add(v,u,w);\r\n\t\t\tf[fd(u)]=fd(v);\r\n\t\t}\r\n\t}\r\n\tnum=n;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(!dep[i]){\r\n\t\t\tdep[i]=1;\r\n\t\t\tdfs(i,0);\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=cnt;i++){\r\n\t\tnum++;\r\n\t\tint tp1=lca(a[i].u,a[i].v),tp2=lca(a[i].uu,a[i].vv);\r\n\t\tbuild(a[i].u,tp1,0,0);build(a[i].v,tp1,0,0);\r\n\t\tbuild(a[i].uu,tp2,a[i].w,1);build(a[i].vv,tp2,a[i].w,1);\r\n\t}\r\n\tmemset(dis,0x3f,sizeof(dis));\r\n\tdis[s]=0;q.push({0,s});\r\n\twhile(!q.empty()){\r\n\t\tint u=q.top().id;q.pop();\r\n\t\tif(vis[u])continue;\r\n\t\tvis[u]=1;\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(dis[v]>dis[u]+e[i].w){\r\n\t\t\t\tdis[v]=dis[u]+e[i].w;\r\n\t\t\t\tq.push({dis[v],v});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(dis[i]>=0x3f3f3f3f)printf(\"-1 \");\r\n\t\telse printf(\"%d \",dis[i]);\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "P5344 题解",
        "date": "2023-12-31 17:18:55",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p5344-ti-jie"
    },
    {
      "content": "[P4778](https://www.luogu.com.cn/problem/P4778)\r\n\r\n240229 模拟赛 T1\r\n\r\n### 题意\r\n\r\n求一个排列每次交换两个位置变成 $1\\dots n$ 的方案数。\r\n\r\n### 思路\r\n\r\n分开考虑每个环。设 $f_i$ 表示大小为 $i$ 的环的答案。每交换一次就将一个环分为两个环。枚举分成的较小的一边是什么，乘两边单独的方案数，两边独立乘一个组合数，选两个一定距离的点乘 $i$ 或 $\\frac{i}{2}$。\r\n\r\n有 $O(n^2)$ 递推式：\r\n\r\n$$f_i=\\sum_{j=1}^{\\frac{i}{2}}f_j\\times f_{i-j}\\times \\binom{i-2}{j-1}\\times (\\frac{i}{2}\\times [j=\\frac{i}{2}]+i\\times [j\\ne \\frac{i}{2}])$$\r\n\r\n打表发现 $f_i=i^{i-2}$。\r\n\r\n大概是钦定 $1$ 为根，枚举 $2$ 的子树大小，乘两边独立的方案数，乘分配编号的组合数。如果 $1$ 和 $2$ 分别有 $\\frac{i}{2}$ 的子树，那就取消 $1$ 和 $2$ 间的区别。所以等价于有标号无根树计数。",
      "data": {
        "title": "P4778 题解",
        "date": "2023-12-31 17:18:02",
        "tags": [
          "题解",
          "图论",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "p4778-ti-jie"
    },
    {
      "content": "[joisc2018_l](https://www.luogu.com.cn/problem/AT_joisc2018_l)\r\n\r\n### 思路\r\n\r\n$a_i$ 和 $a_{i+1}$ 之间取最短路最优。但因为有不能折返的限制，所以希望对每对 $u,v$ 找到 $k$ 条最短路使得任意断掉 $u$ 的一条出边和 $v$ 的一条入边，$u$ 到 $v$ 的最短路还在 $k$ 条中。\r\n\r\n先跳过这一部分。如果可以在可行复杂度内预处理出结构体 $mn_{u,v,i}$ 表示 $u$ 到 $v$ 的第 $i$ 条最短路的距离，最短路中 $u$ 去向的点和去向 $v$ 的点，怎么做。\r\n\r\n考虑线段树维护每个间隔。记录 $v_{i,j}$ 表示间隔的区间 $[l,r]$ 中，$a_l$ 到 $a_{l+1}$ 取第 $i$ 条最短路，$a_r$ 到 $a_{r+1}$ 取第 $j$ 条最短路的区间最短路。合并时枚举左边区间的右端点状态和右边区间的左端点状态，复杂度 $O(k^4l\\log l)$。$l\\le 10^5$，所以希望 $k$ 尽量小。\r\n\r\n可以构造 $k=4$ 条最短路。\r\n\r\n- $u$ 到 $v$ 的最短路：$u,uu,\\dots,vv,v$。\r\n\r\n- 不经过 $uu,vv$ 的最短路：$u,uu',\\dots,vv',v$。\r\n\r\n- 不经过 $uu$ 且不同于 $2$ 的最短路：$u,u3/uu',\\dots,v3,v$。\r\n\r\n- 不经过 $vv$ 且不同于 $2$ 的最短路：$u,u4,\\dots,v4/vv',v$。\r\n\r\n现在要求两点间不过第三点的最短路。厉害的是，可以把无向边拆除两条有向边当成点跑的最短路。\r\n\r\n从每条边 $s$ 开始跑最短路，有 $m$ 个点，$\\sum {deg_u}^2=m^2$ 条边，复杂度 $O(m^3\\log m)$。但有大量的边只会造成一次入队。设当前做到边 $u$，$u$ 指向点 $uu$，如果这是第一次到达点 $uu$，那么枚举除了边 $u$ 的反向边以外的起点为 $uu$ 的边转移，记录 $lst_{uu}=u$；如果这是第二次到达点 $uu$，说明边形成一个环，可以转移到 $lst_{uu}$ 的反向边，并且转移到其他所有边都不会更优；如果大于 $2$ 次，就不会有任何转移。这样做入队次数为 $O(\\sum deg_u)=O(m)$，单次复杂度 $O(m\\log m)$。\r\n\r\n然后枚举点 $u$ 和出边 $i$，点 $v$ 和出边 $j$，找到 $4$ 条最短路。复杂度 $O(\\sum deg_u\\sum deg_v)=O(m^2)$。\r\n\r\n总复杂度 $O(m^2\\log m+k^4l\\log l)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,t,l;\r\nint head[maxn],tot=1;\r\nstruct nd{\r\n\tint nxt,to,fr;ll w;\r\n}e[maxn];\r\nvoid add(int u,int v,ll w){e[++tot]={head[u],v,u,w};head[u]=tot;}\r\nll dis[maxn][maxn];\r\nstruct Dis{\r\n\tint id;ll dis;\r\n\tbool operator <(const Dis&tmp)const{return dis>tmp.dis;}\r\n};\r\npriority_queue<Dis> q;\r\nbool vis[maxn];int bk[maxn];\r\nvoid dij(int s){\r\n\tfor(int i=2;i<=tot;i++)dis[s][i]=inf;\r\n\tmemset(vis,0,sizeof(vis));memset(bk,0,sizeof(bk));\r\n\tdis[s][s]=e[s].w;q.push({s,dis[s][s]});\r\n\t// cout<<s<<\"\\n\";\r\n\twhile(!q.empty()){\r\n\t\tint u=q.top().id;q.pop();\r\n\t\tif(vis[u])continue;vis[u]=1;\r\n\t\t// cout<<u<<\" \"<<dis[s][u]<<\"\\n\";\r\n\t\tif(bk[e[u].to]){\r\n\t\t\tif(dis[s][bk[e[u].to]]>dis[s][u]+e[bk[e[u].to]].w){\r\n\t\t\t\tdis[s][bk[e[u].to]]=dis[s][u]+e[bk[e[u].to]].w;\r\n\t\t\t\tq.push({bk[e[u].to],dis[s][bk[e[u].to]]});\r\n\t\t\t}\r\n\t\t\tbk[e[u].to]=-1;\r\n\t\t}\r\n\t\tif(!bk[e[u].to]){\r\n\t\t\tfor(int i=head[e[u].to];i;i=e[i].nxt){\r\n\t\t\t\tint v=e[i].to;if(!bk[e[u].to]&&i==(u^1))continue;\r\n\t\t\t\t// cout<<v<<\"\\n\";\r\n\t\t\t\tif(dis[s][i]>dis[s][u]+e[i].w){\r\n\t\t\t\t\tdis[s][i]=dis[s][u]+e[i].w;\r\n\t\t\t\t\tq.push({i,dis[s][i]});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbk[e[u].to]=u^1;\r\n\t\t}\r\n\t}\r\n}\r\nint a[maxm];\r\nstruct path{\r\n\tll dis;int x,y;\r\n}mn[maxn][maxn][4];\r\npath Min(path u,path v){if(u.dis<v.dis)return u;return v;}\r\nstruct mat{\r\n\tll v[4][4];\r\n\tmat(){memset(v,0x3f,sizeof(v));}\r\n}tree[maxm<<2];\r\nmat merge(mat u,mat v,int mid){\r\n\tmat res;\r\n\tfor(int i=0;i<4;i++){\r\n\t\tfor(int j=0;j<4;j++){\r\n\t\t\tres.v[i][j]=inf;\r\n\t\t\tfor(int k=0;k<4;k++){\r\n\t\t\t\tfor(int l=0;l<4;l++){\r\n\t\t\t\t\tif(mn[a[mid]][a[mid+1]][k].y!=mn[a[mid+1]][a[mid+2]][l].x)res.v[i][j]=min(res.v[i][j],u.v[i][k]+v.v[l][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn res;\r\n}\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\nvoid build(int nd,int l,int r){\r\n\tif(l==r){\r\n\t\tfor(int i=0;i<4;i++)tree[nd].v[i][i]=mn[a[l]][a[l+1]][i].dis;\r\n\t\treturn ;\r\n\t}\r\n\tbuild(ls,l,mid),build(rs,mid+1,r);\r\n\ttree[nd]=merge(tree[ls],tree[rs],mid);\r\n}\r\nvoid updata(int nd,int l,int r,int p){\r\n\tif(l==r){\r\n\t\tfor(int i=0;i<4;i++)tree[nd].v[i][i]=mn[a[l]][a[l+1]][i].dis;\r\n\t\treturn ;\r\n\t}\r\n\tif(p<=mid)updata(ls,l,mid,p);\r\n\telse updata(rs,mid+1,r,p);\r\n\ttree[nd]=merge(tree[ls],tree[rs],mid);\r\n}\r\nvoid work(){\r\n\tn=read();m=read();t=read();l=read();\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read(),w=read();\r\n\t\tadd(u,v,w),add(v,u,w);\r\n\t}\r\n\tfor(int i=1;i<=l;i++)a[i]=read();\r\n\tfor(int i=2;i<=tot;i++)dij(i);\r\n\tfor(int u=1;u<=n;u++){\r\n\t\tfor(int v=1;v<=n;v++)if(u!=v){\r\n\t\t\tfor(int i=0;i<4;i++)mn[u][v][i]={inf,0,0};\r\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\t\tint uu=e[i].to;\r\n\t\t\t\tfor(int j=head[v];j;j=e[j].nxt){\r\n\t\t\t\t\tint vv=e[j].to;\r\n\t\t\t\t\tmn[u][v][0]=Min(mn[u][v][0],{dis[i][j^1],uu,vv});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\t\tint uu=e[i].to;\r\n\t\t\t\tfor(int j=head[v];j;j=e[j].nxt){\r\n\t\t\t\t\tint vv=e[j].to;\r\n\t\t\t\t\tif(uu!=mn[u][v][0].x&&vv!=mn[u][v][0].y)mn[u][v][1]=Min(mn[u][v][1],{dis[i][j^1],uu,vv});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\t\tint uu=e[i].to;\r\n\t\t\t\tfor(int j=head[v];j;j=e[j].nxt){\r\n\t\t\t\t\tint vv=e[j].to;\r\n\t\t\t\t\tif(uu!=mn[u][v][0].x&&vv!=mn[u][v][1].y)mn[u][v][2]=Min(mn[u][v][2],{dis[i][j^1],uu,vv});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\t\tint uu=e[i].to;\r\n\t\t\t\tfor(int j=head[v];j;j=e[j].nxt){\r\n\t\t\t\t\tint vv=e[j].to;\r\n\t\t\t\t\tif(uu!=mn[u][v][1].x&&vv!=mn[u][v][0].y)mn[u][v][3]=Min(mn[u][v][3],{dis[i][j^1],uu,vv});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tbuild(1,1,l-1);\r\n\twhile(t--){\r\n\t\tint u=read(),v=read();a[u]=v;\r\n\t\tif(u>1)updata(1,1,l-1,u-1);\r\n\t\tupdata(1,1,l-1,u);\r\n\t\tll ans=inf;for(int i=0;i<4;i++)for(int j=0;j<4;j++)ans=min(ans,tree[1].v[i][j]);\r\n\t\tif(ans>=inf)ans=-1;\r\n\t\tprintf(\"%lld\\n\",ans);\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "AT_joisc2018_l 题解",
        "date": "2023-12-31 17:11:27",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "at_joisc2018_l-ti-jie"
    },
    {
      "content": "[CF1854D](https://www.luogu.com.cn/problem/CF1854D)\r\n\r\n### 思路\r\n\r\n题目等价于求 $1$ 的联通块大小。\r\n\r\n可以 $\\log n=9$ 次二分出一个点走 $k$ 步到哪里。有两种用法：走 $n+1$ 步得到环上的某个点和走 $1$ 步得到该点下一个点。\r\n\r\n如果找到知道 $1$ 联通块的环是哪些点，就可以对每个不知道的点询问 $n+1$ 得知答案。先从 $1$ 二分 $n+1$ 找到一个环上点，再一直走知道走完一个环。步数与环长 $len$ 有关，$9\\times len+500-len\\le 4500$。\r\n\r\n先找出一个点在 $1$ 联通块的环上，在环上二分 $124$ 次 $1$ 步找到环上连续的 $125$ 个点。对剩下 $375$ 个点找出 $125$ 步能到这 $125$ 个点之一的点。这时至少已知环上连续的 $250$ 个点，有一半的环已知，其他的点走 $n+1$ 步或 $n+1+250$ 步如果在联通块内则一定能到这一半的环。总步数 $9\\times 125+375+2\\times 250=2000$。如果环长不到 $250$，就直接 $500-len$ 步做完。\r\n\r\n这么做的关键是环上连续点长度可以倍增，$500-len$ 步就可以把 $len$ 长的环倍增到 $len\\times 2$。如果一开始二分少一些连续长度可以步数更小。\r\n\r\n### code\r\n\r\n```cpp\r\nint n;\r\nint id[maxn],tot;bool vis[maxn];\r\nvector<int> a,b;\r\nbool ask(int u,int len){\r\n\tprintf(\"? %lld %lld %lld \",u,len,tot);\r\n\tfor(int i=1;i<=tot;i++)printf(\"%lld \",id[i]);\r\n\tprintf(\"\\n\");fflush(stdout);\r\n\treturn read();\r\n}\r\nbool get(int u,int len,vector<int> a){\r\n\tprintf(\"? %lld %lld %lld \",u,len,(int)a.size());\r\n\tfor(int i:a)printf(\"%lld \",i);\r\n\tprintf(\"\\n\");fflush(stdout);\r\n\treturn read();\r\n}\r\nint find(int u,int len){\r\n\ta.clear();\r\n\tfor(int i=1;i<=n;i++)if(!vis[i]||i==id[1])a.push_back(i);\r\n\twhile(a.size()>1){\r\n\t\tint num=a.size()>>1;b.clear();\r\n\t\twhile(num--)b.push_back(a.back()),a.pop_back();\r\n\t\tif(!get(u,len,a))swap(a,b);\r\n\t}\r\n\treturn a.front();\r\n}\r\nvoid prinf(){\r\n\tsort(id+1,id+tot+1);\r\n\tprintf(\"! %lld \",tot);\r\n\tfor(int i=1;i<=tot;i++)printf(\"%lld \",id[i]);\r\n\tprintf(\"\\n\");fflush(stdout);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\ta.clear(),b.clear();\r\n\tid[++tot]=find(1,n+1);vis[id[tot]]=1;\r\n\tfor(int t=2;t<=125;t++){\r\n\t\tint p=find(id[tot],1);\r\n\t\tif(p==id[1])break;\r\n\t\tid[++tot]=p,vis[id[tot]]=1;\r\n\t}\r\n\tif(tot<125){\r\n\t\tfor(int i=1;i<=n;i++)if(!vis[i]){\r\n\t\t\tif(ask(i,n+1)){\r\n\t\t\t\tid[++tot]=i;vis[i]=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprinf();return ;\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\r\n\t\tif(ask(i,125)){\r\n\t\t\tid[++tot]=i;vis[i]=1;\r\n\t\t}\r\n\t}\r\n\tif(tot<250){\r\n\t\tfor(int i=1;i<=n;i++)if(!vis[i]){\r\n\t\t\tif(ask(i,n+1)){\r\n\t\t\t\tid[++tot]=i;vis[i]=1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprinf();return ;\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\r\n\t\tif(ask(i,n+1)||ask(i,n+1+250)){\r\n\t\t\tid[++tot]=i;vis[i]=1;\r\n\t\t}\r\n\t}\r\n\tprinf();\r\n}\r\n```",
      "data": {
        "title": "CF1854D 题解",
        "date": "2023-12-31 17:10:30",
        "tags": [
          "题解",
          "非传统题"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1854d-ti-jie"
    },
    {
      "content": "[CF1823F](https://www.luogu.com.cn/problem/CF1823F)\r\n\r\n### 思路\r\n\r\n设 $f_u$ 表示经过 $u$ 的期望次数。$f_u$ 的值是所有与 $u$ 有边的点 $v$ 的答案 $f_v$ 除以走向 $u$ 的概率 $\\frac{1}{d_v}$。\r\n\r\n$$f_u=[u=s]+\\sum_{(u,v)\\in E,v\\neq t}\\frac{f_v}{d_v}$$\r\n\r\n$$f_t=1$$\r\n\r\n问题是 $f_u$ 的值可以从 $fa$ 得来，转移成环。直接高斯消元 $O(n^3)$，但是没有用到树的性质。成环是因为有来自父亲的转移，但根节点没有。设 $f_u=a_u\\times f_{fa}+b_u$，带入 dp 方程。\r\n\r\n$$f_u=[u=s]+\\frac{f_{fa}}{d_{fa}}+\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{f_v}{d_v}$$\r\n\r\n$$f_u=[u=s]+\\frac{f_{fa}}{d_{fa}}+\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{a_v\\times f_u+b_v}{d_v}$$\r\n\r\n$$(1-\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{a_v}{d_v})\\times f_u=[u=s]+\\frac{f_{fa}}{d_{fa}}+\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{b_v}{d_v}$$\r\n\r\n$$f_u=\\frac{\\frac{1}{d_{fa}}}{(1-\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{a_v}{d_v})}\\times f_{fa}+\\frac{[u=s]+\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{b_v}{d_v}}{(1-\\sum_{(u,v)\\in E,v\\neq t,v\\neq fa}\\frac{a_v}{d_v}}$$\r\n\r\n对比系数，只与 $u$ 的儿子有关，解出 $a_u,b_u$。再从跟从上往下推一遍。注意到 $v\\neq t$ 很烦，直接把 $t$ 设为跟。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,s,t;\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\ninline int ksm(int a,int b=mod-2){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%mod;\r\n\t\ta=a*a%mod;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint d[maxn],f[maxn],a[maxn],b[maxn];\r\nvoid dfs(int u,int fa){\r\n\tint val=1;b[u]=(u==s);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);\r\n\t\tval+=mod-a[v]*ksm(d[v])%mod;\r\n\t\tb[u]+=b[v]*ksm(d[v])%mod;\r\n\t}\r\n\tval%=mod;b[u]%=mod;\r\n\ta[u]=ksm(val*d[fa]%mod);if(fa==t)a[u]=0;\r\n\tb[u]=ksm(val)*b[u]%mod;\r\n}\r\nvoid dfs1(int u,int fa){\r\n\tf[u]=(a[u]*f[fa]+b[u])%mod;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs1(v,u);\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();s=read();t=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t\t++d[u],++d[v];\r\n\t}\r\n\tdfs(t,0);\r\n\tf[t]=1;dfs1(t,0);\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld \",f[i]);\r\n}\r\n```",
      "data": {
        "title": "CF1823F 题解",
        "date": "2023-12-31 17:09:39",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1823f-ti-jie"
    },
    {
      "content": "[CF1286E](https://www.luogu.com.cn/problem/CF1286E)\r\n\r\n### 思路\r\n\r\n维护当前 border 集合和答案。从 $i-1$ 的合法集合过来。对于集合中的区间 $[1,x]$，如果 $s_{x+1}\\ne s_i$ 则删去，否则拓展为 $[1,x+1]$。如果 $s_i=s_1$ 则加入 $[1,1]$。一共最多 $O(n)$ 个次加入，所以最多 $O(n)$ 次删除。\r\n\r\n考虑删除那些。$i-1$ 的合法位置是从 $i$ 到 $1$ 跳 nxt 到的位置。对于每个节点每种颜色找出在 nxt 树上，$s_{x+1}=s_{i+1}$ 的最近祖先，每次向上跳到那里。显然链上 $s_{x+1}=s_i$ 的点可以保留，其他都要删掉。把除了颜色 $s_i$ 的一路跳上去删掉。末尾添数维护 st 表最小值计算删除的代价。每个 border 删一次，复杂度 $O(n\\log n)$。\r\n\r\n对于合法的那些，新加入 $w_i$，权值要对 $w_i$ 取 min。用 map 维护每个权值的个数，将大于 $a_i$ 的数量加进 $a_i$ 并删除，每个加入的权值被操作一次就变成另一个权值的数量的一部分，复杂度 $O(n\\log n)$。\r\n\r\n爆 long long，维护 $ans=ans1\\times bas+ans2$。略卡空间。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn];\r\nint nxt[maxn],to[maxn][26];\r\nll ans1,ans2,ans26,ansmod;\r\nchar s[maxn];\r\nint st[20][maxn];\r\nvoid add(int p){\r\n\tst[0][p]=a[p];\r\n\tfor(int i=1;(1<<i)<=p;i++)st[i][p]=min(st[i-1][p],st[i-1][p-(1<<i-1)]);\r\n}\r\nint que(int l,int r){\r\n\tint k=log2(r-l+1);\r\n\treturn min(st[k][r],st[k][l+(1<<k)-1]);\r\n}\r\nvoid inc(ll x){\r\n\t(ans26+=x)%=26,(ansmod+=x)&=((1<<30)-1);\r\n\tans2+=x;ans1+=ans2/inf,ans2%=inf;\r\n}\r\ninline void write(__int128 x){static char buf[40];static int len=-1;if(x<0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len>=0)putchar(buf[len--]+48);}\r\nvoid prinf(){\r\n\tif(!ans1)printf(\"%lld\\n\",ans2);\r\n\telse{\r\n\t\t__int128 val=(__int128)ans1*inf+ans2;\r\n\t\twrite(val);puts(\"\");\r\n\t}\r\n}\r\nll res;\r\nmap<int,int> mp;\r\nvoid ins(int u,int v){mp[u]+=v,res+=1ll*u*v;}\r\nvoid mn(int x){\r\n\tauto it=mp.upper_bound(x);int num=0;\r\n\twhile(it!=mp.end()){\r\n\t\tnum+=(*it).second;res-=1ll*(*it).first*(*it).second;\r\n\t\tit=mp.erase(it);\r\n\t}\r\n\tins(x,num);\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1,j=0;i<=n;i++){\r\n\t\tcin>>s[i];s[i]=(s[i]-'a'+ans26)%26+'a';\r\n\t\ta[i]=read()^ansmod;\r\n\t\tadd(i);inc(que(1,i));\r\n\t\tif(i==1){prinf();continue;}\r\n\t\twhile(j&&s[i]!=s[j+1])j=nxt[j];\r\n\t\tif(s[i]==s[j+1])j++;\r\n\t\tnxt[i]=j;\r\n\t\tif(s[1]==s[i])ins(a[i],1);\r\n\t\tfor(int k=0;k<26;k++)to[i][k]=to[nxt[i]][k];\r\n\t\tto[i][s[nxt[i]+1]-'a']=nxt[i];\r\n\t\tfor(int k=0;k<26;k++)if(s[i]-'a'!=k){\r\n\t\t\tint x=to[i-1][k];\r\n\t\t\twhile(x){\r\n\t\t\t\tins(que(i-1-x+1,i-1),-1);\r\n\t\t\t\tx=to[x][k];\r\n\t\t\t}\r\n\t\t}\r\n\t\tmn(a[i]);inc(res);prinf();\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "CF1286E 题解",
        "date": "2023-12-31 16:58:20",
        "tags": [
          "题解",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1286e-ti-jie"
    },
    {
      "content": "[CF1237H](https://www.luogu.com.cn/problem/CF1237H)\r\n\r\n### 思路\r\n\r\n构造。\r\n\r\n因为是对偶数位操作，有一个巧妙的转化：将每两位和为一位。令 $00$ 为 $0$， $01$ 为 $1$， $10$ 为 $2$， $11$ 为 $3$。其中 $1$ 翻转得到 $2$，$2$ 翻转得到 $1$。\r\n\r\n如果有解，则 $suma0=sumb0,suma3=sumb3,suma1+suma2=sumb1+sumb2$。\r\n\r\n考虑从一个大问题转换为小问题。$N+1=2\\times n+1$，猜测答案是用两个操作实现 $a_i=b_i$，再有一个灵活的额外操作。可以一个一个处理。\r\n\r\n要找到一种方法使得在不改变其他结构的同时移动 $a_i$。观察发现，我们可以实现两步将 $a_i$ 换到 $a_1$，$a_{1...{i-1}}$ 不改变结构的换到 $a_{2...i}$。具体是操作 $2\\times i-2$ 和 $2\\times i$。\r\n\r\n所以从后向前，设当前维护到 $a_i$，则 $a_{1...{i-1}}$ 分别等于 $b_{{n-i+2}...n}$。找到 $a_j=b_{n-i+1}$ 且 $i\\leq j$，执行上面操作即可。共 $N$ 次操作。\r\n\r\n现在问题是，$suma1\\neq sumb1$ ，我们要反转一次使 $suma1=sumb1$。\r\n\r\n我们可以找到 $a$ 中某个前缀，使得 $suma1-suma1_i+suma2_i=sumb1$，翻转这个前缀。但也可能找不到，这时一定有 $b$ 的某个前缀，使得 $sumb1-sumb1_i+sumb2_i=suma1$。这时翻转 $b$ 的这个前缀得到 $b'$，把 $a$ 做成 $b'$ 再翻转这个前缀。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn],b[maxn];\r\nchar s[maxn],t[maxn];\r\nint sum[4];\r\nvector<int> ans;\r\nint aa[maxn],bb[maxn],nn;\r\nbool check(){\r\n\tif(ans.size()>nn+1)return 0;\r\n\tfor(int i:ans){\r\n\t\tfor(int j=1;j<=i/2;j++)swap(aa[j],aa[i-j+1]);\r\n//\t\tfor(int j=1;j<=nn;j++)cout<<aa[j];cout<<\"\\n\";\r\n\t}\r\n//\tfor(int i=1;i<=nn;i++)cout<<aa[i];cout<<\"\\n\";\r\n\tfor(int i=1;i<=nn;i++)if(aa[i]!=bb[i])return 0;\r\n\treturn 1;\r\n}\r\nvoid work(){\r\n\tscanf(\"%s%s\",s+1,t+1);n=strlen(s+1);\r\n\t\r\n\tnn=n;\r\n\tfor(int i=1;i<=n;i++)aa[i]=s[i]-'0',bb[i]=t[i]-'0';\r\n\t\r\n\tfor(int i=2;i<=n;i+=2)a[i/2]=(s[i-1]-'0')*2+s[i]-'0';\r\n\tfor(int i=2;i<=n;i+=2)b[i/2]=(t[i-1]-'0')*2+t[i]-'0';\r\n\tn>>=1;\r\n\tfor(int i=1;i<=n;i++)if(b[i]==1||b[i]==2)b[i]=3-b[i];\r\n\tsum[0]=sum[1]=sum[2]=sum[3]=0;\r\n\tfor(int i=1;i<=n;i++)sum[a[i]]++;\r\n\tfor(int i=1;i<=n;i++)sum[b[i]]--;\r\n\tif(sum[0]||sum[3]||sum[1]+sum[2]){printf(\"-1\\n\");return ;}\r\n\tans.clear();int pos=0;\r\n\tbool fl=(sum[1]==0);\r\n\tfor(int i=1;i<=n&&!fl;i++){\r\n\t\tsum[1]-=(a[i]==1);sum[1]+=(a[i]==2);\r\n\t\tif(!sum[1]){\r\n\t\t\tans.push_back(2*i);\r\n\t\t\tfor(int j=1;j<=i/2;j++)swap(a[j],a[i-j+1]);\r\n\t\t\tfor(int j=1;j<=i;j++)if(a[j]==1||a[j]==2)a[j]=3-a[j];\r\n\t\t\tfl=1;\r\n\t\t}\r\n\t}\r\n\tsum[1]=-sum[2];\r\n\tfor(int i=1;i<=n&&!fl;i++){\r\n\t\tsum[1]+=(b[i]==1);sum[1]-=(b[i]==2);\r\n\t\tif(!sum[1]){\r\n\t\t\tpos=2*i;\r\n\t\t\tfor(int j=1;j<=i/2;j++)swap(b[j],b[i-j+1]);\r\n\t\t\tfor(int j=1;j<=i;j++)if(b[j]==1||b[j]==2)b[j]=3-b[j];\r\n\t\t\tfl=1;\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=i;j<=n;j++)if(a[j]==b[n-i+1]){\r\n\t\t\tif(j*2-2!=0)ans.push_back(j*2-2);\r\n\t\t\tans.push_back(j*2);\r\n\t\t\tfor(int k=j-1;k;k--)a[k+1]=a[k];\r\n\t\t\ta[1]=b[n-i+1];\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif(pos)ans.push_back(pos);\r\n\tprintf(\"%lld\\n\",(int)ans.size());\r\n\tfor(int i:ans)if(i)printf(\"%lld \",i);\r\n\tprintf(\"\\n\");\r\n//\tcout<<check()<<\"\\n\";\r\n}\r\n```",
      "data": {
        "title": "CF1237H 题解",
        "date": "2023-12-31 16:57:45",
        "tags": [
          "题解",
          "构造"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1237h-ti-jie"
    },
    {
      "content": "[CF1218A](https://www.luogu.com.cn/problem/CF1218A)\r\n\r\n模拟赛一车贪心水过去了除了我。\r\n\r\n### 思路\r\n\r\n是基环树。先考虑树。如果从一个点开始，定为根，$ans=\\sum siz_u$。换根 dp 即可。\r\n\r\n把环找出来，考虑在环上点 $u$ 的子树中开始染色的答案。染色的方式是大致是从子树的叶子开始向上。对 $u$ 的每个非环上儿子做树的 dp。记 $g_u$ 表示从环上进入子树向下染色的答案，$dp_u$ 表示换根的、从子树内任意节点开始染色的方案。从环上 $u$ 的非环上儿子 $v$ 的子树开始的答案是 $dp_v+\\sum_{v'\\neq v} g_{v'}$，$ans_u=\\sum g_v+\\max (dp_v-g_v)$。染完环上 $u$ 的子树后，绕环染环上点。再从除 $u$ 外的环上点向下染其他环上点的子树，答案为 $\\sum g_v$。\r\n\r\n发现前后贡献固定，变动的是染环的顺序。染环是染一个区间，每次向左右拓展。每次染一个点，答案加上当前连通块大小，当前连通块大小减 $siz_u$。贪心向小的染是错的，因为有后效性。记录 $siz$ 的前缀和，区间 dp，$O(1)$ 向左右转移。$dp_{l,r}=\\max (dp_{l+1,r}+n-(sum_r-sum_l),dp_{l,r-1}+n-(sum_{r-1}-sum_{l-1}))$。第一维记录区间长度，滚动即可。\r\n\r\n### code\r\n\r\n```cpp\r\nint n;\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nint siz[maxn],dp[maxn],g[maxn];\r\nint d[maxn];\r\nvoid dfs(int u,int fa){\r\n\tsiz[u]=1;g[u]=0;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa||d[v]==2)continue;\r\n\t\tdfs(v,u);siz[u]+=siz[v];g[u]+=g[v];\r\n\t}\r\n\tg[u]+=siz[u];\r\n}\r\nvoid dfs1(int u,int fa){\r\n\tif(d[fa]==2)siz[u]=n-siz[u]+1;\r\n\telse siz[u]=1;\r\n\tdp[u]=0;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa||d[v]==2)continue;\r\n\t\tdfs1(v,u);siz[u]+=siz[v];dp[u]+=dp[v];\r\n\t}\r\n\tdp[u]+=siz[u];\r\n}\r\nint ans,res;\r\nvoid dfs2(int u,int fa){\r\n\tans=max(ans,dp[u]);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa||d[v]==2)continue;\r\n\t\tdp[u]-=dp[v];dp[u]-=siz[u];siz[u]-=siz[v];dp[u]+=siz[u];\r\n\t\tdp[v]-=siz[v];siz[v]+=siz[u];dp[v]+=siz[v];dp[v]+=dp[u];\r\n\t\tdfs2(v,u);\r\n\t\tdp[v]-=dp[u];dp[v]-=siz[v];siz[v]-=siz[u];dp[v]+=siz[v];\r\n\t\tdp[u]-=siz[u];siz[u]+=siz[v];dp[u]+=siz[u];dp[u]+=dp[v];\r\n\t}\r\n}\r\nqueue<int> q;\r\nint p[maxn],num;\r\nbool vis[maxn];\r\nvoid dfs3(int u){\r\n\tvis[u]=1;p[++num]=u;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(d[v]!=2)continue;\r\n\t\tif(!vis[v])dfs3(v);\r\n\t}\r\n}\r\nint f[2][maxn],cur,sum[maxn];\r\nint calc(int l,int r){\r\n\tif(l>r)return sum[num]-sum[l-1]+sum[r];\r\n\treturn sum[r]-sum[l-1];\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint u=read()+1,v=read()+1;\r\n\t\tadd(u,v),add(v,u);\r\n\t\td[u]++,d[v]++;\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(d[i]==1)q.push(i);\r\n\twhile(!q.empty()){\r\n\t\tint u=q.front();q.pop();\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(d[v]>1){\r\n\t\t\t\td[v]--;\r\n\t\t\t\tif(d[v]==1)q.push(v);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++)if(d[i]==2)p[++num]=i;\r\n\tnum=0;dfs3(p[1]);\r\n\tint sumg=0;\r\n\tfor(int ii=1;ii<=num;ii++){\r\n\t\tint u=p[ii];\r\n\t\tsiz[u]=1;\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(d[v]!=2)dfs(v,u),sumg+=g[v],siz[u]+=siz[v];\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=num;i++)sum[i]=sum[i-1]+siz[p[i]];\r\n\t// cout<<sumg<<\"\\n\";\r\n\tfor(int ii=1;ii<=num;ii++){\r\n\t\tint u=p[ii];\r\n\t\tint val=0;int s=n;\r\n\t\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\t\tint v=e[i].to;\r\n\t\t\tif(d[v]!=2){\r\n\t\t\t\tans=0;int lstsiz=siz[v];\r\n\t\t\t\tdfs1(v,u),dfs2(v,u);siz[v]=lstsiz;\r\n\t\t\t\tval=max(val,ans-g[v]+n-siz[v]);\r\n\t\t\t\t// cout<<ans<<\" \"<<g[v]<<\" \"<<siz[v]<<\"\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tval=max(val,n);\r\n\t\ts-=siz[u];\r\n\t\tf[1][ii]=val+sumg;\r\n\t}\r\n\tcur=1;\r\n\tfor(int i=2;i<=num;i++){\r\n\t\tfor(int l=1,r=l+i-1;l<=num;l++,r=(r==num?1:r+1)){\r\n\t\t\tf[i&1][l]=max(f[cur][l]+n-calc(l,(r==1?num:r-1)),f[cur][(l==num?1:l+1)]+n-calc((l==num?1:l+1),r));\r\n\t\t}\r\n\t\tcur^=1;\r\n\t}\r\n\tfor(int i=1;i<=num;i++)res=max(res,f[num&1][i]);\r\n\tprintf(\"%lld\\n\",res);\r\n}\r\n```",
      "data": {
        "title": "CF1218A 题解",
        "date": "2023-12-31 07:51:46",
        "tags": [
          "题解",
          "图论",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1218a-ti-jie"
    },
    {
      "content": "[CF1007B](https://www.luogu.com.cn/problem/CF1007B)\r\n\r\n### 思路\r\n\r\n显然题目要求计数 $u\\mid A,v\\mid B,w\\mid C$。$O(n\\sqrt n)$ 预处理出每个数的所有因数，记为集合 $p_i$。\r\n\r\n容斥，记集合 $a,b,c,ab,ac,bc,all$ 为 $p_A,p_B,p_C,p_A\\cap p_B,p_A\\cap p_A,p_B\\cap p_C,p_A\\cap p_B\\cap p_C$。可以用 bitset 维护交集。\r\n\r\n首先加上 $|a||b||c|$。\r\n\r\n- $u\\in a,v\\in bc,w\\in bc,v\\neq w$。$u,v$ 可以交换，最开始多算 $1$ 次，减去。\r\n\r\n- $u\\in abc,v\\in abc,u\\neq v,w\\in bc\\setminus all$。最开始算 $4$ 次，第一步减 $4$ 次，加上 $1$ 次。\r\n\r\n- $u\\in ab,v\\in bc,w\\in ac$。最开始算两次，减去 $1$ 次。\r\n\r\n- $u,v,w\\in all,u=v\\neq w$。最开始算 $3$ 次，第一步减 $3$ 次，加上 $1$ 次。\r\n\r\n- $u,v,w\\in all$，$u,v,w$ 互不相等。最开始算 $6$ 次，第一步减 $3\\times 3$ 次，加上 $4$ 次。\r\n\r\n观察到 $2^3\\times 3^3\\times 5\\times 7\\times 11=83160$，所以 $|p_i|\\le 128$。如果把分解因数写成先分解质因数再 dfs 求因数，复杂度 $O(n)$，常数约为 $400$。\r\n\r\n### code\r\n\r\n```\r\nlong long  a,b,c,ans;\r\nvector<int> p[maxn];\r\nint gcd(int a,int b){\r\n\tif(a%b==0)return b;\r\n\treturn gcd(b,a%b);\r\n}\r\nint id[maxn],tim;\r\nbitset<385> fa,fb,fc;\r\nvoid work(){\r\n\ta=read();b=read();c=read();ans=0;\r\n\tfa.reset(),fb.reset(),fc.reset();\r\n\tfor(int i:p[a])id[i]=0;\r\n\tfor(int i:p[b])id[i]=0;\r\n\tfor(int i:p[c])id[i]=0;\r\n\ttim=0;\r\n\tfor(int i:p[a])if(!id[i])id[i]=++tim;\r\n\tfor(int i:p[b])if(!id[i])id[i]=++tim;\r\n\tfor(int i:p[c])if(!id[i])id[i]=++tim;\r\n\tfor(int i:p[a])fa[id[i]]=1;\r\n\tfor(int i:p[b])fb[id[i]]=1;\r\n\tfor(int i:p[c])fc[id[i]]=1;\r\n\tlong long ab=(fa&fb).count(),ac=(fa&fc).count(),bc=(fb&fc).count(),all=(fa&fb&fc).count();\r\n\ta=p[a].size(),b=p[b].size(),c=p[c].size();\r\n\t// cout<<a*b*c<<\" \"<<a*bc*(bc-1)/2<<\" \"<<b*ac*(ac-1)/2<<\" \"<<c*ab*(ab-1)/2<<\" \"<<all*(all-1)<<\" \"<<all*(all-1)*(all-2)/6<<\"\\n\";\r\n\tans=a*b*c-a*bc*(bc-1)/2-b*ac*(ac-1)/2-c*ab*(ab-1)/2+all*(all-1)+4*all*(all-1)*(all-2)/6;\r\n\tans+=all*(all-1)/2*(ab-all)+all*(all-1)/2*(ac-all)+all*(all-1)/2*(bc-all);\r\n\tans-=(ab-all)*(bc-all)*(ac-all);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\nint pre[maxn],cnt;\r\nbool vis[maxn];\r\nint f[maxn];\r\nvoid s(int n){\r\n\tfor(int i=2;i<=maxn-10;i++){\r\n\t\tif(!vis[i])pre[++cnt]=i,f[i]=i;\r\n\t\tfor(int j=1;j<=cnt&&i*pre[j]<=n;j++){\r\n\t\t\tvis[i*pre[j]]=1;f[i*pre[j]]=pre[j];\r\n\t\t\tif(i%pre[j]==0)break;\r\n\t\t}\r\n\t}\r\n}\r\nvector<pii> val;\r\nvoid dfs(int dep,int mul,int idx){\r\n\tif(dep==val.size()){\r\n\t\tp[idx].push_back(mul);\r\n\t\treturn ;\r\n\t}\r\n\tfor(int i=0,s=1;i<=val[dep].se;i++){\r\n\t\tdfs(dep+1,mul*s,idx);\r\n\t\ts*=val[dep].fi;\r\n\t}\r\n}\r\nint T;\r\nsigned main(){\r\n\tT=read();s(maxn-10);\r\n\tfor(int i=1;i<=maxn-10;i++){\r\n\t\tint x=i;val.clear();\r\n\t\twhile(x>1){\r\n\t\t\tint lst=f[x],num=0;\r\n\t\t\twhile(f[x]==lst){\r\n\t\t\t\t++num;\r\n\t\t\t\tx/=f[x];\r\n\t\t\t}\r\n\t\t\tval.push_back({lst,num});\r\n\t\t}\r\n\t\tdfs(0,1,i);\r\n\t}\r\n\twhile(T--)work();\r\n}\r\n```",
      "data": {
        "title": "CF1007B 题解",
        "date": "2023-12-31 07:51:03",
        "tags": [
          "题解",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf1007b-ti-jie"
    },
    {
      "content": "[CF924F](https://www.luogu.com.cn/problem/CF924F)\r\n\r\n### 思路\r\n\r\n对于一个数字做背包，$f_i$ 表示当前位能不能凑出 $i$。$f_i\\to f_{\\mid i-v\\mid}$，$f_i\\to f_{i+v}$。答案一定在 $[0,9]$ 中，发现大于 $72$ 的背包不优。\r\n\r\n当做 $18$ 位时，这个背包状态有 $12880$ 种。实验发现，$12880$ 也是全部状态数。可以用数位 dp 套这个背包。宽搜所有转移。\r\n\r\n设 $f_{dep,u,k}$ 为当前剩下后 $dep$ 位随便选，当前在内层自动机的位置为 $u$，最最小值小于 $k$ 的答案。$T$ 组询问，差分询问 $x$，按 $x$ 从高位到低位在自动机上走，如果没有限制就加上对应的 f 值。\r\n\r\n记录状态一个 $73$ 位 01 串方面，卡哈希，可以考虑用一个 ```pair``` 记两个 ```long long``` 表示前一半后一半的值。\r\n\r\n### code\r\n\r\n```cpp\r\nint l,r,k,ans;\r\nbool dp[maxn][75],nw[75];\r\nmap<pii,int> mp;int idx;\r\npii calc(bool *a){\r\n\tint v1=0,v2=0;\r\n\tfor(int i=0;i<=36;i++)v1=v1<<1|a[i];\r\n\tfor(int i=37;i<=72;i++)v2=v2<<1|a[i];\r\n\treturn {v1,v2};\r\n}\r\nint to[maxn][12];\r\nqueue<int> q;\r\nvoid init(){\r\n\tdp[1][0]=1;mp[calc(dp[1])]=++idx;q.push(1);\r\n\twhile(!q.empty()){\r\n\t\tint u=q.front();q.pop();\r\n\t\tfor(int i=0;i<=9;i++){\r\n\t\t\tfor(int j=0;j<=72;j++)nw[j]=0;\r\n\t\t\tfor(int j=0;j<=72;j++){\r\n\t\t\t\tif(j+i<=72)nw[i+j]|=dp[u][j];\r\n\t\t\t\tnw[abs(j-i)]|=dp[u][j];\r\n\t\t\t}\r\n\t\t\tif(mp[calc(nw)])to[u][i]=mp[calc(nw)];\r\n\t\t\telse{\r\n\t\t\t\tmp[calc(nw)]=++idx;to[u][i]=idx;q.push(idx);\r\n\t\t\t\tfor(int j=0;j<=72;j++)dp[idx][j]=nw[j];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nint f[19][maxn][12];\r\nint dfs(int dep,int u){\r\n\tif(~f[dep][u][k])return f[dep][u][k];\r\n\tif(!dep){\r\n\t\tfor(int i=0;i<=k;i++)if(dp[u][i])return f[dep][u][k]=1;\r\n\t\treturn 0;\r\n\t}\r\n\tf[dep][u][k]=0;\r\n\tfor(int i=0;i<=9;i++)f[dep][u][k]+=dfs(dep-1,to[u][i]);\r\n\treturn f[dep][u][k];\r\n}\r\nint a[19],tp;\r\nint sovle(int x){\r\n\tint nd=1,tp=0;\r\n\twhile(x){\r\n\t\ta[++tp]=x%10;\r\n\t\tx/=10;\r\n\t}\r\n\tint res=0;\r\n\tfor(int i=tp;i;i--){\r\n\t\tfor(int j=0;j<a[i];j++)res+=dfs(i-1,to[nd][j]);\r\n\t\tnd=to[nd][a[i]];\r\n\t\t// cout<<i<<\" \"<<res<<\"\\n\";\r\n\t}\r\n\tfor(int i=0;i<=k;i++)if(dp[nd][i]){res++;break;}\r\n\treturn res;\r\n}\r\nvoid work(){\r\n\tl=read(),r=read(),k=read();\r\n\tprintf(\"%lld\\n\",sovle(r)-sovle(l-1));\r\n}\r\n\r\nint T;\r\nsigned main(){\r\n\tinit();\r\n\tcout<<idx<<\"\\n\";\r\n\tmemset(f,-1,sizeof(f));\r\n\t// return 0;\r\n\tT=read();\r\n\twhile(T--)work();\r\n}\r\n```",
      "data": {
        "title": "CF924F 题解",
        "date": "2023-12-31 07:50:19",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf924f-ti-jie"
    },
    {
      "content": "[CF875C](https://www.luogu.com.cn/problem/CF875C)\r\n\r\n### 思路\r\n\r\n显然，满足 $S_{i-1}\\leq S_i$ 即可使整体升序。对于每个 $S_{i-1}\\leq S_i$，都需要满足一些限制，只要所有限制前后不矛盾，则输出是。\r\n\r\n分析 $S_{i-1}\\leq S_i$。枚举位置 $j$ 为第一个两者不等的位置，有几种情况：\r\n\r\n- 不存在 $j$。此时如果 $len_{S_{i-1}}\\leq len_{S_i}$，则 $S_{i-1}\\leq S_i$，没有额外限制。否则 $S_i$ 一定小于 $S_{i-1}$，无解。\r\n\r\n- $S_{i-1,j}$ 小于 $S_{i,j}$，则 $S_{i-1}$ 暂时小于 $S_i$，满足条件。此时只要 $S_{i,j}$ 不改，或 $S_{i-1,j}$ 和 $S_{i,j}$ 同时改即可。也就是说，$S_{i,j}$ 如果改了，$S_{i-1,j}$ 必须改。\r\n\r\n- $S_{i-1,j}$ 大于 $S_{i,j}$，则 $S_{i-1}$ 暂时大于 $S_i$，不满足条件。此时必须改 $S_{i-1,j}$，$S_{i,j}$ 一定不能改。\r\n\r\n由上分析，可以建图解决。\r\n\r\n令 $s$ 表示一定改的起点，$t$ 表示一定不改的终点。\r\n\r\n情况 $1$ 没有额外要求。情况 $2$ 要求改 $S_{i,j}$ 必须改 $S_{i-1,j}$，即 $S_{i,j}$ 向 $S_{i-1,j}$ 连边。情况 $3$ 要求改 $S_{i-1,j}$，不改 $S_{i,j}$，即 $s$ 向 $S_{i,j}$ 连边，$S_{i-1,j}$ 向 $t$ 连边。\r\n\r\n从 $s$ 开始搜索，如果能走到 $t$ 则矛盾，否则能走到的点即为要改的点。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,ans;\r\nint s,t,cur;\r\nint a[2][maxn];\r\nbool vis[maxn];\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){\r\n\te[++tot]={head[u],v};\r\n\thead[u]=tot;\r\n}\r\nvoid dfs(int u){\r\n\tvis[u]=1;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(!vis[v]){\r\n\t\t\tdfs(v);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint T;\r\nsigned main(){\r\n\t//\tfreopen(\".in\",\"r\",stdin);\r\n\t//\tfreopen(\".out\",\"w\",stdout);\r\n\t\r\n\tn=read();m=read();\r\n\ts=0;t=m+1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\ta[cur][0]=read();\r\n\t\tfor(int j=1;j<=a[cur][0];j++){\r\n\t\t\ta[cur][j]=read();\r\n\t\t}\r\n\t\tif(i!=1){\r\n\t\t\tfor(int j=1;j<=min(a[cur^1][0],a[cur][0]);j++){\r\n\t\t\t\tif(a[cur^1][j]>a[cur][j]){\r\n\t\t\t\t\tadd(s,a[cur^1][j]);\r\n\t\t\t\t\tadd(a[cur][j],t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(a[cur^1][j]<a[cur][j]){\r\n\t\t\t\t\tadd(a[cur][j],a[cur^1][j]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(j==min(a[cur^1][0],a[cur][0])&&a[cur^1][0]>a[cur][0]){\r\n\t\t\t\t\tprintf(\"No\\n\");\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\tcur^=1;\r\n\t}\r\n\tdfs(s);\r\n\tif(vis[t]){\r\n\t\tprintf(\"No\\n\");\r\n\t}\r\n\telse{\r\n\t\tprintf(\"Yes\\n\");\r\n\t\tfor(int i=1;i<=m;i++)if(vis[i])++ans;\r\n\t\tprintf(\"%lld\\n\",ans);\r\n\t\tfor(int i=1;i<=m;i++)if(vis[i])printf(\"%lld \",i);\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "CF875C 题解",
        "date": "2023-12-31 07:49:48",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cf875c-ti-jie"
    },
    {
      "content": "[arc179d](https://www.luogu.com.cn/problem/AT_arc179_d)\r\n\r\n### 思路\r\n\r\n设计树形 dp。$dp_{u,0}$ 表示进子树 $u$ 并不再出去的代价。$dp_{u,1}$ 表示进子树 $u$ 并返回，且传送门在 $fa$、不在子树内使用传送门的代价。$dp_{u,2}$ 表示进入子树 $u$ 并返回，且可以在子树内使用传送门。\r\n\r\n发现 $dp_{u,1}$ 一定是遍历子树最后到子树中最深的点通过传送门返回，一定是 $2\\times siz_u+\\max (dep_i-dep_u)$。$dp_{u,0}$ 和 $dp_{u,2}$ 的唯一区别在于 $dp_{u,0}$ 最后进入的一个子树不用返回。\r\n\r\n$$dp_{u,2}=\\sum \\max(dp_{v,1}+1,dp_{v,2}+2),dp_{u,0}=dp_{u,2}+\\min (dp_{v,0}+1-\\min(dp_{v,1}+1,dp_{v,2}+2))$$\r\n\r\n然后换根 dp。考虑 $\\max (dep_i-dep_u)$ 和 $\\min (dp_{v,0}+1-\\min(dp_{v,1}+1,dp_{v,2}+2))$ 的转移，需要记录最大值和次大值。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,ans=inf;\r\nint head[maxn],tot;\r\nstruct nd{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nint dp[maxn][3],siz[maxn];\r\npii dep[maxn],mn[maxn];\r\nvoid dfs(int u,int fa){\r\n\tsiz[u]=1;mn[u].fi=mn[u].se=0,dep[u].fi=dep[u].se=0;\r\n\tif(u!=1&&!e[head[u]].nxt){dp[u][0]=dp[u][1]=dp[u][2]=0;return ;}\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tdfs(v,u);siz[u]+=siz[v];\r\n\t\tif(dep[u].fi<dep[v].fi+1)dep[u].se=dep[u].fi,dep[u].fi=dep[v].fi+1;\r\n\t\telse if(dep[u].se<dep[v].fi+1)dep[u].se=dep[v].fi+1;\r\n\t\tint val=dp[v][0]+1-min(dp[v][1]+1,dp[v][2]+2);\r\n\t\tif(val<mn[u].fi)mn[u].se=mn[u].fi,mn[u].fi=val;\r\n\t\telse if(val<mn[u].se)mn[u].se=val;\r\n\t\tdp[u][0]+=min(dp[v][1]+1,dp[v][2]+2);\r\n\t\tdp[u][2]+=min(dp[v][1]+1,dp[v][2]+2);\r\n\t}\r\n\tdp[u][0]+=mn[u].fi;dp[u][1]=(siz[u]-1)*2-dep[u].fi;\r\n\t// cout<<u<<\" \"<<dp[u][0]<<\" \"<<dp[u][1]<<\" \"<<dp[u][2]<<\"\\n\";\r\n}\r\nvoid dfs1(int u,int fa){\r\n\tans=min(ans,dp[u][0]);\r\n\t// cout<<u<<\" \"<<dp[u][0]<<\" \"<<dp[u][1]<<\" \"<<dp[u][2]<<\"\\n\";\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;if(v==fa)continue;\r\n\t\tint u0=dp[u][0],u1=dp[u][1],u2=dp[u][2];pii du=dep[u],mnu=mn[u];\r\n\t\tsiz[u]-=siz[v],siz[v]+=siz[u];\r\n\t\tif(dep[u].fi==dep[v].fi+1)dep[u].fi=dep[u].se;\r\n\t\tint val=dp[v][0]+1-min(dp[v][1]+1,dp[v][2]+2);\r\n\t\tif(mn[u].fi==val)mn[u].fi=mn[u].se;\r\n\t\tdp[u][1]=(siz[u]-1)*2-dep[u].fi;\r\n\t\tdp[u][2]-=min(dp[v][1]+1,dp[v][2]+2);\r\n\t\tdp[u][0]=dp[u][2]+mn[u].fi;\r\n\t\t\r\n\t\tif(dep[v].fi<dep[u].fi+1)dep[v].se=dep[v].fi,dep[v].fi=dep[u].fi+1;\r\n\t\telse if(dep[v].se<dep[u].fi+1)dep[v].se=dep[u].fi+1;\r\n\t\tval=dp[u][0]+1-min(dp[u][1]+1,dp[u][2]+2);\r\n\t\tif(val<mn[v].fi)mn[v].se=mn[v].fi,mn[v].fi=val;\r\n\t\telse if(val<mn[v].se)mn[v].se=val;\r\n\t\tdp[v][0]+=min(dp[u][1]+1,dp[u][2]+2);\r\n\t\tdp[v][2]+=min(dp[u][1]+1,dp[u][2]+2);\r\n\t\tdp[v][0]=dp[v][2]+mn[v].fi;dp[v][1]=(siz[v]-1)*2-dep[v].fi;\r\n\t\t\r\n\t\tdfs1(v,u);\r\n\t\tdp[u][0]=u0,dp[u][1]=u1,dp[u][2]=u2;dep[u]=du,mn[u]=mnu;\r\n\t\tsiz[v]-=siz[u],siz[u]+=siz[v];\r\n\t}\r\n}\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v),add(v,u);\r\n\t}\r\n\tdfs(1,0);\r\n\tdfs1(1,0);\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "arc179d 题解",
        "date": "2023-12-31 07:46:04",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "arc179d-ti-jie"
    },
    {
      "content": "[arc162f](https://www.luogu.com.cn/problem/AT_arc162_f)\r\n\r\n### 思路\r\n\r\n$a_{x1,y2}\\times a_{x2,y2}\\leq a_{x1,y2}\\times a_{x2,y1}$ 改为所有 $a_{x1,y1}=a_{x2,y2}=1$，都有 $a_{x1,y2}=a_{x2,y1}=1$。\r\n\r\n观察发现，第 $i$ 行 $a_{i,j_1}=\\ldots =a_{i,j_{num}}=1,(j_1<\\ldots <j_{num})$，第 $ii,(ii>i)$ 行能取 $1$ 的位置是 $[1,j_1-1]$ 和 $j$ 的一个前缀。形如：\r\n\r\n```\r\n000010110\r\n000010100\r\n010110100\r\n000000000\r\n100000000\r\n```\r\n\r\n但可以空一些行和列，不方便，考虑将所有有 $1$ 的行和列压起来。设 $dp_{i,j,k}$ 表示前 $i$ 行，有 $j$ 个列有过 $1$，当前行选 $k$ 个，强制连续选。首先可以取一个前缀，$dp'_{i,j,k}=\\sum_{l=k}^j dp_{i-1,j,l}$，后缀和维护。其次可以向前在  $[1,j_1-1]$  任意取，但强制连续选，枚举选 $l$ 个，$dp_{i,j,k}=\\sum_{l=0}^k dp'_{i,j-l,k-l}$，维护一个斜线的前缀和。\r\n\r\n计算答案，对于每个 $dp_{i,j,k}$，$n$ 行选 $i$ 行，$m$ 列选 $j$ 列，其他放 $0$，$ans=\\sum \\binom{n}{i}\\times \\binom{m}{j}\\times dp_{i,j,k}$。再加上全取 $0$ 的情况。\r\n\r\n注意取模优化和枚举时 $\\frac{1}{2}$ 的常数。\r\n\r\n### code\r\n\r\n```cpp\r\n\tfor(int i=1;i<=m;i++)dp[i][i]=1,ans=add(ans,C(m,i)*C(n,1)%mod);\r\n\tfor(int i=2;i<=n;i++){\r\n\t\tfor(int j=1;j<=m;j++){\r\n\t\t\tfor(int k=j;~k;k--)f[j][k]=add(f[j][k+1],dp[j][k]);\r\n\t\t}\r\n\t\tfor(int j=1;j<=m;j++){\r\n\t\t\tfor(int k=1;k<=j;k++)f[j][k]=add(f[j][k],f[j-1][k-1]);\r\n\t\t}\r\n\t\tfor(int j=1;j<=m;j++){\r\n\t\t\tfor(int k=1;k<=j;k++){\r\n\t\t\t\tdp[j][k]=f[j][k];\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(int j=1;j<=m;j++){\r\n\t\t\tfor(int k=1;k<=j;k++){\r\n\t\t\t\tans=add(ans,C(m,j)*C(n,i)%mod*dp[j][k]%mod);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans+1);\r\n```",
      "data": {
        "title": "arc162f 题解",
        "date": "2023-12-31 07:45:24",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "arc162f-ti-jie"
    },
    {
      "content": "[arc119f](https://www.luogu.com.cn/problem/AT_arc119_f)\r\n\r\n自动机写法。开始在做的时候题解没讲每个节点代表什么状态，自己推了一遍，记录一下。\r\n\r\n### 思路\r\n\r\n计数，求有多少种替换方式使得 $0$ 到 $n$ 存在一条长度小于等于 $K$ 的路径。\r\n\r\n可以做 $O(n^3)$ 的 dp。设 $dp_{i,a,b}$ 表示前 $i$ 个位置，最近的 $A$ 和 $B$ 分别在 $a$ 和 $b$。官方题解是优化 $a$ 和 $b$，发现有意义状态下 $a$ 和 $b$ 的差不超过一定数值。\r\n\r\n观察发现，在 $\\text{BAA...AAB}$ 处，肯定选择从 $B$ 直接跳过去。具体的，当有连续的 $4$ 个 $A$ 后，会选择直接从两端的 $B$ 越过。所以有效的状态并不多。\r\n\r\n考虑建一个自动机来求出任意状态对应的下一个状态。由于 $A$ 和 $B$ 可以取反得到，先只考虑当前在 $A$，在 $B$ 同理。以下几种有用状态。\r\n\r\n- 状态 $0$。当前在 $A$，上一个位置为 $B$，记为 $\\text{A}$。\r\n\r\n- 状态 $1$ 即状态 $0$ 反过来，记为 $\\text{B}$。\r\n\r\n- 状态 $2$。当前在 $A$，上一个位置为 $B$，下一个位置为 $A$，记为 $\\text{AA}$。\r\n\r\n- 状态 $4$。当前在 $A$，上一个位置为 $B$，下两个位置为 $AA$，记为 $\\text{AAA}$。\r\n\r\n- 状态 $6$。当前在 $A$，上一个位置为 $B$，下三个位置为 $AAA$，记为 $\\text{AAAA}$。此时如果往后有 $B$，直接先后退越过；否则走向自己，不会有 $5$ 个 $A$ 的状态。注意到此时无论如何都会后退，所以稍微调整一下。定义状态 $6$ 为当前在 $B$，接下来有连续 $A$ 且一定会选择跳过。\r\n\r\n- 状态 $8$。当前在 $A$，上一个位置不重要，下一个位置为 $B$，记为 $\\text{AB}$。此时可以跳到下一个 $A$，也可以爬到 $B$，但不知道走一步后要去 $A$ 还是 $B$。\r\n\r\n- 状态 $10$ 至 $12$。当前既可以当作在 $A$，也可以当作在 $B$，记为 $\\text{O}$，称为状态 $12$。状态 $10$ 表示当前在 $O$，下一个为 $A$，记为 $\\text{OA}$。\r\n\r\n综上，有 $13$ 种有用状态。\r\n\r\n- $\\text{A}$，$\\text{AA}$，$\\text{AAA}$，$\\text{AAAA}$，$\\text{AB}$。\r\n\r\n- 上面 $5$ 种状态取反得到当前在 $B$ 的另外 $5$ 种。\r\n\r\n- $\\text{OA}$,$\\text{OB}$,$\\text{O}$。\r\n\r\n考虑转移。记 $tree_{i,0/1}$ 表示当前状态为 $i$，加入 $A$ 或 $B$，走向哪一个状态，$val_{i,0/1}$ 为转移的代价。\r\n\r\n- 状态 $\\text{A}$。如果加入 $A$，走向状态 $\\text{AA}$，点没有移动，代价为 $0$。如果加入 $B$，走向状态 $\\text{AB}$，点没有移动，代价为 $0$。\r\n\r\n- 状态 $\\text{AA}$。如果加入 $A$，走向状态 $\\text{AAA}$，点没有移动，代价为 $0$。如果加入 $B$，走向状态 $\\text{AB}$，点向后移动一格，代价为 $1$。\r\n\r\n- 状态 $\\text{AAA}$。如果加入 $A$，走向状态 $\\text{AAAA}$，点后退一步到上一个 $B$，代价为 $1$。如果加入 $B$，可以先向后再向前越过 $AAA$ 到下一个 $B$，也可以爬两步 $A$，即走向状态 $\\text{O}$，代价为 $2$。\r\n\r\n- 状态 $\\text{AAAA}$。注意这里状态不同于以前，当前点为 $B$。如果加入 $A$，走向状态自己 $\\text{AAAA}$，点不动，代价为 $0$。如果加入 $B$，向前越过 $AAAA$ 到下一个 $B$，即走向状态 $\\text{B}$，代价为 $1$。\r\n\r\n- 状态 $\\text{AB}$。如果加入 $A$，可以向后走到 $B$，也可以跳到下一个 $A$，即走向状态 $O$，代价为 $1$。如果加入 $B$，虽然没有连续 $4$ 个 $B$，但一定会从 $A$ 跳过这段 $B$，即状态 $\\text{BBBB}$，代价为 $0$。\r\n\r\n- 状态 $\\text{OA}$。如果加入 $A$，虽然没有连续 $4$ 个 $A$，但一定会把 $O$ 当作 $B$ 跳过这段 $A$，即状态 $\\text{AAAA}$，代价为 $0$。如果加入 $B$，可以向后走到 $A$，也可以把 $O$ 当作 $B$ 跳到下一个 $B$，即走向状态 $\\text{O}$，代价为 $1$。\r\n\r\n- 状态 $\\text{O}$。如果加入 $A$，走向状态 $\\text{OA}$，代价为 $0$。如果加入 $B$，走向状态 $\\text{OB}$，代价为 $0$。\r\n\r\n分析完自动机状态的转移，dp 即可。设 $dp_{i,j,k}$ 表示加入前 $i$ 位，走了 $j$ 步，当前状态为 $k$。\r\n\r\n$$dp_{0,0,12}=1$$\r\n\r\n$$dp_{i+1,j+val_{k,0},tree_{k,0}}+=dp_{i,j,k}$$\r\n\r\n$$dp_{i+1,j+val_{k,1},tree_{k,1}}+=dp_{i,j,k}$$\r\n\r\n注意到加入一位并不是走到一位。状态设定的当前走到的点不是状态的最后一位。记录 $dis$ 表示状态的最后一位是 $n-1$，状态设定的当前走到的点离终点的距离，稍微处理即可。\r\n\r\n复杂度 $O(13nk)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m,ans;\r\nchar c[maxn];\r\nint tree[15][2],val[15][2];\r\nint dis[7];\r\nint dp[maxn][maxn][15];\r\nsigned main(){\r\n\tn=read();m=read();\r\n\tscanf(\"%s\",c+1);\r\n\ttree[0][0]=2;val[0][0]=0;tree[0][1]=8;val[0][1]=0;\r\n\ttree[2][0]=4;val[2][0]=0;tree[2][1]=8;val[2][1]=1;\r\n\ttree[4][0]=6;val[4][0]=1;tree[4][1]=12;val[4][1]=2;\r\n\ttree[6][0]=6;val[6][0]=0;tree[6][1]=1;val[6][1]=1;\r\n\ttree[8][0]=12;val[8][0]=1;tree[8][1]=7;val[8][1]=0;\r\n\ttree[10][0]=6;val[10][0]=0;tree[10][1]=12;val[10][1]=1;\r\n\ttree[12][0]=10;val[12][0]=0;tree[12][1]=11;val[12][1]=0;\r\n\tfor(int i=0;i<=5;i++){//状态取反。\r\n\t\tfor(int k=0;k<=1;k++){\r\n\t\t\tif(tree[i*2][k^1]==12)tree[i*2+1][k]=tree[i*2][k^1];\r\n\t\t\telse tree[i*2+1][k]=tree[i*2][k^1]^1;\r\n\t\t\tval[i*2+1][k]=val[i*2][k^1];\r\n\t\t}\r\n\t}\r\n//\tfor(int i=0;i<=12;i++)cout<<tree[i][0]<<\" \"<<val[i][0]<<\" \"<<tree[i][1]<<\" \"<<val[i][1]<<\"\\n\";\r\n\tdis[0]=dis[3]=dis[4]=dis[5]=dis[6]=1;\r\n\tdis[1]=dis[2]=2;\r\n\tdp[0][0][12]=1;\r\n\tfor(int i=0;i<=n-2;i++){\r\n\t\tfor(int j=0;j<=m;j++){\r\n\t\t\tfor(int k=0;k<=12;k++){\r\n\t\t\t\tif(dp[i][j][k]){\r\n\t\t\t\t\tif(c[i+1]=='A'){\r\n\t\t\t\t\t\tdp[i+1][j+val[k][0]][tree[k][0]]+=dp[i][j][k];\r\n\t\t\t\t\t\tdp[i+1][j+val[k][0]][tree[k][0]]%=mod;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(c[i+1]=='B'){\r\n\t\t\t\t\t\tdp[i+1][j+val[k][1]][tree[k][1]]+=dp[i][j][k];\r\n\t\t\t\t\t\tdp[i+1][j+val[k][1]][tree[k][1]]%=mod;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tdp[i+1][j+val[k][0]][tree[k][0]]+=dp[i][j][k];\r\n\t\t\t\t\t\tdp[i+1][j+val[k][0]][tree[k][0]]%=mod;\r\n\t\t\t\t\t\tdp[i+1][j+val[k][1]][tree[k][1]]+=dp[i][j][k];\r\n\t\t\t\t\t\tdp[i+1][j+val[k][1]][tree[k][1]]%=mod;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int j=0;j<=m;j++){\r\n\t\tfor(int k=0;k<=12;k++)if(j+dis[k>>1]<=m){\r\n\t\t\tans+=dp[n-1][j][k];\r\n\t\t\tans%=mod;\r\n\t\t}\r\n\t}\r\n\tprintf(\"%lld\\n\",ans);\r\n}\r\n```",
      "data": {
        "title": "arc119f 题解",
        "date": "2023-12-31 07:44:08",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "arc119f-ti-jie"
    },
    {
      "content": "[ARC106D](https://www.luogu.com.cn/problem/AT_arc106_d)\r\n\r\n\r\n### 思路\r\n\r\n左边到右边不好，改为任意一个到另一个。\r\n\r\n$$ans_x=\\frac{1}{2}(\\sum_i^n\\sum_j^n (a_i+a_j)^x-\\sum_i^n (2\\times a_i)^x)$$\r\n\r\n拆开 $k$ 次方。\r\n\r\n$$(a_i+a_j)^x=\\sum_{k=0}^x (\\binom{x}{k}\\times {a_i}^k\\times {a_j}^{x-k})$$\r\n\r\n$$ans_x=\\frac{1}{2}(\\sum_{k=0}^x(\\sum_i^n {a_i}^k\\times \\sum_j^n {a_j}^{x-k})-\\sum_i^n (2\\times a_i)^x)$$\r\n\r\n预处理 $sum_k=\\sum_i {a_i}^k$。\r\n\r\n$$ans_x=\\frac{1}{2}(\\sum_{k=0}^x(sum_k\\times sum_{x-k})-2^x\\times sum_x)$$\r\n\r\n复杂度 $O(nk+k^2)$。 \r\n\r\n### code\r\n\r\n```cpp\r\nint n,x,a[maxn];\r\ninline int ksm(int a,int b=mod-2,int p=mod){\r\n\tint ans=1;\r\n\twhile(b){\r\n\t\tif(b&1)ans=ans*a%p;\r\n\t\ta=a*a%p;\r\n\t\tb>>=1;\r\n\t}\r\n\treturn ans;\r\n}\r\nint ans,ni;\r\nint fac[maxn],inv[maxn];\r\nint C(int m,int n){return fac[m]*inv[n]%mod*inv[m-n]%mod;}\r\nint sum[maxm],mul[maxn];\r\nvoid work(){\r\n\tn=read();x=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read(),mul[i]=1;\r\n\tfor(int k=0;k<=x;k++){\r\n\t\tfor(int i=1;i<=n;i++)sum[k]+=mul[i],sum[k]%=mod;\r\n\t\tfor(int i=1;i<=n;i++)mul[i]=mul[i]*a[i]%mod;\r\n//\t\tcout<<sum[k]<<\" \";\r\n\t}\r\n//\tcout<<\"\\n\";\r\n\tfac[0]=1;for(int i=1;i<=x;i++)fac[i]=fac[i-1]*i%mod;\r\n\tinv[x]=ksm(fac[x]);\r\n\tfor(int i=x-1;~i;i--)inv[i]=inv[i+1]*(i+1)%mod;\r\n\tni=ksm(2);\r\n\tfor(int i=1;i<=x;i++){\r\n\t\tans=0;\r\n\t\tfor(int k=0;k<=i;k++)ans+=C(i,k)*sum[k]%mod*sum[i-k]%mod,ans%=mod;\r\n\t\tans+=mod-ksm(2,i)*sum[i]%mod,ans%=mod;\r\n\t\tans*=ni,ans%=mod;\r\n\t\tprintf(\"%lld\\n\",ans);\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "arc106d 题解",
        "date": "2023-12-31 07:43:30",
        "tags": [
          "题解",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "arc106d-ti-jie"
    },
    {
      "content": "[agc049a](https://www.luogu.com.cn/problem/AT_agc049_a)\r\n\r\n### 思路\r\n\r\n期望。\r\n\r\n与 [CF280C](https://www.luogu.com.cn/problem/CF280C) 相似的思路。\r\n\r\n每个点最多被做一次，或者被其他点影响。设 $f_i$ 表示 $i$ 是否被选，为 $0$ 或 $1$。答案为 $E[\\sum f_i]$，即 $\\sum f_i$ 的期望。\r\n\r\n$$ans=E[\\sum f_i]=\\sum E[f_i]=\\sum p_i$$\r\n\r\n所以答案为每个点被选的概率的和。\r\n\r\n能影响点 $i$ 使其不被选的点，是那些能到达 $i$ 的点，如果在 $i$ 之前被选，那么 $i$ 就不用选了。所以设 $siz$ 为能影响点 $i$ 的点数（包括自己），则 $p_i=\\frac{1}{siz}$ 。\r\n\r\n$n\\leq100$ ，用 弗洛伊德 看一个点能去哪些点。\r\n\r\n### code\r\n\r\n```cpp\r\ndouble n,ans,siz;\r\nchar c[maxn];\r\nint e[maxn][maxn];\r\nsigned main(){\r\n\tcin>>n;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tcin>>c+1;\r\n\t\tfor(int j=1;j<=n;j++)e[j][i]=c[j]-'0';\r\n\t}\r\n\tfor(int i=1;i<=n;i++)e[i][i]=1;\r\n\tfor(int k=1;k<=n;k++){\r\n\t\tfor(int i=1;i<=n;i++){\r\n\t\t\tfor(int j=1;j<=n;j++){\r\n\t\t\t\tif(e[i][k]&&e[k][j])e[i][j]=1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tsiz=0;\r\n\t\tfor(int j=1;j<=n;j++){\r\n\t\t\tif(e[i][j])++siz;\r\n\t\t}\r\n\t\tans+=1.0/siz;\r\n\t}\r\n\tprintf(\"%.10lf\",ans);\r\n}\r\n```",
      "data": {
        "title": "agc049a 题解",
        "date": "2023-12-31 07:41:53",
        "tags": [
          "题解",
          "概率期望"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "agc049a-ti-jie"
    },
    {
      "content": "[abc355f](https://www.luogu.com.cn/problem/AT_abc355_f)\r\n\r\n~~直接贺 lct 维护 mst 的代码。~~\r\n\r\n### 思路\r\n\r\n观察到 $w_i\\le 10$，考虑分开建 $10$ 个图表示边权小于等于 $i$ 的边组成的图。连并查集，记录当前图连了 $siz_i$ 条边。\r\n\r\n可以发现第 $i-1$ 个图是第 $i$ 个图的子图。所以差分 $siz_i-siz_{i-1}$ 可以得到原图的最小生成树中边权为 $i$ 的边数。\r\n\r\n复杂度 $O(n\\max w_i)$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nint f[11][maxn],siz[11];\r\nint fd(int id,int x){\r\n\tif(f[id][x]==x)return x;\r\n\treturn f[id][x]=fd(id,f[id][x]);\r\n}\r\nvoid work(){\r\n\tn=read();m=read();\r\n\tfor(int i=1;i<=10;i++)for(int j=1;j<=n;j++)f[i][j]=j;\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read(),w=read();\r\n\t\tfor(int j=w;j<=10;j++)if(fd(j,u)!=fd(j,v))f[j][fd(j,u)]=fd(j,v),siz[j]++;\r\n\t}\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint u=read(),v=read(),w=read();\r\n\t\tfor(int j=w;j<=10;j++)if(fd(j,u)!=fd(j,v))f[j][fd(j,u)]=fd(j,v),siz[j]++;\r\n\t\tint ans=0;\r\n\t\tfor(int j=1;j<=10;j++)ans+=(siz[j]-siz[j-1])*j;\r\n\t\tprintf(\"%lld\\n\",ans);\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "abc355f 题解",
        "date": "2023-12-31 07:40:56",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "abc355f-ti-jie"
    },
    {
      "content": "[abc349g](https://www.luogu.com.cn/problem/AT_abc349_g)\r\n\r\n### 思路\r\n\r\n从前往后枚举 $i$，每次对 $i+1\\le j\\le i+a_i$ 的 $j$  赋值 $b_j=b_{i\\times 2-j}$。同时有 $b_{i+a_i+1}\\ne b_{i-a_i-1}$。用 $ban_{i,j}$ 记录 $i$ 不能是 $j$，如果要给 $i$ 赋值就选最小的。\r\n\r\n最直接的就是并查集倍增将两段区间并起来。\r\n\r\n可以用类似马拉车的思路得到一个贪心算法。枚举，维护 $r$ 表示当前已知 $b_1\\dotsb b_r$。如果 $i+a_i\\ge r$ 就把 $r$ 更新到 $i+a_i$，否则什么也不做。最后在 hash 判断所有 $a_i$ 是不是都满足条件。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,a[maxn],b[maxn];\r\nint h[maxn],h2[maxn],pw[maxn],bas,val[10];\r\nint calc(int l,int r){return (h[r]-h[l-1]*pw[r-l+1]%mod+mod)%mod;}\r\nint calc2(int l,int r){return (h2[l]-h2[r+1]*pw[r-l+1]%mod+mod)%mod;}\r\nvector<int> ban[maxn];bool vis[10];\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<=n;i++)a[i]=read();\r\n\tfor(int i=2,r=1;i<=n;i++){\r\n\t\tif(i>r){\r\n\t\t\tint mex=10;\r\n\t\t\tfor(int j:ban[i])vis[j]=1;\r\n\t\t\tfor(int j=0;j<10;j++)if(!vis[j]){mex=j;break;}\r\n\t\t\tfor(int j:ban[i])vis[j]=0;\r\n\t\t\tif(mex==10){printf(\"No\\n\");return ;}\r\n\t\t\tb[r=i]=mex;\r\n\t\t}\r\n\t\tif(i+a[i]>r){\r\n\t\t\tfor(int j=r+1;j<=i+a[i];j++)b[j]=b[i*2-j];\r\n\t\t\tr=i+a[i];\r\n\t\t}\r\n\t\tif(i-a[i]-1){ban[i+a[i]+1].push_back(b[i-a[i]-1]);}\r\n\t}\r\n\tsrand(time(0));\r\n\tbas=rand()*rand()%mod;\r\n\tfor(int i=0;i<10;i++)val[i]=rand()*rand()%bas;\r\n\tpw[0]=1;for(int i=1;i<=n;i++)pw[i]=pw[i-1]*bas%mod;\r\n\tfor(int i=1;i<=n;i++)h[i]=(h[i-1]*bas+val[b[i]])%mod;\r\n\tfor(int i=n;i;i--)h2[i]=(h2[i+1]*bas+val[b[i]])%mod;;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tif(calc(i-a[i],i)!=calc2(i,i+a[i])){printf(\"No\");return ;}\r\n\t\tif(i-a[i]>1&&i+a[i]<n){\r\n\t\t\tif(b[i-a[i]-1]==b[i+a[i]+1]){printf(\"No\");return ;}\r\n\t\t}\r\n\t}\r\n\tprintf(\"Yes\\n\");\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld \",b[i]+1);\r\n}\r\n```",
      "data": {
        "title": "abc349g 题解",
        "date": "2023-12-31 07:40:15",
        "tags": [
          "题解",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "abc349g-ti-jie"
    },
    {
      "content": "[abc337g](https://www.luogu.com.cn/problem/solution/AT_abc337_g)\r\n\r\n### 思路\r\n\r\n固定 $w$，将树分为子树内外两部分，分别考虑子树内到子树外，子树外到子树内，两个儿子之间的贡献。\r\n\r\n需要支持查询 $u$ 子树内比 $u$ 大的数的个数，做子树加。后半部分可以 dfn 序上线段树区间加，前面部分没想到从小到大加入 $w$，直接用权值线段树合并。复杂度 $O(n\\log n)$。\r\n\r\n不知道为什么线段树合并 $32$ 倍空间 RE 了，挂了两发。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nint head[maxn],tot;\r\nstruct edgend{\r\n\tint nxt,to;\r\n}e[maxn<<1];\r\nvoid add(int u,int v){e[++tot]={head[u],v};head[u]=tot;}\r\nnamespace sgt{\r\n#define mid (l+r>>1)\r\n#define ls nd<<1\r\n#define rs nd<<1|1\r\n\tint tree[maxn<<2],tag[maxn<<2];\r\n\tvoid push(int nd,int l,int r){\r\n\t\ttree[ls]+=(mid-l+1)*tag[nd],tag[ls]+=tag[nd];\r\n\t\ttree[rs]+=(r-mid)*tag[nd],tag[rs]+=tag[nd];\r\n\t\ttag[nd]=0;\r\n\t}\r\n\tvoid updata(int nd,int l,int r,int ql,int qr,int w){\r\n\t\tif(ql>qr)return ;\r\n\t\tif(l>=ql&&r<=qr){\r\n\t\t\ttree[nd]+=(r-l+1)*w;tag[nd]+=w;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tif(tag[nd])push(nd,l,r);\r\n\t\tif(ql<=mid)updata(ls,l,mid,ql,qr,w);\r\n\t\tif(qr>mid)updata(rs,mid+1,r,ql,qr,w);\r\n\t\ttree[nd]=tree[ls]+tree[rs];\r\n\t}\r\n\tint query(int nd,int l,int r,int p){\r\n\t\tif(l==r)return tree[nd];\r\n\t\tif(tag[nd])push(nd,l,r);\r\n\t\tif(p<=mid)return query(ls,l,mid,p);\r\n\t\telse return query(rs,mid+1,r,p);\r\n\t}\r\n#undef mid\r\n#undef ls\r\n#undef rs\r\n}\r\nint dfn[maxn],idx,rnk[maxn],siz[maxn];\r\nvoid dfs(int u,int fa){\r\n\trnk[dfn[u]=++idx]=u;siz[u]=1;\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v==fa)continue;\r\n\t\tdfs(v,u);siz[u]+=siz[v];\r\n\t}\r\n}\r\nnamespace tr{\r\n#define mid (l+r>>1)\r\n#define ls lc[nd]\r\n#define rs rc[nd]\r\n\tint rt[maxn],idx;\r\n\tint tree[maxn<<6],lc[maxn<<6],rc[maxn<<6];\r\n\tvoid updata(int &nd,int l,int r,int p,int w){\r\n\t\tif(!nd)nd=++idx;\r\n\t\tif(l==r){tree[nd]+=w;return ;}\r\n\t\tif(p<=mid)updata(ls,l,mid,p,w);\r\n\t\telse updata(rs,mid+1,r,p,w);\r\n\t\ttree[nd]=tree[ls]+tree[rs];\r\n\t}\r\n\tint merge(int u,int v,int l,int r){\r\n\t\tif(!u||!v)return u|v;\r\n\t\tint nd=++idx;\r\n\t\tif(l==r){tree[nd]=tree[u]+tree[v];return nd;}\r\n\t\tls=merge(lc[u],lc[v],l,mid);\r\n\t\trs=merge(rc[u],rc[v],mid+1,r);\r\n\t\ttree[nd]=tree[ls]+tree[rs];\r\n\t\treturn nd;\r\n\t}\r\n\tint query(int nd,int l,int r,int ql,int qr){\r\n//\t\tif(!nd)return 0;\r\n\t\tif(ql>qr)return 0;\r\n\t\tif(l>=ql&&r<=qr)return tree[nd];\r\n\t\tif(qr<=mid)return query(ls,l,mid,ql,qr);\r\n\t\tif(ql>mid)return query(rs,mid+1,r,ql,qr);\r\n\t\treturn query(ls,l,mid,ql,qr)+query(rs,mid+1,r,ql,qr);\r\n\t}\r\n}\r\nvoid dfs2(int u,int fa){\r\n\ttr::updata(tr::rt[u],1,n,u,1);\r\n\tfor(int i=head[u];i;i=e[i].nxt){\r\n\t\tint v=e[i].to;\r\n\t\tif(v==fa)continue;\r\n\t\tdfs2(v,u);\r\n\t\tint num=tr::query(tr::rt[v],1,n,1,u-1);\r\n\t\tsgt::updata(1,1,n,dfn[u]+1,dfn[v]-1,num);sgt::updata(1,1,n,dfn[v]+siz[v],dfn[u]+siz[u]-1,num);\r\n\t\ttr::rt[u]=tr::merge(tr::rt[u],tr::rt[v],1,n);\r\n\t}\r\n\tint num=tr::query(tr::rt[u],1,n,1,u-1);\r\n//\tcout<<u<<\" \"<<num<<\" \";\r\n\tsgt::updata(1,1,n,1,dfn[u],num);sgt::updata(1,1,n,dfn[u]+siz[u],n,num);\r\n\tnum=u-1-tr::query(tr::rt[u],1,n,1,u-1);\r\n//\tcout<<num<<\"\\n\";\r\n\tsgt::updata(1,1,n,dfn[u],dfn[u]+siz[u]-1,num);\r\n\t\r\n}\r\nint ans[maxn];\r\nvoid work(){\r\n\tn=read();\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint u=read(),v=read();\r\n\t\tadd(u,v);add(v,u);\r\n\t}\r\n\tdfs(1,0);\r\n\tdfs2(1,0);\r\n\tfor(int i=1;i<=n;i++)ans[rnk[i]]=sgt::query(1,1,n,i);\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld \",ans[i]);\r\n}\r\n```",
      "data": {
        "title": "abc337g 题解",
        "date": "2023-12-31 07:38:37",
        "tags": [
          "题解",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "abc337g-ti-jie"
    },
    {
      "content": "[abc238g](https://www.luogu.com.cn/problem/AT_abc238_g)\r\n\r\n\r\n### 思路\r\n\r\n莫队 $O(n\\sqrt n\\log a_i)$。\r\n\r\n哈希。\r\n\r\n把 $a_i$ 质因数分解，指数模 $3$。直接乘过大，考虑哈希。每个质数的指数和都因为 $3$ 的倍数。\r\n\r\n即：所有数的出现次数和是否都为 $k$ 的倍数。\r\n\r\n法一：前缀和。给每个质数随机 $val_i$，$a_i=\\sum val_p$，做前缀和。如果是完全立方数可推出 $sum_r-sum_{l-1}\\mod 3=0$。因为对 $k$ 取模，所以 $val_p$ 可看作从$[0,k-1]$ 中随机。显然只做一次是不行的，重复 $b$ 次。可以大概认为单次正确率为 $\\frac{1}{k}$，一道题正确率 $(1-(\\frac{1}{k})^b)^{qT}$，$T$ 是测试点数。\r\n\r\n法二：异或。给每个质数随机 $val_{i,0}$ 到 $val_{i,k-2}$ 共 $k-1$ 个值，令 $val_{i,k-1}=\\oplus_{j=0}^{k-2} val_{i,j}$。从前往后，如果当前 $a_i$ 有质因数 $p$ 且 $p$ 在 $a_i$ 前已经出现 $num_p$ 次，$num_p$ 对 $k$ 取模，$hsh_i$ 异或上 $val_{p,num_p}$。做前缀异或和，如果是完全立方数可推出 $sum_r\\oplus sum_{l-1}=0$。因为是异或，所以错误率极低。\r\n\r\n法一适合 $k$ 较大，法二适合 $k$ 较小，代码用法二。\r\n\r\n另外，既然不用莫队，可以把复杂度优化到 $O(n\\log n)$，筛质数的时候记录 $g_i$ 表示 $i$ 最小的质因数。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nint pre[maxn],cnt;\r\nint g[maxn],f[maxn];\r\nbool vis[maxn];\r\nint val[maxn][3],num[maxn];\r\nvoid s(int n){\r\n\tfor(int i=2;i<=n;i++){\r\n\t\tif(!vis[i]){\r\n\t\t\tpre[++cnt]=i;g[i]=i;\r\n\t\t\tval[i][0]=rand()*rand()%inf;\r\n\t\t\tval[i][1]=rand()*rand()%inf;\r\n\t\t\tval[i][2]=val[i][0]^val[i][1];\r\n\t\t}\r\n\t\tfor(int j=1;j<=cnt&&i*pre[j]<=n;j++){\r\n\t\t\tvis[i*pre[j]]=1;g[i*pre[j]]=pre[j];\r\n\t\t\tif(i%pre[j]==0)break;\r\n\t\t}\r\n\t}\r\n}\r\nvoid work(){\r\n\tsrand(time(0));\r\n\tn=read();s(maxn-10);m=read();\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tint x=read();\r\n\t\twhile(g[x]){\r\n\t\t\tf[i]^=val[g[x]][num[g[x]]%3];\r\n\t\t\tnum[g[x]]++;\r\n\t\t\tx/=g[x];\r\n\t\t}\r\n//\t\tcout<<f[i]<<\" \";\r\n\t\tf[i]^=f[i-1];\r\n\t}\r\n\twhile(m--){\r\n\t\tint u=read(),v=read();\r\n\t\tif((f[v]^f[u-1])==0)printf(\"Yes\\n\");\r\n\t\telse printf(\"No\\n\");\r\n\t}\r\n}\r\n```",
      "data": {
        "title": "abc238g 做题记录",
        "date": "2023-12-31 07:36:54",
        "tags": [
          "题解",
          "哈希"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "abc238g-zuo-ti-ji-lu"
    },
    {
      "content": "[abc217g](https://www.luogu.com.cn/problem/AT_abc217_g)\r\n\r\n### 思路\r\n\r\n设 $f_{i,j}$ 表示前 $i$ 个数分到 $j$ 组的情况数。\r\n\r\n两种转移：\r\n\r\n- 新开一组。$f_{i,j}=f_{i-1,j-1}$。\r\n\r\n- 加入之前的组。在 $i$ 之前与 $i$ 模 $m$ 余数相同的有 $\\frac{i-1}{m}$ 个，剩下 $j-\\frac{i-1}{m}$ 组可以加入。$f_{i,j}=f_{i-1,j}\\times (j-\\frac{i-1}{m})$。\r\n\r\n最后答案为 $f_{n,i}$。\r\n\r\n### code\r\n\r\n```cpp\r\nint n,m;\r\nint f[maxn][maxn];\r\n\r\nint T;\r\nsigned main(){\r\n//\tfreopen(\".in\",\"r\",stdin);\r\n//\tfreopen(\".out\",\"w\",stdout);\r\n\r\n\tn=read();m=read();\r\n\tf[0][0]=1;\r\n\tfor(int i=1;i<=n;i++){\r\n\t\tfor(int j=1;j<=n;j++){\r\n\t\t\tf[i][j]=f[i-1][j-1];\r\n\t\t\tif(j>=(i+1)/m)f[i][j]+=f[i-1][j]*(j-(i-1)/m);\r\n\t\t\tf[i][j]%=mod;\r\n//\t\t\tcout<<f[i][j]<<\" \";\r\n\t\t}\r\n//\t\tcout<<\"\\n\";\r\n\t}\r\n\tfor(int i=1;i<=n;i++)printf(\"%lld\\n\",f[n][i]);\r\n}\r\n```",
      "data": {
        "title": "abc217g 题解",
        "date": "2023-12-31 07:35:14",
        "tags": [
          "题解",
          "dp"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "abc217g-ti-jie"
    }
  ],
  "tags": [
    {
      "name": "计数",
      "slug": "ji-shu",
      "used": true
    },
    {
      "name": "acm",
      "slug": "acm",
      "used": true
    },
    {
      "name": "随机说话",
      "slug": "jy5Pht0LHl",
      "used": true
    },
    {
      "name": "游记",
      "slug": "AuY4ZHOv9O",
      "used": true
    },
    {
      "name": "网络流",
      "slug": "H7ae-fd_LT",
      "used": true
    },
    {
      "name": "笔记",
      "slug": "lCGT0L7Fpf",
      "used": true
    },
    {
      "name": "非传统题",
      "slug": "EGF3e5YRJg",
      "used": true
    },
    {
      "name": "构造",
      "slug": "VgMnBDjlUw",
      "used": true
    },
    {
      "name": "数学",
      "slug": "8msVnv8ktV",
      "used": true
    },
    {
      "name": "概率期望",
      "slug": "_lSZqgazqt",
      "used": true
    },
    {
      "name": "字符串",
      "slug": "2CIh50ouxs",
      "used": true
    },
    {
      "name": "哈希",
      "slug": "sY41xmFV02",
      "used": true
    },
    {
      "name": "dp",
      "slug": "a6XwkWmtgC",
      "used": true
    },
    {
      "name": "生成函数",
      "slug": "TkU6A_oCD7",
      "used": true
    },
    {
      "name": "题解",
      "slug": "vDpH-t1gbD",
      "used": true
    },
    {
      "name": "图论",
      "slug": "inVIC10HCFS",
      "used": true
    },
    {
      "name": "数据结构",
      "slug": "YnPdfse-RKW",
      "used": true
    },
    {
      "name": "ucup",
      "slug": "WNAEYkPPxHM",
      "used": true
    },
    {
      "name": "做题记录",
      "slug": "p7hyyBRA1BX",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}