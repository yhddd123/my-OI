### T1：P2757

如果存在长度 $>3$ 的子序列那么一定存在 $=3$ 的，考虑 $=3$ 即可。

枚举中间数 $a_p$，存在等差子序列等价于存在一个 $k$，使得 $a_p-k$ 在 $p$ 左边且 $a_p+k$ 在 $p$ 右边。

考虑正难则反，如果不存在就是对于所有 $k$，$a_p-k$ 在 $p$ 左右的情况和 $a_p+k$ 在 $p$ 左右的情况一样。

设在 $p$ 左边的数为 $1$，右边的数为 $0$，写出一个 $0/1$ 序列。

则不存在以 $p$ 为中心的等差子序列等价于 $a_p$ 之后的状态和 $a_p$ 之前的状态构成回文串，可使用哈希判断。

按顺序枚举 $p$，每次把 $a_p$ 的位置修改为 $1$，线段树维护区间哈希值即可。

复杂度 $O(n\log n)$。

---

### T2：CF718C

考虑矩阵实现在斐波那契下标上的加，即往后转移若干轮。

首先有 $\begin{bmatrix}\operatorname{Fib}_i&\operatorname{Fib}_{i+1}\end{bmatrix}=\begin{bmatrix}\operatorname{Fib}_{i-1}&\operatorname{Fib}_i\end{bmatrix}\begin{bmatrix}0&1\\1&1\end{bmatrix}$，所以 $a_i\gets a_i+x$ 即 $\begin{bmatrix}\operatorname{Fib}_{a_i}&\operatorname{Fib}_{a_i+1}\end{bmatrix}\gets\begin{bmatrix}\operatorname{Fib}_{a_i}&\operatorname{Fib}_{a_i+1}\end{bmatrix}\begin{bmatrix}0&1\\1&1\end{bmatrix}^x$。

于是区间加等价于区间乘，注意到矩阵运算有结合律，可以线段树维护区间 $\begin{bmatrix}\operatorname{Fib}_{a_i}&\operatorname{Fib}_{a_i+1}\end{bmatrix}$ 之和。

复杂度 $O((n+q\log n)\omega^3)$，其中 $\omega=2$。

---

### T3：CF911G

注意到颜色数很小，考虑建 $100$ 棵动态开点线段树，只维护线段树结构（即左右儿子）。

若线段树 $x$ 含有叶子 $p$，则表示序列中 $a_p=x$。

那么区间 $x$ 变 $y$ 相当于把 $x$ 线段树的这一部分合并到 $y$ 上。递归到对应的结点合并即可。

时空 $O(n\log n)$。

---

### T4：P2839

可以发现中位数大于等于 $x$，等价于比 $x$ 大的数个数大于等于比 $x$ 小的数个数，记比 $x$ 小的数为 $-1$，比 $x$ 大的数为 $1$，则等价于区间和 $\ge 0$。

二分答案，判断是否能 $\operatorname{ans}\ge mid$。仍然记比 $mid$ 小的数为 $-1$，比 $mid$ 大的数为 $1$，则等价于存在一个满足端点限制且和 $\ge 0$ 的区间。

这等价于，$[b,c]$ 必选，$[a,b]$ 选一个最大后缀和，$[c,d]$ 选一个最大前缀和。

按值域建主席树，维护区间和、区间前缀最大值和区间后缀最大值即可。

复杂度 $O(n\log n+q\log^2n)$。

---

### T5：P8969

注意到一次 $\operatorname{popcount}$ 操作之后值域只有 $\log$，可以考虑一些暴力的维护。

这样设计标记：每个节点记一个 $o,a,b,f[64]$。

- 若 $o=0$ 则 $val(x)=x+b$。
- 若 $o=1$ 则 $val(x)=f(\operatorname{popcount}(x+a))+b$。

合并信息 $A,B$ 的时候：

- 若 $o_B=0$，可以简单处理，$b_A\gets b_A+b_B$。
- 否则若 $o_A=0$，则需要启动映射，$o_A\gets1,a_A\gets b_A+b_B,f_A\gets f_B$。
- 否则叠上映射 $f_A[x]\gets f_B[\operatorname{popcount}(f_A[x]+b_A+a_B)],b_A\gets b_B$。

区间加 $x$：叠上一个这样的信息：$o=a=f=0,b=x$。

区间取 $\operatorname{popcount}$：$o=1,a=b=0,f[i]=i(0\le i<64)$。

复杂度 $O(n+q\log n\log V)$。

---

### T6：P9989

考虑一个这样的暴力，直接遍历所有 $a_i$，给他们和 $x$ 取 $\gcd$。

显然过不了，考虑剪枝：如果有 $a_i\mid x$，那么取 $\gcd$ 不改变 $a_i$ 的值，直接跳过。

用线段树去实现这个过程：维护区间 $\operatorname{lcm}$，如果 $\operatorname{lcm}\mid x$ 就直接返回，遇到叶子就直接修改，否则继续递归。

一个小细节：注意到 $\operatorname{lcm}$ 可能很大，但 $x$ 只有 $10^{18}$，所以 $\operatorname{lcm}$ 比 $10^{18}$ 大可以标记为 $-1$。

然后你发现过了。为什么呢？

考虑如果 $a_i\nmid x$，则 $\gcd(a_i,x)$ 比 $a_i$ 至少少了一个质因数，即 $\gcd(a_i,x)\le\dfrac{a_i}2$。

当 $a_i=1$ 时显然不会再被修改，于是一个 $a_i$ 只会被修改 $\log V$ 次。总共递归到的叶子数量就是 $n\log V$。

算上线段树的复杂度，总的时间复杂度为 $O(n\log n\log V+q\log n)$。

---

### T7：CF739C

在差分数组上做，相当于找一段区间，使得前一段为正，后一段为负。区间加也变成了单点修改，容易维护。

考虑在每个结点上维护：$lv,rv,mv$ 分别表示 包含左端点/包含右端点/不限制 的答案。

发现不方便合并，记 $ld,rd$ 表示左右端点的值。

如果左儿子的右端点为正，或右儿子的左端点为负，那么它们包含端点的答案一定有一个是没有拐点的，这样就可以合并，否则不可以合并。

其他的信息合并应该是比较 trival 的，做过 GSS 系列题目应该很熟练了。

复杂度 $O(n+q\log n)$。

---

### T8：P9990

把询问挂在左端点上，对每个 $l$ 维护有多少个以 $l$ 为左端点的颜色数为 奇数/偶数 的区间数量 $s_{0/1}$，询问即 $s_1$ 区间和。

每次 $r\to r+1$，真正被改变的只有 $a_{r+1}$ 上一次出现的位置 $+1$ 到 $r+1$ 这个区间，区间交换 $s_0,s_1$ 即可。

具体实现上，线段树每个结点维护 $[s_0,s_1,s]$ 表示区间 奇数/偶数 个数和偶数个数的历史和。

矩阵线段树即可，轻微卡常。$O((n+q)\log n)$。