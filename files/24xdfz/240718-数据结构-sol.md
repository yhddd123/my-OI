### T1：CF992E

记 $s_i$ 为前缀和数组，如果 $a_i\ge s_{i-1}$，则有 $s_i\ge2s_{i-1}$，这样的点只有 $O(\log V)$ 个。

直接遍历所有 $a_i\ge s_{i-1}$ 的点，判断是否恰好取等即可。

线段树维护区间 $a_i-s_{i-1}$ 的最大值，单点修改相当于单点加和后缀减。

查询的时候直接暴力递归最大值 $\ge 0$ 的结点，复杂度 $O(m\log V\log n)$。

---

### T2：CF1771F

随机异或哈希，二分答案 $x$，检查所有值域在 $[1,x]$ 中的数的哈希值异或和是否非 $0$。

由于区间询问，直接建出主席树维护哈希值，主席树上二分。

---

### T3：QOJ8672

把询问挂在 $R$ 上，记 $w_{L,R}=f_R(f_{R-1}(\dots f_L(0)))$，可以证明 $w_{i,R}$ 关于 $i$ 有单调性。

那么 $R\to R+1$ 时直接二分出 $l_{R+1}$ 和 $r_{R+1}$ 对应的段，做区间加即可，复杂度 $O(n\log n)$。

---

### T4：LOJ2055

区间排序不是很可做。

二分答案 $k$，将小于 $k$ 的数标记为 $0$，其他标记为 $1$。

每次排序将区间的 $0$ 和 $1$ 放到左右两侧，相当于区间推平操作。

线段树维护，检查最后 $p$ 位置是否为 $1$。

---

### T5：QOJ3061

将询问暴力跳到第 $1$ 列，然后整圈跳，最后剩下的暴力跳。

倍增，维护第一列第 $i$ 个格子跳 $2^j$ 圈后到的格子。

发现 $x$ 坐标每次移动必然增加 $1$，在列上建线段树。

线段树每个节点维护区间 $l,r$ 的一个数组 $f$，表示第 $l$ 列第 $i$ 个格子到第 $r$ 列第 $f_i$ 个格子。

每次修改 $(x,y)$ 只影响第 $x-1$ 列答案，即单点修改。

---

### T6：P3391

记录序列为若干个区间，形如 $a_l\sim a_r$ 是值为 $vl\sim vr$ 的公差为 $1$ 或 $-1$ 的等差数列。

翻转操作将两端区间分裂并将中间所有区间翻转。

注意到一次翻转总区间数增加 $O(1)$ 个，于是可以每翻转 $O(\sqrt n)$ 次暴力重构，重构时使用映射使 $a$ 重新变成 $1\sim n$。

---

### T7：QOJ6142

记 $w$ 为 $u,v$ 的 lca，把路径 $u\to v$ 分成 $u\to w$ 和 $w\to v$。

主席树处理出一个点的祖先中第一个点权为自己 $+1/-1$ 的点，倍增可实现若干步跳跃。

先求出 $u\to w$ 的答案 $x_0$，再二分最终答案 $x$，主席树查 $v$ 祖先中第一个 $x$，看从这个点到 $w$ 之前能不能跳到 $x_0$ 即可。

复杂度 $O(n\log^2n)$。

---

### T8：P4497

对于第一问：

- 贪心选所有极长上升段的首尾，记差分数组 $d$，$\mathrm{ans}=\sum\limits_{i=2}^n\max\{0,d_i\}$。

对于第二问：

- 每个 $d_i<0$ 的段中 $B$ 可以做一个前缀和一个和前缀无交的后缀，那么操作这一段的贡献就是 $\operatorname{sum}-\min$。

- 因为要操作数尽可能少，一定是选 $\operatorname{sum}-\min$ 最大的一些段操作，权值线段树上二分即可。

对于修改：

- 区间修改变成的单点修改。第一问减去原来的再加上新的即可。

- 第二问 set 维护 $d_i<0$ 的段，在权值线段树上更新被修改的段即可，还需要一个区间求和和区间最值的线段树。

复杂度 $O(n\log V)$，用平衡树代替权值线段树可以做到 $O(n\log n)$。