题目用 ppt 但 sol 用 md 的原因是 ppt 打公式太坐牢了。

### Copy and Paste 3（P9523）

打字方法一定是先打出来一个串，用操作 2 剪切掉，然后只进行操作 1 或 3 打出最后的文本串。

考虑区间 DP，设 $f_{i, j}$ 表示打出文本串的子串 $[i, j]$ 需要的最少时间。朴素的转移为枚举 $[i, j]$ 的子串 $[l, r]$，令 $t$ 为 $[i, j]$ 中至多能找到几个不重叠的子串 $[l, r]$，转移 $f_{i, j} = \min\{f_{i, j}, [i-j+1 - (r-l+1)t]a + b + tc + f_{l, r}\}$。

改为枚举 $[l, r]$ 和 $t$，找到最小的区间 $[i, j]$ 满足 $j = r$ 且 $[i, j]$ 内能找到 $t$ 个不重叠 $[l, r]$，然后做一次上述转移。还需要加一个二维前缀 $\min$，也就是 $f_{i, j} = \min\{f_{i, j}, f_{i + 1, j} + a, f_{i, j - 1} + a\}$。这样做的复杂度 $O(n^2 \log n)$，其中 $\log n$ 是调和级数。

找 $[i, j]$ 也不难，预处理出每个区间 $[l, r]$ 上一次出现且不与 $[l, r]$ 重合的位置（也就是最大的 $x$ 使得 $x - l + r < l$ 且子串 $[l, r]$ 和 $[x, x - l + r]$ 相同）。在 $O(n^2)$ 预处理了任意两个后缀的 $\mathrm{lcp}$ 之后是容易的。 

### Goldfish and pikes（qoj1249）

显然大鱼每次会吃掉比自己小的最大的鱼。如果大鱼吃掉某条鱼之后就可以去吃之前吃不了的鱼，称这种情况为“升级”，否则只能吃更小的鱼。可以发现升级只会出现 $O(\log V)$ 次，因为设 $x_i$ 表示大鱼第 $i$ 次升级之后吃的第一条鱼，可以发现 $x_i \geq 2x_{i-2}$。

把鱼按大小排序，两次升级之间肯定是吃了一段区间，因此可以大力拿平衡树或动态开点线段树通过树上二分解决。复杂度 $O(n \log n + q \log V \log n)$。

### Easy Jump（gym103687E）

设 $f_{i, j, k}$ 表示当前在关卡 $i$，血量蓝量分别为 $j, k$ 时，通关的期望时间。

在一个不能回蓝的关卡，血量大于 $2$ 时回血是没有意义的，回血时有蓝不用也是没有意义的（除非 $T_2 \leq T_1$）。

在可以回蓝的关卡，可以感受出来最优决策是血量低于一个阈值时回血，否则不回。由于此时蓝量一定等于 $S$，所以直接枚举阈值取最优即可。

两部分复杂度分别为 $O(nSH)$ 和 $O(nH^2)$。

事实上，由于蓝量不满一定是因为血量恰等于 $2$，而阈值也不用枚举，可以直接算（虽然我不会），故复杂度其实能做到 $O(n(S+H))$。

### Maze Game（UTPC2021L）

结论：如果起点终点之间有割点，显然 Alice 必胜，否则非障碍格有奇数个 Alice 胜，否则 Bob 胜。

结论前半句显然，后半句是因为 Alice 和 Bob 一定不会让图出现割点，所以最后图上一定仅剩下两条不相交的从起点到终点的路径，而由于网格图是二分图，这两条路径的长度奇偶性一定相同，长度之和一定是偶数，所以只需要知道一开始非障碍格的数量奇偶性即可。

### EllysNim（TopCoder SRM785 R1 - Div1. Lv3）

$100$ 的数据范围是骗人的，做法其实是直接贪心。

从高到低枚举每一位 $d$，把所有数对 $2^{d + 1}$ 取模，因为更高的位已经确定了，不会再修改。可以选择若干 $< 2^d$ 的数改成 $2^d$，以此来修改这一位的异或和。

这些被改成 $2^d$ 的数在更小的 $d$ 处会被直接当成 $0$，有几个相关的性质：

1. 如果当前有一个数为 $0$，那么它之后也一直会 $= 0$，
2. 如果当前有很多个 $0$，显然只修改其中一个而不是每个都改肯定更优，因为异或和不超过直接加和。
3. 如果当前已经有一个数为 $0$ 或 $2^d$ 了，那么至多再拉一个 $2^d$ 来改变异或值，因为如果把两个值 $a, b$ 都拉到 $2^d$ 花费 $2^{d+1} - a - b$，而由于结论 2 这些数又不会再用上，所以不如拉到较大值花费 $|a - b|$。
4. 每次操作肯定会先拉值最大的到 $2^d$，不然比如 $a < b$，把 $a$ 改成了 $2^d$ 而不改变 $b$，不如把 $b$ 改成 $2^d$ 而在之后有需要的时候可以把 $a$ 改成 $b$。

因此枚举第一次出现 “把数改成 $2^d$” 的操作的位 $d$，要求 $d + 1$ 及更高的位异或和为 $0$，根据第 $d$ 位异或和拉一个最大值，或两个最大次大值，然后再跑前 $d - 1$ 位，如果当前位异或和为 $0$ 就拉一个最大值上来，否则跳过。

暴力实现，复杂度 $O(n \log^2 V)$，基数排序然后预处理 $\bmod 2^{d+1}$ 下前若干大之类的操作应该能再压一个 $\log V$，但没必要。

### Student's Camp（CF708E）

容易想到 $O(nm^2)$ DP：$f_{i, j, k}$ 表示前 $i$ 行联通，第 $i$ 行剩下的区间是 $[j, k]$ 的概率。

发现两个集合有交的情况很难判断，但无交的情况是 $l_1 > r_2 \or r_1 < l_2$，两个式子不可能同时满足，因此发现只记录 $f_{i, j}$ 表示第 $i$ 行左端点是 $j$ 和 $g_{i, j}$ 表示第 $i$ 行右端点是 $j$ 两种状态，就可以通过减去不合法情况来转移，用前缀和优化到 $O(nm)$。

### Lazy Numbers（CF1870F）

由于长度相同的数字典序排名也随值的增加而增加，所以考虑枚举长度，同时需要枚举该数与 $n$ 的字典序大小关系。设 $n$ 的长度为 $m$。

对于一个长度为 $l + 1$ 的数 $x$（即 $x \in [k^l, k^{l+1})$），对于 $i + 1 \leq l + 1$，长度为 $i + 1$ 且字典序小于等于 $x$ 的数有 $\lfloor \frac{x}{k^{l - i}} \rfloor - k^i + 1$ 个，对于 $l + 1 < j + 1 \leq m$，长度为 $j + 1$ 且字典序小于等于 $x$ 的数有 $x^{j-l} - k^j$ 个。当然，当 $j+1 = m$ 且硬点 $x$ 的字典序大于 $n$ 的字典序时，数量应该是 $n - 2^m + 1$ 个。

因此列出式子：$x = (\sum\limits_i \lfloor \frac{x}{k^{l-i}} \rfloor - k^i + 1) + (\sum\limits_j x^{j-l} - k^j)$，把左边的 $x$ 与右边第一个和式中 $i=l$ 时的 $x$ 抵消，然后把右式中的所有与 $x$ 无关的常数放到左边，得到一个形如 $f(x) = C$ 的限制，而且根据形式不难发现 $f(x)$ 单调。

直接二分出一个符合条件的区间 $[l, r]$，再结合该数与 $n$ 的字典序大小关系（也就是多一条类似 $x \geq a$ 或 $x \leq b$ 的平凡限制）就能数出个数，复杂度 $O(Tm^2 \log n)$。

实际上还能更快一点，可以根据式子的形式注意到 $x = \sum k^i a_i(0 \leq a_i < k) \implies f(x) = \sum a_if(k^i)$，即 $f$ 关于每一位独立，因此直接按位确定可以做到 $O(T m^2)$。

### 老虎机（P9379）

显然需要一个状压 DP，设 $f_{S}$ 表示当前未知的集合为 $S$ 还期望要猜多少次，跑一次复杂度 $O(3^l)$ 或者用 cdq 做到更低，暴力就是枚举每一个字符串，然后把能唯一确定该字符串的 $S$ 设为初态 $f_S = 0$。

希望通过合理的魔改一下使得 DP 可以逆过来从而实现多测。可以把原问题魔改成：如果唯一确定了字符串，那么再猜就是免费的，不用花费次数。这样一来 DP 的初态始终只有 $f_{\emptyset} = 0$，每次相当于有些地方的 $f_S = \sum p_{S \to T}f_T + v_{S}$ 要把 $v_S$ 改成 $0$。而每个 $v_S$ 对答案的贡献显然是独立的，因此只需要累加就能得到答案。

计算每个字符串对应哪些 $v_S$ 也并不难，状压一个 $3^l$ 的状态 $g_i$，每一位为 $0, 1$ 表示已知字符串这一位为 $0, 1$，否则未知，值为 $0$ 表示不存在这样的串，为 $-1$ 表示存在多个，否则表示那个唯一字符串的编号。转移可以考虑 $g_i = merge(g_{i - 3^k}, g_{i - 2\cdot3^k})$，其中 $i$ 的第 $k$ 位为 $2$。

复杂度 $O(T3^l)$。

### Subset（gym103428B）

考虑一种反演的思想：先求出 $f_m$ 表示选 $m$ 个可以相同的数满足条件的方案数，然后反推 $g_m$ 表示选 $m$ 个不能相同的数满足条件的方案数。这里 $f$ 和 $g$ 都是有顺序的，选三个数 $1, 1, 2$ 和 $2, 1, 1$ 是不同的方案，最终答案为 $\frac{g}{m!}$。

$f_m$ 是容易求的，数位 DP 枚举哪一位出现了不卡上界的数（说明之后可以随便改）然后瞎数数可以求出 $f_1, f_2, \dots, f_m$。

考虑把 $f$ 映射到 $g$，把 $f_a$ 中的某一种方案进行如此映射：对于每个数 $x$，如果方案中有偶数个 $x$ 则全部删去，否则只保留第一个 $x$，然后把未被删去的元素按原顺序写下，就映射到了某个 $g_b(b \leq a)$ 中的方案。

对于某个 $g_b$ 中的方案，数被几个 $f_a$ 中的方案映射到了，发现只与 $n, m$ 有关，与具体方案无关，说明 $g_b$ 对 $f_a$ 的贡献是固定的，最终应该能写出一个形如 $f_a = \sum\limits_{b \leq a} g_b c_{a, b}$ 的东西，从而解出 $g$。

求 $c_{a, b}$ 考虑大力定义 $h_{i, j}$ 表示往序列里放了 $i$ 个数，目前出现奇数次的数有 $j$ 个，转移即考虑枚举第 $i + 1$ 个数在不在 $j$ 个数里面。则有 $c_{a, b} = \frac{h_{a, b}}{n^{\underline b}}$。

原题解有一个我没看懂的 $O(m \log m \log^2 n)$ 做法，上述做法也可以进一步用生成函数和多项式科技优化，但我也不会。

### Addition without carry（P9293）

先确定答案的最高位最小是多少。欲判断最高位为 $p$ 是否可行，可以找出当前最大的 $a_i$，设其位数为 $l_i$，把 $p$ 这一位的 $1$ 分配给它，如果 $l_i > p$ 说明这个操作非法，验证失败，$l_i < p$ 就可以直接把 $a_i$ 删去，$l_i = p$ 就把 $a_i$ 删去最高位后塞回序列。然后将 $p$ 减小 $1$，继续检验直到序列 $a$ 被删空。

注意到如果一开始将 $a$ 降序排序，令 $h = \max\limits_{1\leq i\leq n} l_i+i-1$，如果 $p = h+1$ 一定可行，$p < h$ 一定不可行，所以实际上只需要检验 $p = h$ 的情况。

考虑定义 $check(a, p)$ 表示检验序列 $a$ 的答案最高位是否小于等于 $p$，如果是则顺带返回问题答案。其流程如下：

如果 $h > p$ 直接返回 F。

检验最高位是否能等于 $h$，找到最小的 $i$ 满足 $l_i + i - 1 = h$，将 $h \sim h-i+1$ 分配给 $a_1 \sim a_i$，删去 $a_1 \sim a_{i - 1}$ 并删去 $a_i$ 的最高位，然后递归调用 $check(a, h - i)$，如果该递归调用返回 T 则直接返回答案。

否则说明最高位只能大于 $h$。如果 $p = h$ 则返回 F，否则将方案改为 $h + 1 \sim h - i + 2$ 分配给 $a_1 \sim a_i$，删去 $a_1 \sim a_i$ 并递归调用 $check(a, h - i + 1)$（这次调用必定返回 T）并返回方案。

通过基排预处理 $a_i$ 去掉最高的若干个 $1$ 后的排名，可以拿线段树或平衡树维护 $a$ 序列和 $h$。

令 $L = \sum l_i$，则可以说明上述算法的复杂度为 $O(L \log L)$：

对于成功的 $check$，复杂度总和是答案中 $1$ 的个数乘上数据结构的复杂度，也就是 $O(L \log L)$，因此只需要计算失败的 $check$ 的复杂度总和。

一个 $check$ 如果失败，说明它只进行了一次 $check$ 的递归调用（而且这次调用也失败了），因此一次失败的 $check(a, p)$ 与其所有递归调用的复杂度总和为 $T(check(a, p)) = T(check(a, p - i)) + O(i\log L) = O(p \log L)$。如果有某个 $check$ 中调用了一次失败的 $check$，并调用了第二次 $check$，那么第一次的复杂度为 $O(l_i \log P)$，在第二次调用中 $a_i$ 被删去，故 $l_i$ 不会再对复杂度有贡献，因此总复杂度为 $\sum O(l_i\log L) = O(L \log L)$。

### Alice、Bob 与 DFS（loj3633）

约定 $e_{x, i}$ 表示 $x$ 的第 $i$ 条出边，$m_x$ 为 $x$ 的出度，$E(x) = [e_{x, m_x}, e_{x, m_x - 1}, \dots, e_{x, 1}]$，即倒序的出边，序列的加法为首尾拼接。

用栈模拟 `dfs` 的过程：一开始的栈是 $E(r)$，这些栈中的点是有颜色的，但是并不是这些点本身的颜色，而是 $r$ 的颜色。一名玩家可以干的事情是：从栈顶 `pop` 若干个白色元素，如果栈空了说明程序结束了，没空就需要拎一个栈顶 $t$ 出来，然后把 $E(t)$ 按顺序 `push` 进栈中，颜色均为点 $t$ 本身的颜色。接下来把栈当作状态。

先解决全是白点的情况。

考察单独调用 `dfs(x)`（即状态 $E(x)$），和某次把 $x$ 作为栈顶拿出来的差异（假设是状态 $[v_1, v_2, \dots, v_k] + E(x)$）。发现如果在后者操作的过程中始终不把栈 `pop` 到 $v_k$ 及以前的话，那么两者没有差异，但是后者可以在任意时刻把栈 `pop` 到 $v_i$，然后转移到额外状态 $[v_1, v_2, \dots, v_{i - 1}] + E(v_i)$，设这个状态的 $SG$ 值为 $s_i$，$S = \{s_1, s_2, \dots, s_k\}$。可以认为，前者的 $SG$ 函数相当于在 $\mathbb N$ 上求 $\mathrm{mex}$，后者就是在 $\mathbb N \setminus S$ 上求 $\mathrm{mex}$。如果前者的 $SG$ 值为 $k$，后者的 $SG$ 值就是 $\mathbb N \setminus S$ 的第 $k+1$ 小。

令 $f_x$ 表示 $E(x)$ 的 $SG$ 值，则需要对于 $1 \leq i \leq m_x$，计算状态 $[e_{x, m_x}, e_{x, m_x - 1}, \dots, e_{x, i + 1}] + E(e_{x, i})$ 的 $SG$ 值，这些值的 $\mathrm{mex}$ 就是 $f_x$，用上一段的方法依次考虑从后往前考虑 $e_{x, i}$，用树状数组求第 $k$ 小即可。

接下来考虑加入黑点的情况。

同样考察黑点 $x$ 的 $E(x)$ 的 $SG$ 值与能转移到的额外状态 $S$ 之间的关系，首先每 `push` 一个黑色元素都会让 $S$ 清空，而且由于黑点不能 `pop`，所以状态只有一个转移，因此其 $SG$ 值 $\in \{0, 1\}$（这里利用了 $E(x) \neq \emptyset$ 的性质，因此要把无出边的黑点当白点），且仅关心 $S$ 中是否有 $0$。同时注意到，对于白点，它可能不理解黑点的 $SG$ 值等于 $1$ 到底是 $1$ 本身，还是 $\mathbb N \setminus S$ 的次小值，所以还需要记录 $S$ 中是否有 $1$。

因此可以用 $f_{x, 0/1, 0/1}$ 表示状态 $E(x)$，额外状态 $S$ 是否有 $0$ 和 $1$ 的 $SG$ 值。如果该值 $\leq 1$ 说明这是 $SG$ 值本身，否则说明是 $\mathbb N \setminus S \setminus \{0, 1\}$ 的第 $f_{x, 0/1, 0/1} - 1$ 小值。最终某个 $E(x)$ 本身的 $SG$ 值就是 $f_{x, 1, 0}$。
